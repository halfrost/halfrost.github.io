<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Halfrost&#39;s Field | 冰霜之地</title>
    <description>嗨，我是于德志 (@halfrost)，一名来自中国的 iOS 开发者，已退役 acmer 。现居上海。吾笃信：德不孤，必有志，技不疏，必有朋。</description>
    <link>http://vno.onevcat.com/</link>
    <atom:link href="http://vno.onevcat.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 07 Sep 2016 02:31:25 +0800</pubDate>
    <lastBuildDate>Wed, 07 Sep 2016 02:31:25 +0800</lastBuildDate>
    <generator>Jekyll v3.1.6</generator>
    
      <item>
        <title>深入研究Block用weakSelf、strongSelf、@weakify、@strongify解决循环引用</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-d3d8244be4e6059f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;前言&lt;/h4&gt;
&lt;p&gt;在上篇中，仔细分析了一下Block的实现原理以及__block捕获外部变量的原理。然而实际使用Block过程中，还是会遇到一些问题，比如Retain Circle的问题。&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;目录&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;1.Retain Circle的由来&lt;/li&gt;
  &lt;li&gt;2.__weak、__strong的实现原理&lt;/li&gt;
  &lt;li&gt;3.weakSelf、strongSelf的用途&lt;/li&gt;
  &lt;li&gt;4.@weakify、@strongify实现原理&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;retain-circle&quot;&gt;一. Retain Circle的由来&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-2eb65c853e014ed3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;循环引用的问题相信大家都很理解了，这里还是简单的提一下。&lt;/p&gt;

&lt;p&gt;当A对象里面强引用了B对象，B对象又强引用了A对象，这样两者的retainCount值一直都无法为0，于是内存始终无法释放，导致内存泄露。所谓的内存泄露就是本应该释放的对象，在其生命周期结束之后依旧存在。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-aeffe9c77bf9ef5c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这是2个对象之间的，相应的，这种循环还能存在于3，4……个对象之间，只要相互形成环，就会导致Retain Cicle的问题。&lt;/p&gt;

&lt;p&gt;当然也存在自身引用自身的，当一个对象内部的一个obj，强引用的自身，也会导致循环引用的问题出现。常见的就是block里面引用的问题。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-e6f47d76a23b40c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;weakstrong&quot;&gt;二.__weak、__strong的实现原理&lt;/h4&gt;

&lt;p&gt;在ARC环境下，id类型和对象类型和C语言其他类型不同，类型前必须加上所有权的修饰符。&lt;/p&gt;

&lt;p&gt;所有权修饰符总共有4种：&lt;/p&gt;

&lt;p&gt;1.__strong修饰符
2.__weak修饰符
3.__unsafe_unretained修饰符
4.__autoreleasing修饰符&lt;/p&gt;

&lt;p&gt;一般我们如果不写，默认的修饰符是__strong。&lt;/p&gt;

&lt;p&gt;要想弄清楚__strong，__weak的实现原理，我们就需要研究研究clang(LLVM编译器)和objc4 Objective-C runtime库了。&lt;/p&gt;

&lt;p&gt;关于clang有一份&lt;a href=&quot;http://clang.llvm.org/docs/AutomaticReferenceCounting.html&quot;&gt;关于ARC详细的文档&lt;/a&gt;，有兴趣的可以仔细研究一下文档里面的说明和例子，很有帮助。&lt;/p&gt;

&lt;p&gt;以下的讲解，也会来自于上述文档中的函数说明。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-8ba2276f15bbfd49.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;strong&quot;&gt;1.__strong的实现原理&lt;/h5&gt;

&lt;h6 id=&quot;section-2&quot;&gt;(1)对象持有自己&lt;/h6&gt;

&lt;p&gt;首先我们先来看看生成的对象持有自己的情况，利用alloc/new/copy/mutableCopy生成对象。&lt;/p&gt;

&lt;p&gt;当我们声明了一个__strong对象&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;__strong&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;[[NSObject&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;alloc]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;init];&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;LLVM编译器会把上述代码转换成下面的样子&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
id __attribute__((objc_ownership(strong))) obj = ((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;NSObject&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;init&quot;));
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;相应的会调用&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;id obj = objc_msgSend(NSObject, @selector(alloc));
objc_msgSend(obj,selector(init));
objc_release(obj);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上述这些方法都好理解。在ARC有效的时候就会自动插入release代码，在作用域结束的时候自动释放。&lt;/p&gt;

&lt;h6 id=&quot;section-3&quot;&gt;(2)对象不持有自己&lt;/h6&gt;

&lt;p&gt;生成对象的时候不用alloc/new/copy/mutableCopy等方法。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;__strong&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;[NSMutableArray&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;array];&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;LLVM编译器会把上述代码转换成下面的样子&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
id __attribute__((objc_ownership(strong))) array = ((NSMutableArray *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;NSMutableArray&quot;), sel_registerName(&quot;array&quot;));

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;查看LLVM文档，其实是下述的过程&lt;/p&gt;

&lt;p&gt;相应的会调用&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;id obj = objc_msgSend(NSMutableArray, @selector(array));
objc_retainAutoreleasedReturnValue(obj);
objc_release(obj);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;与之前对象会持有自己的情况不同，这里多了一个objc_retainAutoreleasedReturnValue函数。&lt;/p&gt;

&lt;p&gt;这里有3个函数需要说明：&lt;br /&gt;
1.id objc_retainAutoreleaseReturnValue(id value)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://clang.llvm.org/docs/AutomaticReferenceCounting.html#id69&quot;&gt;id objc_retainAutoreleaseReturnValue(id value);
&lt;/a&gt;&lt;a href=&quot;http://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-retainautoreleasereturnvalue&quot;&gt;&lt;/a&gt;
&lt;em&gt;Precondition:&lt;/em&gt; value is null or a pointer to a valid object.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;If value is null, this call has no effect. Otherwise, it performs a retain operation followed by the operation described in &lt;a href=&quot;http://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-autoreleasereturnvalue&quot;&gt;objc_autoreleaseReturnValue&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Equivalent to the following code:
id objc_retainAutoreleaseReturnValue(id value) { &lt;br /&gt;
       return objc_autoreleaseReturnValue(objc_retain(value));
}&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Always returns value&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;2.id objc_retainAutoreleaseReturnValue(id value)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://clang.llvm.org/docs/AutomaticReferenceCounting.html#id70&quot;&gt;id objc_retainAutoreleasedReturnValue(id value);
&lt;/a&gt;&lt;a href=&quot;http://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-retainautoreleasedreturnvalue&quot;&gt;&lt;/a&gt;
&lt;em&gt;Precondition:&lt;/em&gt; value is null or a pointer to a valid object.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;If value is null, this call has no effect. Otherwise, it attempts to accept a hand off of a retain count from a call to &lt;a href=&quot;http://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-autoreleasereturnvalue&quot;&gt;objc_autoreleaseReturnValue&lt;/a&gt; on value in a recently-called function or something it calls. If that fails, it performs a retain operation exactly like &lt;a href=&quot;http://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-retain&quot;&gt;objc_retain&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Always returns value&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;3.id objc_autoreleaseReturnValue(id value)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://clang.llvm.org/docs/AutomaticReferenceCounting.html#id59&quot;&gt;id objc_autoreleaseReturnValue(id value);
&lt;/a&gt;&lt;a href=&quot;http://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-autoreleasereturnvalue&quot;&gt;&lt;/a&gt;
&lt;em&gt;Precondition:&lt;/em&gt; value  is null or a pointer to a valid object.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;If value  is null, this call has no effect. Otherwise, it makes a best effort to hand off ownership of a retain count on the object to a call to&lt;a href=&quot;http://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-retainautoreleasedreturnvalue&quot;&gt;objc_retainAutoreleasedReturnValue&lt;/a&gt; for the same object in an enclosing call frame. If this is not possible, the object is autoreleased as above.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Always returns value&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这3个函数其实都是在描述一件事情。 it makes a best effort to hand off ownership of a retain count on the object to a call to objc_retainAutoreleasedReturnValue for the same object in an enclosing call frame。&lt;/p&gt;

&lt;p&gt;这属于LLVM编译器的一个优化。objc_retainAutoreleasedReturnValue函数是用于自己持有(retain)对象的函数，它持有的对象应为返回注册在autoreleasepool中对象的方法或者是函数的返回值。&lt;/p&gt;

&lt;p&gt;在ARC中原本对象生成之后是要注册到autoreleasepool中，但是调用了objc_autoreleasedReturnValue 之后，紧接着调用了 objc_retainAutoreleasedReturnValue，objc_autoreleasedReturnValue函数会去检查该函数方法或者函数调用方的执行命令列表，如果里面有objc_retainAutoreleasedReturnValue()方法，那么该对象就直接返回给方法或者函数的调用方。达到了即使对象不注册到autoreleasepool中，也可以返回拿到相应的对象。&lt;/p&gt;

&lt;h5 id=&quot;weak&quot;&gt;2.__weak的实现原理&lt;/h5&gt;

&lt;p&gt;声明一个__weak对象&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;__weak&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;strongObj;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;假设这里的strongObj是一个已经声明好了的对象。&lt;/p&gt;

&lt;p&gt;LLVM转换成对应的代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
id __attribute__((objc_ownership(none))) obj1 = strongObj;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;相应的会调用&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;id obj ;
objc_initWeak(&amp;amp;obj,strongObj);
objc_destoryWeak(&amp;amp;obj);

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;看看文档描述&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;[id objc_initWeak(id &lt;em&gt;object, id value);
](http://clang.llvm.org/docs/AutomaticReferenceCounting.html#id62)&lt;a href=&quot;http://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-initweak&quot;&gt;&lt;/a&gt;
*Precondition:&lt;/em&gt; object is a valid pointer which has not been registered as a __weak object. &lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;value  is null or a pointer to a valid object.
If value is a null pointer or the object to which it points has begun deallocation, object is zero-initialized. Otherwise, object
 is registered as a __weak object pointing to value&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Equivalent to the following code:
id objc_initWeak(id *object, id value) { &lt;br /&gt;
    *object = nil; 
    return objc_storeWeak(object, value);
}&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Returns the value of object after the call.
Does not need to be atomic with respect to calls to objc_storeWeak on object&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;objc_initWeak的实现其实是这样的&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
id objc_initWeak(id *object, id value) {   
    *object = nil; 
    return objc_storeWeak(object, value);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;会把传入的object变成0或者nil，然后执行objc_storeWeak函数。&lt;/p&gt;

&lt;p&gt;那么objc_destoryWeak函数是干什么的呢？&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;[void objc_destroyWeak(id &lt;em&gt;object);
](http://clang.llvm.org/docs/AutomaticReferenceCounting.html#id61)&lt;a href=&quot;http://clang.llvm.org/docs/AutomaticReferenceCounting.html#void-objc-destroyweak-id-object&quot;&gt;&lt;/a&gt;
*Precondition:&lt;/em&gt; object  is a valid pointer which either contains a null pointer or has been registered as a __weak object.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;object  is unregistered as a weak object, if it ever was. The current value of object is left unspecified; otherwise, equivalent to the following code:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;void objc_destroyWeak(id *object) { 
objc_storeWeak(object, nil);
}&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Does not need to be atomic with respect to calls to objc_storeWeak on object&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;objc_destoryWeak函数的实现&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void objc_destroyWeak(id *object) { 
    objc_storeWeak(object, nil);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;也是会去调用objc_storeWeak函数。objc_initWeak和objc_destroyWeak函数都会去调用objc_storeWeak函数，唯一不同的是调用的入参不同，一个是value，一个是nil。&lt;/p&gt;

&lt;p&gt;那么重点就都落在objc_storeWeak函数上了。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;[id objc_storeWeak(id &lt;em&gt;object, id value);
](http://clang.llvm.org/docs/AutomaticReferenceCounting.html#id73)&lt;a href=&quot;http://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-storeweak&quot;&gt;&lt;/a&gt;
*Precondition:&lt;/em&gt; object is a valid pointer which either contains a null pointer or has been registered as a __weak object. value
 is null or a pointer to a valid object.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;If value is a null pointer or the object to which it points has begun deallocation, object  is assigned null and unregistered as a __weak object. Otherwise, object is registered as a __weak object or has its registration updated to point to value&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Returns the value of object after the call.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;objc_storeWeak函数的用途就很明显了。由于weak表也是用Hash table实现的，所以objc_storeWeak函数就把第一个入参的变量地址注册到weak表中，然后根据第二个入参来决定是否移除。如果第二个参数为0，那么就把__weak变量从weak表中删除记录，并从引用计数表中删除对应的键值记录。&lt;/p&gt;

&lt;p&gt;所以如果__weak引用的原对象如果被释放了，那么对应的__weak对象就会被指为nil。原来就是通过objc_storeWeak函数这些函数来实现的。&lt;/p&gt;

&lt;p&gt;以上就是ARC中__strong和__weak的简单的实现原理，更加详细的还请大家去看看这一章开头提到的那个LLVM文档，里面说明的很详细。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-3c3eea3397b741f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;weakselfstrongself&quot;&gt;三.weakSelf、strongSelf的用途&lt;/h4&gt;

&lt;p&gt;在提weakSelf、strongSelf之前，我们先引入一个Retain Cicle的例子。&lt;/p&gt;

&lt;p&gt;假设自定义的一个student类&lt;/p&gt;

&lt;p&gt;例子1：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;cp&quot;&gt;#import &amp;lt;Foundation/Foundation.h&amp;gt;
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Study&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)();&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Student&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NSObject&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;copy&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nonatomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;copy&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nonatomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Study&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;study&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;cp&quot;&gt;#import &quot;ViewController.h&quot;
#import &quot;Student.h&quot;
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ViewController&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ViewController&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;viewDidLoad&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;super&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;viewDidLoad&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;  &lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Student&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;student&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Student&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;@&quot;Hello World&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;n&quot;&gt;student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;study&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSLog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;my name is = %@&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;到这里，大家应该看出来了，这里肯定出现了循环引用了。student的study的Block里面强引用了student自身。根据&lt;a href=&quot;http://www.jianshu.com/p/ee9756f3d5f6&quot;&gt;上篇文章&lt;/a&gt;的分析，可以知道，_NSConcreteMallocBlock捕获了外部的对象，会在内部持有它。retainCount值会加一。&lt;/p&gt;

&lt;p&gt;我们用Instruments来观察一下。添加Leak观察器。&lt;/p&gt;

&lt;p&gt;当程序运行起来之后，在&lt;strong&gt;Leak Checks&lt;/strong&gt;观察器里面应该可以看到红色的❌，点击它就会看到内存leak了。有2个泄露的对象。Block和Student相互循环引用了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-8c51133ef5b64e01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;打开Cycles &amp;amp; Roots 观察一下循环的环。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-b32b093f6ddf412c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里形成环的原因block里面持有student本身，student本身又持有block。&lt;/p&gt;

&lt;p&gt;那再看一个例子2：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#import &quot;ViewController.h&quot;
#import &quot;Student.h&quot;
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ViewController&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ViewController&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;viewDidLoad&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;super&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;viewDidLoad&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;  &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Student&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;student&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Student&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;  &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;@&quot;Hello World&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;n&quot;&gt;student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;study&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSLog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;my name is = %@&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;n&quot;&gt;student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;study&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我把block新传入一个参数，传入的是student.name。这个时候会引起循环引用么？&lt;/p&gt;

&lt;p&gt;答案肯定是不会。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-345a97d7a6eb607c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如上图，并不会出现内存泄露。原因是因为，student是作为形参传递进block的，block并不会捕获形参到block内部进行持有。所以肯定不会造成循环引用。&lt;/p&gt;

&lt;p&gt;再改一下。看例子3：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;cp&quot;&gt;#import &quot;ViewController.h&quot;
#import &quot;Student.h&quot;
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ViewController&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nonatomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nonatomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Student&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ViewController&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;viewDidLoad&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;super&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;viewDidLoad&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;  &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Student&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;student&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Student&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;  &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;@&quot;halfrost&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stu&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;  &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;n&quot;&gt;student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;study&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSLog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;my name is = %@&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;  &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;n&quot;&gt;student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;study&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样会形成循环引用么？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-4ec0577cf7a01f6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;答案也是否定的。&lt;/p&gt;

&lt;p&gt;ViewController虽然强引用着student，但是student里面的blcok强引用的是viewController的name属性，并没有形成环。如果把上述的self.name改成self，也依旧不会产生循环引用。因为他们都没有强引用这个block。&lt;/p&gt;

&lt;p&gt;那遇到循环引用我们改如何处理呢？？类比平时我们经常写的delegate，可以知道，只要有一边是__weak就可以打破循环。&lt;/p&gt;

&lt;p&gt;先说一种做法，利用__block解决循环的做法。例子4：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;cp&quot;&gt;#import &quot;ViewController.h&quot;
#import &quot;Student.h&quot;
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ViewController&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ViewController&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;viewDidLoad&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;super&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;viewDidLoad&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Student&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;student&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Student&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;  &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__block&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Student&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stu&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;@&quot;Hello World&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;n&quot;&gt;student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;study&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSLog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;my name is = %@&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;stu&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样写会循环么？看上去应该不会。但是实际上却是会的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-544bc137d452c71b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-92ae745538414431.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由于没有执行study这个block，现在student持有该block，block持有__block变量，__block变量又持有student对象。3者形成了环，导致了循环引用了。
想打破环就需要破坏掉其中一个引用。__block不持有student即可。&lt;/p&gt;

&lt;p&gt;只需要执行一下block即可。例子5：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;cp&quot;&gt;#import &quot;ViewController.h&quot;
#import &quot;Student.h&quot;
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ViewController&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ViewController&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;viewDidLoad&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;super&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;viewDidLoad&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Student&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;student&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Student&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;  &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;@&quot;Hello World&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__block&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Student&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stu&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;n&quot;&gt;student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;study&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSLog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;my name is = %@&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stu&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;n&quot;&gt;student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;study&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样就不会循环引用了。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-8d5dc8c77796e5b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;使用__block解决循环引用虽然可以控制对象持有时间，在block中还能动态的控制是__block变量的值，可以赋值nil，也可以赋值其他的值，但是有一个唯一的缺点就是需要执行一次block才行。否则还是会造成循环引用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;值得注意的是，在ARC下__block会导致对象被retain，有可能导致循环引用。而在MRC下，则不会retain这个对象，也不会导致循环引用。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;接下来可以正式开始讲讲weakSelf 和 strongSelf的用法了。&lt;/p&gt;

&lt;h5 id=&quot;weakself&quot;&gt;1.weakSelf&lt;/h5&gt;

&lt;p&gt;说道weakSelf，需要先来区分几种写法。
__weak __typeof(self)weakSelf = self;  这是AFN里面的写法。。&lt;/p&gt;

&lt;p&gt;#define WEAKSELF typeof(self) __weak weakSelf = self; 这是我们平时的写法。。&lt;/p&gt;

&lt;p&gt;先区分__typeof() 和 typeof()
由于笔者一直很崇拜AFNetWorking的作者，这个库里面的代码都很整洁，里面各方面的代码都可以当做代码范本来阅读。遇到不懂疑惑的，都要深究，肯定会有收获。这里就是一处，平时我们的写法是不带__的，AFN里面用这种写法有什么特殊的用途么？&lt;/p&gt;

&lt;p&gt;在SOF上能找到相关的&lt;a href=&quot;http://stackoverflow.com/questions/14877415/difference-between-typeof-typeof-and-typeof-objective-c&quot;&gt;答案&lt;/a&gt;：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;__typeof__() and __typeof() are compiler-specific extensions to the C language, because standard C does not include such an operator. Standard C requires compilers to prefix language extensions with a double-underscore (which is also why you should never do so for your own functions, variables, etc.)
typeof() is exactly the same, but throws the underscores out the window with the understanding that every modern compiler supports it. (Actually, now that I think about it, Visual C++ might not. It does support decltype() though, which generally provides the same behaviour as typeof().)
All three mean the same thing, but none are standard C so a conforming compiler may choose to make any mean something different.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其实两者都是一样的东西，只不过是C里面不同的标准，兼容性不同罢了。&lt;/p&gt;

&lt;p&gt;更加详细的&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc/Alternate-Keywords.html#Alternate-Keywords&quot;&gt;官方说明&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;那么抽象出来就是这2种写法。  &lt;br /&gt;
#define WEAKSELF  __weak typeof(self)weakSelf = self;
#define WEAKSELF typeof(self) __weak weakSelf = self;&lt;/p&gt;

&lt;p&gt;这样子看就清楚了，两种写法就是完全一样的。&lt;/p&gt;

&lt;p&gt;我们可以用WEAKSELF来解决循环引用的问题。例子6：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;cp&quot;&gt;#import &quot;ViewController.h&quot;
#import &quot;Student.h&quot;
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ViewController&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ViewController&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;viewDidLoad&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;super&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;viewDidLoad&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Student&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;student&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Student&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;  &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;@&quot;Hello World&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__weak&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;typeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;weakSelf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;  &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;n&quot;&gt;student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;study&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSLog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;my name is = %@&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;weakSelf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;n&quot;&gt;student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;study&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样就解决了循环引用的问题了。&lt;/p&gt;

&lt;p&gt;解决循环应用的问题一定要分析清楚哪里出现了循环引用，只需要把其中一环加上weakSelf这类似的宏，就可以解决循环引用。如果分析不清楚，就只能无脑添加weakSelf、strongSelf，这样的做法不可取。&lt;/p&gt;

&lt;p&gt;在上面的例子3中，就完全不存在循环引用，要是无脑加weakSelf、strongSelf是不对的。在例子6中，也只需要加一个weakSelf就可以了，也不需要加strongSelf。&lt;/p&gt;

&lt;p&gt;曾经在segmentfault也看到过这样一个问题，问：&lt;a href=&quot;https://segmentfault.com/q/1010000004343510&quot;&gt;为什么iOS的Masonry中的self不会循环引用?&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;

UIButton *testButton = [[UIButton alloc] init];
[self.view addSubview:testButton];
testButton.backgroundColor = [UIColor redColor];
[testButton mas_makeConstraints:^(MASConstraintMaker *make) {
    make.width.equalTo(@100);
    make.height.equalTo(@100);
    make.left.equalTo(self.view.mas_left);
    make.top.equalTo(self.view.mas_top);
}];
[testButton bk_addEventHandler:^(id sender) {
    [self dismissViewControllerAnimated:YES completion:nil];
} forControlEvents:UIControlEventTouchUpInside];

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;如果我用blocksKit的bk_addEventHandler
方法, 其中使用strong self, 该viewController就无法dealloc, 我理解是因为,self retain self.view, retain testButton, retain self. 但是如果只用Mansonry的mas_makeConstraints
方法, 同样使用strong self, 该viewController却能正常dealloc, 请问这是为什么, 为什么Masonry没有导致循环引用？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;看到这里，读者应该就应该能回答这个问题了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *))block {
    self.translatesAutoresizingMaskIntoConstraints = NO;
    MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:self];
    block(constraintMaker);
    return [constraintMaker install];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;del&gt;在Masonry这个block中，block仅仅捕获了self的translatesAutoresizingMaskIntoConstraints变量，但是并没有持有self。&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;上述描述有误，感谢@酷酷的哀殿 耐心指点&lt;/p&gt;

&lt;p&gt;更正如下：&lt;/p&gt;

&lt;p&gt;关于 Masonry ，它捕获了变量 self，然后对其执行了&lt;code class=&quot;highlighter-rouge&quot;&gt;setTranslatesAutoresizingMaskIntoConstraints:&lt;/code&gt;方法。但是，因为执行完毕后，block会被销毁，没有形成环。所以，没有引起循环依赖。&lt;/p&gt;

&lt;h5 id=&quot;strongself&quot;&gt;2.strongSelf&lt;/h5&gt;

&lt;p&gt;上面介绍完了weakSelf，既然weakSelf能完美解决Retain Circle的问题了，那为何还需要strongSelf呢？&lt;/p&gt;

&lt;p&gt;还是先从AFN经典说起，以下是AFN其中的一段代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
#pragma mark - NSOperation

- (void)setCompletionBlock:(void (^)(void))block {
    [self.lock lock];
    if (!block) {
        [super setCompletionBlock:nil];
    } else {
        __weak __typeof(self)weakSelf = self;
        [super setCompletionBlock:^ {
            __strong __typeof(weakSelf)strongSelf = weakSelf;

#pragma clang diagnostic push
#pragma clang diagnostic ignored &quot;-Wgnu&quot;
            dispatch_group_t group = strongSelf.completionGroup ?: url_request_operation_completion_group();
            dispatch_queue_t queue = strongSelf.completionQueue ?: dispatch_get_main_queue();
#pragma clang diagnostic pop

            dispatch_group_async(group, queue, ^{
                block();
            });

            dispatch_group_notify(group, url_request_operation_completion_queue(), ^{
                [strongSelf setCompletionBlock:nil];
            });
        }];
    }
    [self.lock unlock];
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果block里面不加__strong __typeof(weakSelf)strongSelf = weakSelf会如何呢？&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;cp&quot;&gt;#import &quot;ViewController.h&quot;
#import &quot;Student.h&quot;
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ViewController&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ViewController&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;viewDidLoad&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;super&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;viewDidLoad&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Student&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;student&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Student&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;@&quot;Hello World&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__weak&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;typeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;weakSelf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;  &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;n&quot;&gt;student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;study&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dispatch_after&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dispatch_time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DISPATCH_TIME_NOW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int64_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSEC_PER_SEC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dispatch_get_main_queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSLog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;my name is = %@&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;weakSelf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;n&quot;&gt;student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;study&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;my name is = (null)

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;为什么输出是这样的呢？&lt;/p&gt;

&lt;p&gt;重点就在dispatch_after这个函数里面。在study()的block结束之后，student被自动释放了。又由于dispatch_after里面捕获的__weak的student，根据第二章讲过的__weak的实现原理，在原对象释放之后，__weak对象就会变成null，防止野指针。所以就输出了null了。&lt;/p&gt;

&lt;p&gt;那么我们怎么才能在weakSelf之后，block里面还能继续使用weakSelf之后的对象呢？&lt;/p&gt;

&lt;p&gt;究其根本原因就是weakSelf之后，无法控制什么时候会被释放，为了保证在block内不会被释放，需要添加__strong。&lt;/p&gt;

&lt;p&gt;在block里面使用的__strong修饰的weakSelf是为了在函数生命周期中防止self提前释放。strongSelf是一个自动变量当block执行完毕就会释放自动变量strongSelf不会对self进行一直进行强引用。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;cp&quot;&gt;#import &quot;ViewController.h&quot;
#import &quot;Student.h&quot;
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ViewController&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ViewController&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;viewDidLoad&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;super&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;viewDidLoad&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Student&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;student&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Student&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;  &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;n&quot;&gt;student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;@&quot;Hello World&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__weak&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;typeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;weakSelf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;  &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;n&quot;&gt;student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;study&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__strong&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;typeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;strongSelf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;weakSelf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dispatch_after&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dispatch_time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DISPATCH_TIME_NOW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int64_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSEC_PER_SEC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dispatch_get_main_queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSLog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;my name is = %@&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strongSelf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;  &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;n&quot;&gt;student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;study&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;my name is = Hello World

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;至此，我们就明白了weakSelf、strongSelf的用途了。&lt;/p&gt;

&lt;p&gt;weakSelf 是为了block不持有self，避免Retain Circle循环引用。在 Block 内如果需要访问 self 的方法、变量，建议使用 weakSelf。&lt;/p&gt;

&lt;p&gt;strongSelf的目的是因为一旦进入block执行，假设不允许self在这个执行过程中释放，就需要加入strongSelf。block执行完后这个strongSelf 会自动释放，没有不会存在循环引用问题。如果在 Block 内需要多次 访问 self，则需要使用 strongSelf。&lt;/p&gt;

&lt;p&gt;关于Retain Circle最后总结一下，有3种方式可以解决循环引用。&lt;/p&gt;

&lt;p&gt;结合《Effective Objective-C 2.0》(编写高质量iOS与OS X代码的52个有效方法)这本书的例子，来总结一下。&lt;/p&gt;

&lt;p&gt;EOCNetworkFetcher.h&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EOCNetworkFetcherCompletionHandler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSData&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;EOCNetworkFetcher&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NSObject&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nonatomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;strong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readonly&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSURL&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;initWithURL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSURL&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;startWithCompletionHandler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EOCNetworkFetcherCompletionHandler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;completion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;EOCNetworkFetcher.m&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;EOCNetworkFetcher&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nonatomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;strong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readwrite&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSURL&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nonatomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EOCNetworkFetcherCompletionHandler&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;completionHandler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nonatomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;strong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSData&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;downloadData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;EOCNetworkFetcher&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;initWithURL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSURL&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;url&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;super&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_url&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;startWithCompletionHandler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EOCNetworkFetcherCompletionHandler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;completion&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;completionHandler&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;completion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//开始网络请求
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;dispatch_async&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dispatch_get_global_queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_downloadData&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSData&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;initWithContentsOfURL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;dispatch_async&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dispatch_get_main_queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
             &lt;span class=&quot;c1&quot;&gt;//网络请求完成
&lt;/span&gt;            &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;p_requestCompleted&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p_requestCompleted&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_completionHandler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_completionHandler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_downloadData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;EOCClass.m&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;k&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;EOCClass&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;EOCNetworkFetcher&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_networkFetcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;NSData&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_fetchedData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;downloadData&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;NSURL&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;url&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSURL&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;URLWithString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;http://www.baidu.com&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;_networkFetcher&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EOCNetworkFetcher&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;initWithURL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_networkFetcher&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;startWithCompletionHandler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSData&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_fetchedData&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在这个例子中，存在3者之间形成环&lt;/p&gt;

&lt;p&gt;1、completion handler的block因为要设置_fetchedData实例变量的值，所以它必须捕获self变量，也就是说handler块保留了EOCClass实例；&lt;/p&gt;

&lt;p&gt;2、EOCClass实例通过strong实例变量保留了EOCNetworkFetcher，最后EOCNetworkFetcher实例对象也会保留了handler的block。&lt;/p&gt;

&lt;p&gt;书上说的3种方法来打破循环。&lt;/p&gt;

&lt;p&gt;方法一：手动释放EOCNetworkFetcher使用之后持有的_networkFetcher，这样可以打破循环引用&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)downloadData {
    NSURL *url = [NSURL URLWithString:@&quot;http://www.baidu.com&quot;];
    _networkFetcher = [[EOCNetworkFetcher alloc] initWithURL:url];
    [_networkFetcher startWithCompletionHandler:^(NSData *data) {
        _fetchedData = data;
        _networkFetcher = nil;//加上此行，打破循环引用
    }];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;方法二：直接释放block。因为在使用完对象之后需要人为手动释放，如果忘记释放就会造成循环引用了。如果使用完completion handler之后直接释放block即可。打破循环引用&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
- (void)p_requestCompleted {
    if(_completionHandler) {
        _completionHandler(_downloadData);
    }
    self.completionHandler = nil;//加上此行，打破循环引用
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;方法三：使用weakSelf、strongSelf&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)downloadData {
   __weak __typeof(self) weakSelf = self;
   NSURL *url = [NSURL URLWithString:@&quot;http://www.baidu.com&quot;];
   _networkFetcher = [[EOCNetworkFetcher alloc] initWithURL:url];
   [_networkFetcher startWithCompletionHandler:^(NSData *data) {
        __typeof(&amp;amp;*weakSelf) strongSelf = weakSelf;
        if (strongSelf) {
            strongSelf.fetchedData = data;
        }
   }];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-59b08429238b088d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;weakifystrongify&quot;&gt;四.@weakify、@strongify实现原理&lt;/h4&gt;

&lt;p&gt;上面讲完了weakSelf、strongSelf之后，接下来再讲讲@weakify、@strongify，这两个关键字是RAC中避免Block循环引用而开发的2个宏，这2个宏的实现过程很牛，值得我们学习。&lt;/p&gt;

&lt;p&gt;@weakify、@strongify的作用和weakSelf、strongSelf对应的一样。这里我们具体看看大神是怎么实现这2个宏的。&lt;/p&gt;

&lt;p&gt;直接从源码看起来。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define weakify(...) \
    rac_keywordify \
    metamacro_foreach_cxt(rac_weakify_,, __weak, __VA_ARGS__)


#define strongify(...) \
    rac_keywordify \
    _Pragma(&quot;clang diagnostic push&quot;) \
    _Pragma(&quot;clang diagnostic ignored \&quot;-Wshadow\&quot;&quot;) \
    metamacro_foreach(rac_strongify_,, __VA_ARGS__) \
    _Pragma(&quot;clang diagnostic pop&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;看到这种宏定义，咋一看什么都不知道。那就只能一层层的往下看。&lt;/p&gt;

&lt;h5 id=&quot;weakify&quot;&gt;1. weakify&lt;/h5&gt;
&lt;p&gt;先从weakify(…)开始。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
#if DEBUG
#define rac_keywordify autoreleasepool {}
#else
#define rac_keywordify try {} @catch (...) {}
#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里在debug模式下使用@autoreleasepool是为了维持编译器的分析能力，而使用@try/@catch 是为了防止插入一些不必要的autoreleasepool。rac_keywordify 实际上就是autoreleasepool {}
的宏替换。因为有了autoreleasepool {}的宏替换，所以weakify要加上@，形成@autoreleasepool {}。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
#define metamacro_foreach_cxt(MACRO, SEP, CONTEXT, ...) \
        metamacro_concat(metamacro_foreach_cxt, metamacro_argcount(__VA_ARGS__))(MACRO, SEP, CONTEXT, __VA_ARGS__)

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;__VA_ARGS__：总体来说就是将左边宏中 … 的内容原样抄写在右边 __VA_ARGS__ 所在的位置。它是一个可变参数的宏，是新的C99规范中新增的，目前似乎只有gcc支持（VC从VC2005开始支持）。&lt;/p&gt;

&lt;p&gt;那么我们使用@weakify(self)传入进去。__VA_ARGS__相当于self。此时我们可以把最新开始的weakify套下来。于是就变成了这样：&lt;/p&gt;

&lt;p&gt;rac_weakify_,, __weak, __VA_ARGS__整体替换MACRO, SEP, CONTEXT, …&lt;/p&gt;

&lt;p&gt;这里需要注意的是，源码中就是给的两个”,”逗号是连着的，所以我们也要等效替换参数，相当于SEP是空值。&lt;/p&gt;

&lt;p&gt;替换完成之后就是下面这个样子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;autoreleasepool {}
metamacro_concat(metamacro_foreach_cxt, metamacro_argcount(self))(rac_weakify_, , __weak, self)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;现在我们需要弄懂的就是metamacro_concat 和 metamacro_argcount是干什么用的。&lt;/p&gt;

&lt;p&gt;继续看看metamacro_concat  的实现&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;

#define metamacro_concat(A, B) \
        metamacro_concat_(A, B)


#define metamacro_concat_(A, B) A ## B

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;## 是宏连接符。举个例子：&lt;/p&gt;

&lt;p&gt;假设宏定义为#define XNAME(n) x##n，代码为：XNAME(4)，则在预编译时，宏发现XNAME(4)与XNAME(n)匹配，则令 n 为 4，然后将右边的n的内容也变为4，然后将整个XNAME(4)替换为 x##n，亦即 x4，故 最终结果为 XNAME(4) 变为 x4。所以A##B就是AB。&lt;/p&gt;

&lt;p&gt;metamacro_argcount 的实现&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define metamacro_argcount(...) \
        metamacro_at(20, __VA_ARGS__, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)


#define metamacro_at(N, ...) \
        metamacro_concat(metamacro_at, N)(__VA_ARGS__)

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;metamacro_concat是上面讲过的连接符，那么metamacro_at, N = metamacro_atN，由于N = 20，于是metamacro_atN = metamacro_at20。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
#define metamacro_at0(...) metamacro_head(__VA_ARGS__)
#define metamacro_at1(_0, ...) metamacro_head(__VA_ARGS__)
#define metamacro_at2(_0, _1, ...) metamacro_head(__VA_ARGS__)
#define metamacro_at3(_0, _1, _2, ...) metamacro_head(__VA_ARGS__)
#define metamacro_at4(_0, _1, _2, _3, ...) metamacro_head(__VA_ARGS__)
#define metamacro_at5(_0, _1, _2, _3, _4, ...) metamacro_head(__VA_ARGS__)
#define metamacro_at6(_0, _1, _2, _3, _4, _5, ...) metamacro_head(__VA_ARGS__)
#define metamacro_at7(_0, _1, _2, _3, _4, _5, _6, ...) metamacro_head(__VA_ARGS__)
#define metamacro_at8(_0, _1, _2, _3, _4, _5, _6, _7, ...) metamacro_head(__VA_ARGS__)
#define metamacro_at9(_0, _1, _2, _3, _4, _5, _6, _7, _8, ...) metamacro_head(__VA_ARGS__)
#define metamacro_at10(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, ...) metamacro_head(__VA_ARGS__)
#define metamacro_at11(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, ...) metamacro_head(__VA_ARGS__)
#define metamacro_at12(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, ...) metamacro_head(__VA_ARGS__)
#define metamacro_at13(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, ...) metamacro_head(__VA_ARGS__)
#define metamacro_at14(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, ...) metamacro_head(__VA_ARGS__)
#define metamacro_at15(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, ...) metamacro_head(__VA_ARGS__)
#define metamacro_at16(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, ...) metamacro_head(__VA_ARGS__)
#define metamacro_at17(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, ...) metamacro_head(__VA_ARGS__)
#define metamacro_at18(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, ...) metamacro_head(__VA_ARGS__)
#define metamacro_at19(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, ...) metamacro_head(__VA_ARGS__)
#define metamacro_at20(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, ...) metamacro_head(__VA_ARGS__)

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;metamacro_at20的作用就是截取前20个参数，剩下的参数传入metamacro_head。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
#define metamacro_head(...) \
        metamacro_head_(__VA_ARGS__, 0)


#define metamacro_head_(FIRST, ...) FIRST

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;metamacro_head的作用返回第一个参数。返回到上一级metamacro_at20，如果我们从最源头的@weakify(self)，传递进来，那么metamacro_at20(self,20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)，截取前20个参数，最后一个留给metamacro_head_(1)，那么就应该返回1。&lt;/p&gt;

&lt;p&gt;metamacro_concat(metamacro_foreach_cxt, metamacro_argcount(self)) = metamacro_concat(metamacro_foreach_cxt, 1) 最终可以替换成metamacro_foreach_cxt1。&lt;/p&gt;

&lt;p&gt;在源码中继续搜寻。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
// metamacro_foreach_cxt expansions
#define metamacro_foreach_cxt0(MACRO, SEP, CONTEXT)
#define metamacro_foreach_cxt1(MACRO, SEP, CONTEXT, _0) MACRO(0, CONTEXT, _0)

#define metamacro_foreach_cxt2(MACRO, SEP, CONTEXT, _0, _1) \
    metamacro_foreach_cxt1(MACRO, SEP, CONTEXT, _0) \
    SEP \
    MACRO(1, CONTEXT, _1)

#define metamacro_foreach_cxt3(MACRO, SEP, CONTEXT, _0, _1, _2) \
    metamacro_foreach_cxt2(MACRO, SEP, CONTEXT, _0, _1) \
    SEP \
    MACRO(2, CONTEXT, _2)

#define metamacro_foreach_cxt4(MACRO, SEP, CONTEXT, _0, _1, _2, _3) \
    metamacro_foreach_cxt3(MACRO, SEP, CONTEXT, _0, _1, _2) \
    SEP \
    MACRO(3, CONTEXT, _3)

#define metamacro_foreach_cxt5(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4) \
    metamacro_foreach_cxt4(MACRO, SEP, CONTEXT, _0, _1, _2, _3) \
    SEP \
    MACRO(4, CONTEXT, _4)

#define metamacro_foreach_cxt6(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5) \
    metamacro_foreach_cxt5(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4) \
    SEP \
    MACRO(5, CONTEXT, _5)

#define metamacro_foreach_cxt7(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6) \
    metamacro_foreach_cxt6(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5) \
    SEP \
    MACRO(6, CONTEXT, _6)

#define metamacro_foreach_cxt8(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7) \
    metamacro_foreach_cxt7(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6) \
    SEP \
    MACRO(7, CONTEXT, _7)

#define metamacro_foreach_cxt9(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8) \
    metamacro_foreach_cxt8(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7) \
    SEP \
    MACRO(8, CONTEXT, _8)

#define metamacro_foreach_cxt10(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9) \
    metamacro_foreach_cxt9(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8) \
    SEP \
    MACRO(9, CONTEXT, _9)

#define metamacro_foreach_cxt11(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10) \
    metamacro_foreach_cxt10(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9) \
    SEP \
    MACRO(10, CONTEXT, _10)

#define metamacro_foreach_cxt12(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11) \
    metamacro_foreach_cxt11(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10) \
    SEP \
    MACRO(11, CONTEXT, _11)

#define metamacro_foreach_cxt13(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12) \
    metamacro_foreach_cxt12(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11) \
    SEP \
    MACRO(12, CONTEXT, _12)

#define metamacro_foreach_cxt14(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13) \
    metamacro_foreach_cxt13(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12) \
    SEP \
    MACRO(13, CONTEXT, _13)

#define metamacro_foreach_cxt15(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14) \
    metamacro_foreach_cxt14(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13) \
    SEP \
    MACRO(14, CONTEXT, _14)

#define metamacro_foreach_cxt16(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15) \
    metamacro_foreach_cxt15(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14) \
    SEP \
    MACRO(15, CONTEXT, _15)

#define metamacro_foreach_cxt17(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16) \
    metamacro_foreach_cxt16(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15) \
    SEP \
    MACRO(16, CONTEXT, _16)

#define metamacro_foreach_cxt18(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17) \
    metamacro_foreach_cxt17(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16) \
    SEP \
    MACRO(17, CONTEXT, _17)

#define metamacro_foreach_cxt19(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18) \
    metamacro_foreach_cxt18(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17) \
    SEP \
    MACRO(18, CONTEXT, _18)

#define metamacro_foreach_cxt20(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19) \
    metamacro_foreach_cxt19(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18) \
    SEP \
    MACRO(19, CONTEXT, _19)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;metamacro_foreach_cxt这个宏定义有点像递归，这里可以看到N 最大就是20，于是metamacro_foreach_cxt19就是最大，metamacro_foreach_cxt19会生成rac_weakify_(0,__weak,_18)，然后再把前18个数传入metamacro_foreach_cxt18，并生成rac_weakify_(0,__weak,_17)，依次类推，一直递推到metamacro_foreach_cxt0。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
#define metamacro\_foreach\_cxt0(MACRO, SEP, CONTEXT)

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;metamacro_foreach_cxt0就是终止条件，不做任何操作了。&lt;/p&gt;

&lt;p&gt;于是最初的@weakify就被替换成&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;autoreleasepool {}
metamacro_foreach_cxt1(rac_weakify_, , __weak, self)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
#define metamacro_foreach_cxt1(MACRO, SEP, CONTEXT, _0) MACRO(0, CONTEXT, _0)

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;代入参数&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;autoreleasepool {}
rac_weakify_（0,__weak,self）

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最终需要解析的就是rac_weakify_&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;

#define rac_weakify_(INDEX, CONTEXT, VAR) \
    CONTEXT __typeof__(VAR) metamacro_concat(VAR, _weak_) = (VAR);

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;把（0,__weak,self）的参数替换进来(INDEX, CONTEXT, VAR)。
INDEX = 0， CONTEXT = __weak，VAR = self，&lt;/p&gt;

&lt;p&gt;于是&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
CONTEXT __typeof__(VAR) metamacro_concat(VAR, _weak_) = (VAR);


等效替换为


__weak __typeof__(self) self_weak_ = self;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最终@weakify(self) = __weak __typeof__(self) self_weak_ = self;&lt;/p&gt;

&lt;p&gt;这里的self_weak_ 就完全等价于我们之前写的weakSelf。&lt;/p&gt;

&lt;h5 id=&quot;strongify&quot;&gt;2. strongify&lt;/h5&gt;

&lt;p&gt;再继续分析strongify(…)&lt;/p&gt;

&lt;p&gt;rac_keywordify还是和weakify一样，是autoreleasepool {}，只为了前面能加上@&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-obejctivec&quot;&gt;
_Pragma(&quot;clang diagnostic push&quot;) \
_Pragma(&quot;clang diagnostic ignored \&quot;-Wshadow\&quot;&quot;) \
_Pragma(&quot;clang diagnostic pop&quot;)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;strongify比weakify多了这些_Pragma语句。&lt;/p&gt;

&lt;p&gt;关键字_Pragma是C99里面引入的。_Pragma比#pragma（在设计上）更加合理，因而功能也有所增强。&lt;/p&gt;

&lt;p&gt;上面的等效替换&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-obejctivec&quot;&gt;
#pragma clang diagnostic push
#pragma clang diagnostic ignored &quot;-Wshadow&quot;
#pragma clang diagnostic pop

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的clang语句的作用:忽略当一个局部变量或类型声明遮盖另一个变量的警告。&lt;/p&gt;

&lt;p&gt;最初的&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define strongify(...) \
    rac_keywordify \
    _Pragma(&quot;clang diagnostic push&quot;) \
    _Pragma(&quot;clang diagnostic ignored \&quot;-Wshadow\&quot;&quot;) \
    metamacro_foreach(rac_strongify_,, __VA_ARGS__) \
    _Pragma(&quot;clang diagnostic pop&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;strongify里面需要弄清楚的就是metamacro_foreach 和 rac_strongify_。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define metamacro_foreach(MACRO, SEP, ...) \
        metamacro_foreach_cxt(metamacro_foreach_iter, SEP, MACRO, __VA_ARGS__)

#define rac_strongify_(INDEX, VAR) \
    __strong __typeof__(VAR) VAR = metamacro_concat(VAR, _weak_);

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们先替换一次，SEP = 空 ， MACRO = rac_strongify_ ， __VA_ARGS__ , 于是替换成这样。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
metamacro_foreach_cxt(metamacro_foreach_iter,,rac_strongify_,self)

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;根据之前分析，metamacro_foreach_cxt再次等效替换，metamacro_foreach_cxt##1(metamacro_foreach_iter,,rac_strongify_,self)&lt;/p&gt;

&lt;p&gt;根据&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
#define metamacro_foreach_cxt1(MACRO, SEP, CONTEXT, _0) MACRO(0, CONTEXT, _0)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;再次替换成metamacro_foreach_iter(0, rac_strongify_, self)&lt;/p&gt;

&lt;p&gt;继续看看metamacro_foreach_iter的实现&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;

#define metamacro_foreach_iter(INDEX, MACRO, ARG) MACRO(INDEX, ARG)

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最终替换成rac_strongify_(0,self)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
#define rac_strongify_(INDEX, VAR) \
    __strong __typeof__(VAR) VAR = metamacro_concat(VAR, _weak_);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;INDEX = 0, VAR = self,于是@strongify(self)就等价于&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
 __strong __typeof__(VAR) VAR = metamacro_concat(VAR, _weak_);

等价于

__strong __typeof__(self) self = self_weak_;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;注意@strongify(self)只能使用在block中，如果用在block外面，会报错，因为这里会提示你Redefinition of ‘self’。&lt;/p&gt;

&lt;p&gt;总结一下&lt;/p&gt;

&lt;p&gt;@weakify(self) = @autoreleasepool{} __weak __typeof__ (self) self_weak_ = self;&lt;/p&gt;

&lt;p&gt;@strongify(self) = @autoreleasepool{} __strong __typeof__(self) self = self_weak_;&lt;/p&gt;

&lt;p&gt;经过分析以后，其实@weakify(self) 和 @strongify(self) 就是比我们日常写的weakSelf、strongSelf多了一个@autoreleasepool{}而已，至于为何要用这些复杂的宏定义来做，目前我还没有理解。如果有大神指导其中的原因，还请多多指点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;更新&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;针对文章中给的例子3，大家都提出了疑问，为何没有检测出循环引用？其实这个例子有点不好。因为这个ViewController的引用计数一出来就是6，因为它被其他很多对象引用着。当然它是强引用了student，因为student的retainCount值是2。ViewController释放的时候才会把student的值减一。针对这个例子3，我重新抽取出中间的模型，重新举一个例子。&lt;/p&gt;

&lt;p&gt;既然ViewController特殊，那我们就新建一个类。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;cp&quot;&gt;#import &amp;lt;Foundation/Foundation.h&amp;gt;
#import &quot;Student.h&quot;
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Teacher&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NSObject&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;copy&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nonatomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nonatomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Student&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;cp&quot;&gt;#import &quot;ViewController.h&quot;
#import &quot;Student.h&quot;
#import &quot;Teacher.h&quot;
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ViewController&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ViewController&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;viewDidLoad&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;super&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;viewDidLoad&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;  &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Student&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;student&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Student&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Teacher&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;teacher&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Teacher&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;  &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;n&quot;&gt;teacher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;@&quot;i&#39;m teacher&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;n&quot;&gt;teacher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stu&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;  &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;n&quot;&gt;student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;@&quot;halfrost&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;  &lt;/span&gt; 
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;n&quot;&gt;student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;study&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSLog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;my name is = %@&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;teacher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;  &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;n&quot;&gt;student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;study&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-81da182083ef4625.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-3b483f1ccd94e77c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如图所示，还是出现了循环引用，student的block强引用了teacher，teacher又强引用了student，导致两者都无法释放。&lt;/p&gt;

</description>
        <pubDate>Mon, 05 Sep 2016 07:02:02+0800</pubDate>
        <link>http://vno.onevcat.com/2016/09/%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6Block%E7%94%A8weakSelf-strongSelf-@weakify-@strongify%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/</link>
        <guid isPermaLink="true">http://vno.onevcat.com/2016/09/%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6Block%E7%94%A8weakSelf-strongSelf-@weakify-@strongify%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/</guid>
        
        <category>iOS</category>
        
        
        <category>Blog</category>
        
      </item>
    
      <item>
        <title>深入研究Block捕获外部变量和__block实现原理</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-3b6a5c9d5edb1aae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;前言&lt;/h4&gt;

&lt;p&gt;Blocks是C语言的扩充功能，而Apple 在OS X Snow Leopard 和 iOS 4中引入了这个新功能“Blocks”。从那开始，Block就出现在iOS和Mac系统各个API中，并被大家广泛使用。一句话来形容Blocks，带有自动变量（局部变量）的匿名函数。&lt;/p&gt;

&lt;p&gt;Block在OC中的实现如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;
struct Block_layout {
    void *isa;
    int flags;
    int reserved;
    void (*invoke)(void *, ...);
    struct Block_descriptor *descriptor;
    /* Imported variables. */
};

struct Block_descriptor {
    unsigned long int reserved;
    unsigned long int size;
    void (*copy)(void *dst, void *src);
    void (*dispose)(void *);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-1739b7e85e46b4db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从结构图中很容易看到isa，所以OC处理Block是按照对象来处理的。在iOS中，isa常见的就是_NSConcreteStackBlock，_NSConcreteMallocBlock，_NSConcreteGlobalBlock这3种(另外只在GC环境下还有3种使用的_NSConcreteFinalizingBlock，_NSConcreteAutoBlock，_NSConcreteWeakBlockVariable，本文暂不谈论这3种，有兴趣的看看官方文档)&lt;/p&gt;

&lt;p&gt;以上介绍是Block的简要实现，接下来我们来仔细研究一下Block的捕获外部变量的特性以及__block的实现原理。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;研究工具：clang&lt;/strong&gt;
为了研究编译器的实现原理，我们需要使用 clang 命令。clang 命令可以将 Objetive-C 的源码改写成 C / C++ 语言的，借此可以研究 block 中各个特性的源码实现方式。该命令是&lt;/p&gt;

&lt;div class=&quot;language-vim highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;clang &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;rewrite&lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;objc block&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;c&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;####目录
- 1.Block捕获外部变量实质
- 2.Block的copy和release
- 3.Block中__block实现原理&lt;/p&gt;

&lt;h4 id=&quot;block&quot;&gt;一.Block捕获外部变量实质&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-b7046feffe189bfa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;拿起我们的Block一起来捕捉外部变量吧。&lt;/p&gt;

&lt;p&gt;说到外部变量，我们要先说一下C语言中变量有哪几种。一般可以分为一下5种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;自动变量&lt;/li&gt;
  &lt;li&gt;函数参数&lt;/li&gt;
  &lt;li&gt;静态变量&lt;/li&gt;
  &lt;li&gt;静态全局变量&lt;/li&gt;
  &lt;li&gt;全局变量&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;研究Block的捕获外部变量就要除去函数参数这一项，下面一一根据这4种变量类型的捕获情况进行分析。&lt;/p&gt;

&lt;p&gt;我们先根据这4种类型
- 自动变量 
- 静态变量
- 静态全局变量
- 全局变量&lt;/p&gt;

&lt;p&gt;写出Block测试代码。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-cba895ef7fe45179.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里很快就出现了一个错误，提示说自动变量没有加__block，由于__block有点复杂，我们先实验静态变量，静态全局变量，全局变量这3类。测试代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;
#import &amp;lt;Foundation/Foundation.h&amp;gt;

int global_i = 1;

static int static_global_j = 2;

int main(int argc, const char * argv[]) {
   
    static int static_k = 3;
    int val = 4;
    
    void (^myBlock)(void) = ^{
        global_i ++;
        static_global_j ++;
        static_k ++;
        NSLog(@&quot;Block中 global_i = %d,static_global_j = %d,static_k = %d,val = %d&quot;,global_i,static_global_j,static_k,val);
    };
    
    global_i ++;
    static_global_j ++;
    static_k ++;
    val ++;
    NSLog(@&quot;Block外 global_i = %d,static_global_j = %d,static_k = %d,val = %d&quot;,global_i,static_global_j,static_k,val);
    
    myBlock();
    
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果
&lt;code class=&quot;highlighter-rouge&quot;&gt;vim
Block 外  global_i = 2,static_global_j = 3,static_k = 4,val = 5
Block 中  global_i = 3,static_global_j = 4,static_k = 5,val = 4
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这里就有2点需要弄清楚了
1.为什么在Block里面不加__bolck不允许更改变量？
2.为什么自动变量的值没有增加，而其他几个变量的值是增加的？自动变量是什么状态下被block捕获进去的？&lt;/p&gt;

&lt;p&gt;为了弄清楚这2点，我们用clang转换一下源码出来分析分析。&lt;/p&gt;

&lt;p&gt;（main.m代码行37行，文件大小832bype， 经过clang转换成main.cpp以后，代码行数飙升至104810行，文件大小也变成了3.1MB）&lt;/p&gt;

&lt;p&gt;源码如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;
int global_i = 1;

static int static_global_j = 2;

struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  int *static_k;
  int val;
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_static_k, int _val, int flags=0) : static_k(_static_k), val(_val) {
    impl.isa = &amp;amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
  int *static_k = __cself-&amp;gt;static_k; // bound by copy
  int val = __cself-&amp;gt;val; // bound by copy

        global_i ++;
        static_global_j ++;
        (*static_k) ++;
        NSLog((NSString *)&amp;amp;__NSConstantStringImpl__var_folders_45_k1d9q7c52vz50wz1683_hk9r0000gn_T_main_6fe658_mi_0,global_i,static_global_j,(*static_k),val);
    }

static struct __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};


int main(int argc, const char * argv[]) {

    static int static_k = 3;
    int val = 4;

    void (*myBlock)(void) = ((void (*)())&amp;amp;__main_block_impl_0((void *)__main_block_func_0, &amp;amp;__main_block_desc_0_DATA, &amp;amp;static_k, val));

    global_i ++;
    static_global_j ++;
    static_k ++;
    val ++;
    NSLog((NSString *)&amp;amp;__NSConstantStringImpl__var_folders_45_k1d9q7c52vz50wz1683_hk9r0000gn_T_main_6fe658_mi_1,global_i,static_global_j,static_k,val);

    ((void (*)(__block_impl *))((__block_impl *)myBlock)-&amp;gt;FuncPtr)((__block_impl *)myBlock);

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先全局变量global_i和静态全局变量static_global_j的值增加，以及它们被Block捕获进去，这一点很好理解，因为是全局的，作用域很广，所以Block捕获了它们进去之后，在Block里面进行++操作，Block结束之后，它们的值依旧可以得以保存下来。&lt;/p&gt;

&lt;p&gt;接下来仔细看看自动变量和静态变量的问题。
在__main_block_impl_0中，可以看到静态变量static_k和自动变量val，被Block从外面捕获进来，成为__main_block_impl_0这个结构体的成员变量了。&lt;/p&gt;

&lt;p&gt;接着看构造函数，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;
__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_static_k, int _val, int flags=0) : static_k(_static_k), val(_val)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个构造函数中，自动变量和静态变量被捕获为成员变量追加到了构造函数中。&lt;/p&gt;

&lt;p&gt;main里面的myBlock闭包中的__main_block_impl_0结构体，初始化如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void (*myBlock)(void) = ((void (*)())&amp;amp;__main_block_impl_0((void *)__main_block_func_0, &amp;amp;__main_block_desc_0_DATA, &amp;amp;static_k, val));


impl.isa = &amp;amp;_NSConcreteStackBlock;
impl.Flags = 0;
impl.FuncPtr = __main_block_impl_0; 
Desc = &amp;amp;__main_block_desc_0_DATA;
*_static_k = 4；
val = 4; 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;到此，__main_block_impl_0结构体就是这样把自动变量捕获进来的。也就是说，在执行Block语法的时候，Block语法表达式所使用的自动变量的值是被保存进了Block的结构体实例中，也就是Block自身中。&lt;/p&gt;

&lt;p&gt;这里值得说明的一点是，如果Block外面还有很多自动变量，静态变量，等等，这些变量在Block里面并不会被使用到。那么这些变量并不会被Block捕获进来，也就是说并不会在构造函数里面传入它们的值。&lt;/p&gt;

&lt;p&gt;Block捕获外部变量仅仅只捕获Block闭包里面会用到的值，其他用不到的值，它并不会去捕获。&lt;/p&gt;

&lt;p&gt;再研究一下源码，我们注意到__main_block_func_0这个函数的实现&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
  int *static_k = __cself-&amp;gt;static_k; // bound by copy
  int val = __cself-&amp;gt;val; // bound by copy

        global_i ++;
        static_global_j ++;
        (*static_k) ++;
        NSLog((NSString *)&amp;amp;__NSConstantStringImpl__var_folders_45_k1d9q7c52vz50wz1683_hk9r0000gn_T_main_6fe658_mi_0,global_i,static_global_j,(*static_k),val);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以发现，系统自动给我们加上的注释，bound by copy，自动变量val虽然被捕获进来了，但是是用 __cself-&amp;gt;val来访问的。Block仅仅捕获了val的值，并没有捕获val的内存地址。所以在__main_block_func_0这个函数中即使我们重写这个自动变量val的值，依旧没法去改变Block外面自动变量val的值。&lt;/p&gt;

&lt;p&gt;OC可能是基于这一点，在编译的层面就防止开发者可能犯的错误，因为自动变量没法在Block中改变外部变量的值，所以编译过程中就报编译错误。错误就是最开始的那张截图。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Variable is not assignable(missing __block type specifier)

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;小结一下：
到此为止，上面提出的第二个问题就解开答案了。自动变量是以值传递方式传递到Block的构造函数里面去的。Block只捕获Block中会用到的变量。由于只捕获了自动变量的值，并非内存地址，所以Block内部不能改变自动变量的值。Block捕获的外部变量可以改变值的是静态变量，静态全局变量，全局变量。上面例子也都证明过了。&lt;/p&gt;

&lt;p&gt;剩下问题一我们还没有解决。&lt;/p&gt;

&lt;p&gt;回到上面的例子上面来，4种变量里面只有静态变量，静态全局变量，全局变量这3种是可以在Block里面被改变值的。仔细观看源码，我们能看出这3个变量可以改变值的原因。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;静态全局变量，全局变量由于作用域的原因，于是可以直接在Block里面被改变。他们也都存储在全局区。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-cf406451fc813cdb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;静态变量传递给Block是内存地址值，所以能在Block里面直接改变值。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;根据&lt;a href=&quot;developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Blocks/Articles/bxVariables.html#//apple_ref/doc/uid/TP40007502-CH6-SW1&quot;&gt;官方文档&lt;/a&gt;我们可以了解到，苹果要求我们在自动变量前加入 &lt;strong&gt;__block&lt;/strong&gt;关键字(__block storage-class-specifier存储域类说明符)，就可以在Block里面改变外部自动变量的值了。&lt;/p&gt;

&lt;p&gt;总结一下在Block中改变变量值有2种方式，一是传递内存地址指针到Block中，二是改变存储区方式(__block)。&lt;/p&gt;

&lt;p&gt;先来实验一下第一种方式，传递内存地址到Block中，改变变量的值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;
#import &amp;lt;Foundation/Foundation.h&amp;gt;

int main(int argc, const char * argv[]) {
    
  NSMutableString * str = [[NSMutableString alloc]initWithString:@&quot;Hello,&quot;];
    
        void (^myBlock)(void) = ^{
            [str appendString:@&quot;World!&quot;];
            NSLog(@&quot;Block中 str = %@&quot;,str);
        };
    
    NSLog(@&quot;Block外 str = %@&quot;,str);
    
    myBlock();
    
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;控制台输出：&lt;/p&gt;

&lt;div class=&quot;language-vim highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Block 外  str &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; Hello&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
Block 中  str &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; Hello&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;World&lt;span class=&quot;p&quot;&gt;!&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;看结果是成功改变了变量的值了，转换一下源码。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;
struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  NSMutableString *str;
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, NSMutableString *_str, int flags=0) : str(_str) {
    impl.isa = &amp;amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
  NSMutableString *str = __cself-&amp;gt;str; // bound by copy

            ((void (*)(id, SEL, NSString *))(void *)objc_msgSend)((id)str, sel_registerName(&quot;appendString:&quot;), (NSString *)&amp;amp;__NSConstantStringImpl__var_folders_45_k1d9q7c52vz50wz1683_hk9r0000gn_T_main_33ff12_mi_1);
            NSLog((NSString *)&amp;amp;__NSConstantStringImpl__var_folders_45_k1d9q7c52vz50wz1683_hk9r0000gn_T_main_33ff12_mi_2,str);
        }
static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&amp;amp;dst-&amp;gt;str, (void*)src-&amp;gt;str, 3/*BLOCK_FIELD_IS_OBJECT*/);}

static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src-&amp;gt;str, 3/*BLOCK_FIELD_IS_OBJECT*/);}

static struct __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);
  void (*dispose)(struct __main_block_impl_0*);
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};

int main(int argc, const char * argv[]) {
    NSMutableString * str = ((NSMutableString *(*)(id, SEL, NSString *))(void *)objc_msgSend)((id)((NSMutableString *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;NSMutableString&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;initWithString:&quot;), (NSString *)&amp;amp;__NSConstantStringImpl__var_folders_45_k1d9q7c52vz50wz1683_hk9r0000gn_T_main_33ff12_mi_0);

        void (*myBlock)(void) = ((void (*)())&amp;amp;__main_block_impl_0((void *)__main_block_func_0, &amp;amp;__main_block_desc_0_DATA, str, 570425344));

    NSLog((NSString *)&amp;amp;__NSConstantStringImpl__var_folders_45_k1d9q7c52vz50wz1683_hk9r0000gn_T_main_33ff12_mi_3,str);

    ((void (*)(__block_impl *))((__block_impl *)myBlock)-&amp;gt;FuncPtr)((__block_impl *)myBlock);

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在__main_block_func_0里面可以看到传递的是指针。所以成功改变了变量的值。&lt;/p&gt;

&lt;p&gt;至于源码里面的copy和dispose下一节会讲到。&lt;/p&gt;

&lt;p&gt;改变外部变量值的第二种方式是加 __block这个放在第三章里面讨论，接下来我们先讨论一下Block的copy的问题，因为这个问题会关系到 __block存储域的问题。&lt;/p&gt;

&lt;h4 id=&quot;blockcopydispose&quot;&gt;二.Block的copy和dispose&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-244bd60d4cb8ad27.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;OC中，一般Block就分为以下3种，_NSConcreteStackBlock，_NSConcreteMallocBlock，_NSConcreteGlobalBlock。&lt;/p&gt;

&lt;p&gt;先来说明一下3者的区别。&lt;/p&gt;

&lt;h5 id=&quot;section-1&quot;&gt;1.从捕获外部变量的角度上来看&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;_NSConcreteStackBlock：
只用到外部局部变量、成员属性变量，且没有强指针引用的block都是StackBlock。
StackBlock的生命周期由系统控制的，一旦返回之后，就被系统销毁了。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;_NSConcreteMallocBlock：
有强指针引用或copy修饰的成员属性引用的block会被复制一份到堆中成为MallocBlock，没有强指针引用即销毁，生命周期由程序员控制&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;_NSConcreteGlobalBlock：
没有用到外界变量或只用到全局变量、静态变量的block为_NSConcreteGlobalBlock，生命周期从创建到应用程序结束。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;没有用到外部变量肯定是_NSConcreteGlobalBlock，这点很好理解。不过只用到全局变量、静态变量的block也是_NSConcreteGlobalBlock。举例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;
#import &amp;lt;Foundation/Foundation.h&amp;gt;

int global_i = 1;
static int static_global_j = 2;

int main(int argc, const char * argv[]) {
   
    static int static_k = 3;

    void (^myBlock)(void) = ^{
            NSLog(@&quot;Block中 变量 = %d %d %d&quot;,static_global_j ,static_k, global_i);
        };
    
    NSLog(@&quot;%@&quot;,myBlock);
    
    myBlock();
    
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;

&lt;div class=&quot;language-vim highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;__NSGlobalBlock__&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;x100001050&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
Block中 变量 &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可见，只用到全局变量、静态变量的block也可以是_NSConcreteGlobalBlock。&lt;/p&gt;

&lt;p&gt;所以在ARC环境下，3种类型都可以捕获外部变量。&lt;/p&gt;

&lt;h5 id=&quot;section-2&quot;&gt;2.从持有对象的角度上来看：&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;_NSConcreteStackBlock是不持有对象的。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;
//以下是在MRC下执行的
    NSObject * obj = [[NSObject alloc]init];
    NSLog(@&quot;1.Block外 obj = %lu&quot;,(unsigned long)obj.retainCount);
    
    void (^myBlock)(void) = ^{
        NSLog(@&quot;Block中 obj = %lu&quot;,(unsigned long)obj.retainCount);
    };
    
    NSLog(@&quot;2.Block外 obj = %lu&quot;,(unsigned long)obj.retainCount);
    
    myBlock();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;div class=&quot;language-vim highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;Block外 obj &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;Block外 obj &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
Block中 obj &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;_NSConcreteMallocBlock是持有对象的。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;//以下是在MRC下执行的
    NSObject * obj = [[NSObject alloc]init];
    NSLog(@&quot;1.Block外 obj = %lu&quot;,(unsigned long)obj.retainCount);
    
    void (^myBlock)(void) = [^{
        NSLog(@&quot;Block中 obj = %lu&quot;,(unsigned long)obj.retainCount);
    }copy];
    
    NSLog(@&quot;2.Block外 obj = %lu&quot;,(unsigned long)obj.retainCount);
    
    myBlock();
    
    [myBlock release];
    
    NSLog(@&quot;3.Block外 obj = %lu&quot;,(unsigned long)obj.retainCount);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;div class=&quot;language-vim highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;Block外 obj &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;Block外 obj &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;
Block中 obj &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;Block外 obj &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;_NSConcreteGlobalBlock也不持有对象&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;//以下是在MRC下执行的
    void (^myBlock)(void) = ^{
        
        NSObject * obj = [[NSObject alloc]init];
        NSLog(@&quot;Block中 obj = %lu&quot;,(unsigned long)obj.retainCount);
    };
    
    myBlock();

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;div class=&quot;language-vim highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
Block 中 obj &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;由于_NSConcreteStackBlock所属的变量域一旦结束，那么该Block就会被销毁。在ARC环境下，编译器会自动的判断，把Block自动的从栈copy到堆。比如当Block作为函数返回值的时候，肯定会copy到堆上。&lt;/p&gt;

&lt;p&gt;1.手动调用copy
2.Block是函数的返回值
3.Block被强引用，Block被赋值给__strong或者id类型
4.调用系统API入参中含有usingBlcok的方法&lt;/p&gt;

&lt;p&gt;以上4种情况，系统都会默认调用copy方法把Block赋复制&lt;/p&gt;

&lt;p&gt;但是当Block为函数参数的时候，就需要我们手动的copy一份到堆上了。这里除去系统的API我们不需要管，比如GCD等方法中本身带usingBlock的方法，其他我们自定义的方法传递Block为参数的时候都需要手动copy一份到堆上。&lt;/p&gt;

&lt;p&gt;copy函数把Block从栈上拷贝到堆上，dispose函数是把堆上的函数在废弃的时候销毁掉。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;
#define Block_copy(...) ((__typeof(__VA_ARGS__))_Block_copy((const void *)(__VA_ARGS__)))
#define Block_release(...) _Block_release((const void *)(__VA_ARGS__))

// Create a heap based copy of a Block or simply add a reference to an existing one.
// This must be paired with Block_release to recover memory, even when running
// under Objective-C Garbage Collection.
BLOCK_EXPORT void *_Block_copy(const void *aBlock)
    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);

// Lose the reference, and if heap based and last reference, recover the memory
BLOCK_EXPORT void _Block_release(const void *aBlock)
    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);

// Used by the compiler. Do not call this function yourself.
BLOCK_EXPORT void _Block_object_assign(void *, const void *, const int)
    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);

// Used by the compiler. Do not call this function yourself.
BLOCK_EXPORT void _Block_object_dispose(const void *, const int)
    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面是源码中2个常用的宏定义和4个常用的方法，一会我们就会看到这4个方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;
static void *_Block_copy_internal(const void *arg, const int flags) {
    struct Block_layout *aBlock;
    const bool wantsOne = (WANTS_ONE &amp;amp; flags) == WANTS_ONE;
    
    // 1
    if (!arg) return NULL;
    
    // 2
    aBlock = (struct Block_layout *)arg;
    
    // 3
    if (aBlock-&amp;gt;flags &amp;amp; BLOCK_NEEDS_FREE) {
        // latches on high
        latching_incr_int(&amp;amp;aBlock-&amp;gt;flags);
        return aBlock;
    }
    
    // 4
    else if (aBlock-&amp;gt;flags &amp;amp; BLOCK_IS_GLOBAL) {
        return aBlock;
    }
    
    // 5
    struct Block_layout *result = malloc(aBlock-&amp;gt;descriptor-&amp;gt;size);
    if (!result) return (void *)0;
    
    // 6
    memmove(result, aBlock, aBlock-&amp;gt;descriptor-&amp;gt;size); // bitcopy first
    
    // 7
    result-&amp;gt;flags &amp;amp;= ~(BLOCK_REFCOUNT_MASK);    // XXX not needed
    result-&amp;gt;flags |= BLOCK_NEEDS_FREE | 1;
    
    // 8
    result-&amp;gt;isa = _NSConcreteMallocBlock;
    
    // 9
    if (result-&amp;gt;flags &amp;amp; BLOCK_HAS_COPY_DISPOSE) {
        (*aBlock-&amp;gt;descriptor-&amp;gt;copy)(result, aBlock); // do fixup
    }
    
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这一段是Block_copy的一个实现，实现了从_NSConcreteStackBlock复制到_NSConcreteMallocBlock的过程。对应有9个步骤。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;
void _Block_release(void *arg) {
    // 1
    struct Block_layout *aBlock = (struct Block_layout *)arg;
    if (!aBlock) return;
    
    // 2
    int32_t newCount;
    newCount = latching_decr_int(&amp;amp;aBlock-&amp;gt;flags) &amp;amp; BLOCK_REFCOUNT_MASK;
    
    // 3
    if (newCount &amp;gt; 0) return;
    
    // 4
    if (aBlock-&amp;gt;flags &amp;amp; BLOCK_NEEDS_FREE) {
        if (aBlock-&amp;gt;flags &amp;amp; BLOCK_HAS_COPY_DISPOSE)(*aBlock-&amp;gt;descriptor-&amp;gt;dispose)(aBlock);
        _Block_deallocator(aBlock);
    }
    
    // 5
    else if (aBlock-&amp;gt;flags &amp;amp; BLOCK_IS_GLOBAL) {
        ;
    }
    
    // 6
    else {
        printf(&quot;Block_release called upon a stack Block: %p, ignored\\\\n&quot;, (void *)aBlock);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这一段是Block_release的一个实现，实现了怎么释放一个Block。对应有6个步骤。&lt;/p&gt;

&lt;p&gt;上述2个方法的详细解析可以看这篇&lt;a href=&quot;http://www.galloway.me.uk/2013/05/a-look-inside-blocks-episode-3-block-copy/&quot;&gt;文章&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;回到上一章节中最后的例子，字符串的例子中来，转换源码之后，我们会发现多了一个copy和dispose方法。&lt;/p&gt;

&lt;p&gt;因为在C语言的结构体中，编译器没法很好的进行初始化和销毁操作。这样对内存管理来说是很不方便的。所以就在 __main_block_desc_0结构体中间增加成员变量 void (*copy)(struct  __main_block_impl_0*, struct __main_block_impl_0*)和void (*dispose)(struct __main_block_impl_0*)，利用OC的Runtime进行内存管理。&lt;/p&gt;

&lt;p&gt;相应的增加了2个方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&amp;amp;dst-&amp;gt;str, (void*)src-&amp;gt;str, 3/*BLOCK_FIELD_IS_OBJECT*/);}

static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src-&amp;gt;str, 3/*BLOCK_FIELD_IS_OBJECT*/);}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的_Block_object_assign和_Block_object_dispose就对应着retain和release方法。&lt;/p&gt;

&lt;p&gt;BLOCK_FIELD_IS_OBJECT 是Block截获对象时候的特殊标示，如果是截获的__block，那么是BLOCK_FIELD_IS_BYREF。&lt;/p&gt;

&lt;h4 id=&quot;blockblock&quot;&gt;三.Block中__block实现原理&lt;/h4&gt;

&lt;p&gt;我们继续研究一下__block实现原理。&lt;/p&gt;

&lt;h5 id=&quot;section-3&quot;&gt;1.普通非对象的变量&lt;/h5&gt;

&lt;p&gt;先来看看普通变量的情况。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;
#import &amp;lt;Foundation/Foundation.h&amp;gt;

int main(int argc, const char * argv[]) {
    
    __block int i = 0;
    
    void (^myBlock)(void) = ^{
        i ++;
        NSLog(@&quot;%d&quot;,i);
    };
    
    myBlock();
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;把上述代码用clang转换成源码。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
struct __Block_byref_i_0 {
  void *__isa;
__Block_byref_i_0 *__forwarding;
 int __flags;
 int __size;
 int i;
};

struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  __Block_byref_i_0 *i; // by ref
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_i_0 *_i, int flags=0) : i(_i-&amp;gt;__forwarding) {
    impl.isa = &amp;amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
  __Block_byref_i_0 *i = __cself-&amp;gt;i; // bound by ref

        (i-&amp;gt;__forwarding-&amp;gt;i) ++;
        NSLog((NSString *)&amp;amp;__NSConstantStringImpl__var_folders_45_k1d9q7c52vz50wz1683_hk9r0000gn_T_main_3b0837_mi_0,(i-&amp;gt;__forwarding-&amp;gt;i));
    }
static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&amp;amp;dst-&amp;gt;i, (void*)src-&amp;gt;i, 8/*BLOCK_FIELD_IS_BYREF*/);}

static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src-&amp;gt;i, 8/*BLOCK_FIELD_IS_BYREF*/);}

static struct __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);
  void (*dispose)(struct __main_block_impl_0*);
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};
int main(int argc, const char * argv[]) {
    __attribute__((__blocks__(byref))) __Block_byref_i_0 i = {(void*)0,(__Block_byref_i_0 *)&amp;amp;i, 0, sizeof(__Block_byref_i_0), 0};

    void (*myBlock)(void) = ((void (*)())&amp;amp;__main_block_impl_0((void *)__main_block_func_0, &amp;amp;__main_block_desc_0_DATA, (__Block_byref_i_0 *)&amp;amp;i, 570425344));

    ((void (*)(__block_impl *))((__block_impl *)myBlock)-&amp;gt;FuncPtr)((__block_impl *)myBlock);

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;从源码我们能发现，带有 __block的变量也被转化成了一个结构体__Block_byref_i_0,这个结构体有5个成员变量。第一个是isa指针，第二个是指向自身类型的__forwarding指针，第三个是一个标记flag，第四个是它的大小，第五个是变量值，名字和变量名同名。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;__attribute__((__blocks__(byref))) __Block_byref_i_0 i = {(void*)0,(__Block_byref_i_0 *)&amp;amp;i, 0, sizeof(__Block_byref_i_0), 0};

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;源码中是这样初始化的。__forwarding指针初始化传递的是自己的地址。然而这里__forwarding指针真的永远指向自己么？我们来做一个实验。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;
//以下代码在MRC中运行
    __block int i = 0;
    NSLog(@&quot;%p&quot;,&amp;amp;i);
    
    void (^myBlock)(void) = [^{
        i ++;
        NSLog(@&quot;这是Block 里面%p&quot;,&amp;amp;i);
    }copy];

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们把Block拷贝到了堆上，这个时候打印出来的2个i变量的地址就不同了。&lt;/p&gt;

&lt;div class=&quot;language-vim highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;x7fff5fbff818
&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;__NSMallocBlock__&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;x100203cc0&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
这是Block 里面 &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;x1002038a8
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;地址不同就可以很明显的说明__forwarding指针并没有指向之前的自己了。那__forwarding指针现在指向到哪里了呢？&lt;/p&gt;

&lt;p&gt;Block里面的__block的地址和Block的地址就相差1052。我们可以很大胆的猜想，__block现在也在堆上了。&lt;/p&gt;

&lt;p&gt;出现这个不同的原因在于这里把Block拷贝到了堆上。&lt;/p&gt;

&lt;p&gt;由第二章里面详细分析的，堆上的Block会持有对象。我们把Block通过copy到了堆上，堆上也会重新复制一份Block，并且该Block也会继续持有该__block。当Block释放的时候，__block没有被任何对象引用，也会被释放销毁。&lt;/p&gt;

&lt;p&gt;__forwarding指针这里的作用就是针对堆的Block，把原来__forwarding指针指向自己，换成指向_NSConcreteMallocBlock上复制之后的__block自己。然后堆上的变量的__forwarding再指向自己。这样不管__block怎么复制到堆上，还是在栈上，都可以通过(i-&amp;gt;__forwarding-&amp;gt;i)来访问到变量值。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-5f5f486bab68191f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;
所以在__main_block_func_0函数里面就是写的(i-&amp;gt;__forwarding-&amp;gt;i)。&lt;/p&gt;

&lt;p&gt;这里还有一个需要注意的地方。还是从例子说起：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec&quot;&gt;//以下代码在MRC中运行
    __block int i = 0;
    NSLog(@&quot;%p&quot;,&amp;amp;i);
    
    void (^myBlock)(void) = ^{
        i ++;
        NSLog(@&quot;Block 里面的%p&quot;,&amp;amp;i);
    };
    
    
    NSLog(@&quot;%@&quot;,myBlock);
    
    myBlock();

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果和之前copy的例子完全不同。&lt;/p&gt;

&lt;div class=&quot;language-vim highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
 &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;x7fff5fbff818
&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;__NSStackBlock__&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;x7fff5fbff7c0&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;**
 &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;x7fff5fbff818

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Block在捕获住__block变量之后，并不会复制到堆上，所以地址也一直都在栈上。这与ARC环境下的不一样。&lt;/p&gt;

&lt;p&gt;&lt;del&gt;ARC环境下，不管有没有copy，__block都会变copy到堆上，Block也是__NSMallocBlock。&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;感谢@酷酷的哀殿 指出错误，感谢@bestswifter 指点。上述说法有点不妥，详细见文章末尾更新。&lt;/p&gt;

&lt;p&gt;ARC环境下，一旦Block赋值就会触发copy，__block就会copy到堆上，Block也是__NSMallocBlock。ARC环境下也是存在__NSStackBlock的时候，这种情况下，__block就在栈上。&lt;/p&gt;

&lt;p&gt;MRC环境下，只有copy，__block才会被复制到堆上，否则，__block一直都在栈上，block也只是__NSStackBlock，这个时候__forwarding指针就只指向自己了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-5e5ae21bfacf7b91.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;至此，文章开头提出的问题一，也解答了。__block的实现原理也已经明了。&lt;/p&gt;

&lt;h5 id=&quot;section-4&quot;&gt;2.对象的变量&lt;/h5&gt;

&lt;p&gt;还是先举一个例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
//以下代码是在ARC下执行的
#import &amp;lt;Foundation/Foundation.h&amp;gt;

int main(int argc, const char * argv[]) {
     
    __block id block_obj = [[NSObject alloc]init];
    id obj = [[NSObject alloc]init];

    NSLog(@&quot;block_obj = [%@ , %p] , obj = [%@ , %p]&quot;,block_obj , &amp;amp;block_obj , obj , &amp;amp;obj);
    
    void (^myBlock)(void) = ^{
        NSLog(@&quot;***Block中****block_obj = [%@ , %p] , obj = [%@ , %p]&quot;,block_obj , &amp;amp;block_obj , obj , &amp;amp;obj);
    };
    
    myBlock();
   
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
block_obj = [&amp;lt;NSObject: 0x100b027d0&amp;gt; , 0x7fff5fbff7e8] , obj = [&amp;lt;NSObject: 0x100b03b50&amp;gt; , 0x7fff5fbff7b8]
Block****中********block_obj = [&amp;lt;NSObject: 0x100b027d0&amp;gt; , 0x100f000a8] , obj = [&amp;lt;NSObject: 0x100b03b50&amp;gt; , 0x100f00070]

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们把上面的代码转换成源码研究一下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
struct __Block_byref_block_obj_0 {
  void *__isa;
__Block_byref_block_obj_0 *__forwarding;
 int __flags;
 int __size;
 void (*__Block_byref_id_object_copy)(void*, void*);
 void (*__Block_byref_id_object_dispose)(void*);
 id block_obj;
};

struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  id obj;
  __Block_byref_block_obj_0 *block_obj; // by ref
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, id _obj, __Block_byref_block_obj_0 *_block_obj, int flags=0) : obj(_obj), block_obj(_block_obj-&amp;gt;__forwarding) {
    impl.isa = &amp;amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
  __Block_byref_block_obj_0 *block_obj = __cself-&amp;gt;block_obj; // bound by ref
  id obj = __cself-&amp;gt;obj; // bound by copy

        NSLog((NSString *)&amp;amp;__NSConstantStringImpl__var_folders_45_k1d9q7c52vz50wz1683_hk9r0000gn_T_main_e64910_mi_1,(block_obj-&amp;gt;__forwarding-&amp;gt;block_obj) , &amp;amp;(block_obj-&amp;gt;__forwarding-&amp;gt;block_obj) , obj , &amp;amp;obj);
    }
static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&amp;amp;dst-&amp;gt;block_obj, (void*)src-&amp;gt;block_obj, 8/*BLOCK_FIELD_IS_BYREF*/);_Block_object_assign((void*)&amp;amp;dst-&amp;gt;obj, (void*)src-&amp;gt;obj, 3/*BLOCK_FIELD_IS_OBJECT*/);}

static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src-&amp;gt;block_obj, 8/*BLOCK_FIELD_IS_BYREF*/);_Block_object_dispose((void*)src-&amp;gt;obj, 3/*BLOCK_FIELD_IS_OBJECT*/);}

static struct __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);
  void (*dispose)(struct __main_block_impl_0*);
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};


int main(int argc, const char * argv[]) {

    __attribute__((__blocks__(byref))) __Block_byref_block_obj_0 block_obj = {(void*)0,(__Block_byref_block_obj_0 *)&amp;amp;block_obj, 33554432, sizeof(__Block_byref_block_obj_0), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131, ((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;NSObject&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;init&quot;))};

    id obj = ((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;NSObject&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;init&quot;));
    NSLog((NSString *)&amp;amp;__NSConstantStringImpl__var_folders_45_k1d9q7c52vz50wz1683_hk9r0000gn_T_main_e64910_mi_0,(block_obj.__forwarding-&amp;gt;block_obj) , &amp;amp;(block_obj.__forwarding-&amp;gt;block_obj) , obj , &amp;amp;obj);

    void (*myBlock)(void) = ((void (*)())&amp;amp;__main_block_impl_0((void *)__main_block_func_0, &amp;amp;__main_block_desc_0_DATA, obj, (__Block_byref_block_obj_0 *)&amp;amp;block_obj, 570425344));

    ((void (*)(__block_impl *))((__block_impl *)myBlock)-&amp;gt;FuncPtr)((__block_impl *)myBlock);

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;首先需要说明的一点是对象在OC中，默认声明自带__strong所有权修饰符的，所以main开头我们声明的&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
__block id block_obj = [[NSObject alloc]init];
id obj = [[NSObject alloc]init];

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;等价于&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
__block id __strong block_obj = [[NSObject alloc]init];
id __strong obj = [[NSObject alloc]init];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在转换出来的源码中，我们也可以看到，Block捕获了__block，并且强引用了，因为在__Block_byref_block_obj_0结构体中，有一个变量是id block_obj，这个默认也是带__strong所有权修饰符的。&lt;/p&gt;

&lt;p&gt;根据打印出来的结果来看，ARC环境下，Block捕获外部对象变量，是都会copy一份的，地址都不同。只不过带有__block修饰符的变量会被捕获到Block内部持有。&lt;/p&gt;

&lt;p&gt;我们再来看看MRC环境下的情况，还是将上述代码的例子运行在MRC中。&lt;/p&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
block_obj = [&amp;lt;NSObject: 0x100b001b0&amp;gt; , 0x7fff5fbff7e8] , obj = [&amp;lt;NSObject: 0x100b001c0&amp;gt; , 0x7fff5fbff7b8]
Block****中********block_obj = [&amp;lt;NSObject: 0x100b001b0&amp;gt; , 0x7fff5fbff7e8] , obj = [&amp;lt;NSObject: 0x100b001c0&amp;gt; , 0x7fff5fbff790]

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个时候block在栈上，__NSStackBlock__，可以打印出来retainCount值都是1。当把这个block copy一下，就变成__NSMallocBlock__，对象的retainCount值就会变成2了。&lt;/p&gt;

&lt;p&gt;总结：&lt;/p&gt;

&lt;p&gt;在MRC环境下，__block根本不会对指针所指向的对象执行copy操作，而只是把指针进行的复制。
而在ARC环境下，对于声明为__block的外部对象，在block内部会进行retain，以至于在block环境内能安全的引用外部对象，所以才会产生循环引用的问题！&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;最后&lt;/h4&gt;

&lt;p&gt;关于Block捕获外部变量有很多用途，用途也很广，只有弄清了捕获变量和持有的变量的概念以后，之后才能清楚的解决Block循环引用的问题。&lt;/p&gt;

&lt;p&gt;再次回到文章开头，5种变量，自动变量，函数参数 ，静态变量，静态全局变量，全局变量，如果严格的来说，捕获是必须在Block结构体__main_block_impl_0里面有成员变量的话，Block能捕获的变量就只有带有自动变量和静态变量了。捕获进Block的对象会被Block持有。&lt;/p&gt;

&lt;p&gt;对于非对象的变量来说，&lt;/p&gt;

&lt;p&gt;自动变量的值，被copy进了Block，不带__block的自动变量只能在里面被访问，并不能改变值。&lt;br /&gt;
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-9c34ab1560e75504.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;带__block的自动变量 和 静态变量 就是直接地址访问。所以在Block里面可以直接改变变量的值。&lt;br /&gt;
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-455842213775d7dd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而剩下的静态全局变量，全局变量，函数参数，也是可以在直接在Block中改变变量值的，但是他们并没有变成Block结构体__main_block_impl_0的成员变量，因为他们的作用域大，所以可以直接更改他们的值。&lt;/p&gt;

&lt;p&gt;值得注意的是，静态全局变量，全局变量，函数参数他们并不会被Block持有，也就是说不会增加retainCount值。&lt;/p&gt;

&lt;p&gt;对于对象来说，&lt;/p&gt;

&lt;p&gt;在MRC环境下，__block根本不会对指针所指向的对象执行copy操作，而只是把指针进行的复制。
而在ARC环境下，对于声明为__block的外部对象，在block内部会进行retain，以至于在block环境内能安全的引用外部对象。&lt;/p&gt;

&lt;p&gt;请大家多多指点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;更新&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在ARC环境下，Block也是存在__NSStackBlock的时候的，平时见到最多的是_NSConcreteMallocBlock，是因为我们会对Block有赋值操作，所以ARC下，block 类型通过=进行传递时，会导致调用objc_retainBlock-&amp;gt;_Block_copy-&amp;gt;_Block_copy_internal方法链。并导致 __NSStackBlock__ 类型的 block 转换为 __NSMallocBlock__ 类型。&lt;/p&gt;

&lt;p&gt;举例如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
#import &amp;lt;Foundation/Foundation.h&amp;gt;

int main(int argc, const char * argv[]) {
    
    __block int temp = 10;
    
    NSLog(@&quot;%@&quot;,^{NSLog(@&quot;*******%d %p&quot;,temp ++,&amp;amp;temp);});
   
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;__NSStackBlock__: 0x7fff5fbff768&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这种情况就是ARC环境下Block是__NSStackBlock的类型。&lt;/p&gt;
</description>
        <pubDate>Sat, 27 Aug 2016 22:05:02+0800</pubDate>
        <link>http://vno.onevcat.com/2016/08/%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6Block%E6%8D%95%E8%8E%B7%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C__block%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link>
        <guid isPermaLink="true">http://vno.onevcat.com/2016/08/%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6Block%E6%8D%95%E8%8E%B7%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C__block%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid>
        
        <category>iOS</category>
        
        
        <category>Blog</category>
        
      </item>
    
      <item>
        <title>给iOS 模拟器“安装”app文件</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-aa54e17eb79b1ce4.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;前言&lt;/h4&gt;
&lt;p&gt;刚刚接触iOS的时候，我就一直很好奇，模拟器上面能不能直接安装app呢？如果可以，我们就直接在模拟器上面聊QQ和微信了。直到昨天和朋友们聊到了这个话题，没有想到还真的可以给模拟器“安装”app！&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;一.应用场景&lt;/h4&gt;

&lt;p&gt;先来谈谈是什么情况下，会有在模拟器上安装app的需求。&lt;/p&gt;

&lt;p&gt;在一个大公司里，对源码的管理有严格的制度，非开发人员是没有权限接触到源码的。对苹果的开发证书管理也非常严格，甚至连开发人员也没有发布证书，证书只在持续集成环境或者Appstore产线里面，或者只在最后打包上架的人手上。&lt;/p&gt;

&lt;p&gt;那么现在就有这样的需求，开发人员搭建好UI以后，要把开发完成的Alapha版给到UI设计师那边去评审，看看是否完全达到要求，达不到要求就需要打回来重做。&lt;/p&gt;

&lt;p&gt;一般做法就是直接拿手机去安装一遍了。直接真机看效果。不过要是设计师和开发不在同一个地方的公司，一个在北京一个在上海，这种就没法安装了。源码又无法导出给设计师，让他运行一下Xcode跑一下模拟器。打release的ipa通过扫码安装，如果公司大了，UDID全部都用完了，也没法安装。这个时候就比较麻烦了。(一般也没人遇到这么蛋疼的事情吧)&lt;/p&gt;

&lt;p&gt;那么现在就有给模拟器安装app的需求了，那开发人员如何能把开发版的app给打包出来给其他模拟器安装呢？&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;二.解决办法&lt;/h4&gt;

&lt;p&gt;解决思路，想要别人的模拟器运行起我们开发的app，最简单的办法就是把我们DerivedData的数据直接拷贝到别人模拟器上面，就可以了。当然还要考虑到设计师也许并不会一些命令行命令，我们的操作越傻瓜越好。&lt;/p&gt;

&lt;h5 id=&quot;deriveddatadebug&quot;&gt;1.拷贝本地的DerivedData里面的debug包&lt;/h5&gt;

&lt;p&gt;Mac的拷贝命令有cp和ditto，建议用ditto进行拷贝工作。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
Usage: ditto [ &amp;lt;options&amp;gt; ] src [ ... src ] dst

    &amp;lt;options&amp;gt; are any of:
    -h                         print full usage
    -v                         print a line of status for each source copied
    -V                         print a line of status for every file copied
    -X                         do not descend into directories with a different device ID

    -c                         create an archive at dst (by default CPIO format)
    -x                         src(s) are archives
    -z                         gzip compress CPIO archive
    -j                         bzip2 compress CPIO archive
    -k                         archives are PKZip
    --keepParent               parent directory name src is embedded in dst_archive
    --arch archVal             fat files will be thinned to archVal
                               multiple -arch options can be specified
                               archVal should be one of &quot;ppc&quot;, &quot;i386&quot;, etc
    --bom bomFile              only objects present in bomFile are copied
    --norsrc                   don&#39;t preserve resource data
    --noextattr                don&#39;t preserve extended attributes
    --noqtn                    don&#39;t preserve quarantine information
    --noacl                    don&#39;t preserve ACLs
    --sequesterRsrc            copy resources via polite directory (PKZip only)
    --nocache                  don&#39;t use filesystem cache for reads/writes
    --hfsCompression           compress files at destination if appropriate
    --nopreserveHFSCompression don&#39;t preserve HFS+ compression when copying files
    --zlibCompressionLevel num use compression level &#39;num&#39; when creating a PKZip archive
    --password                 request password for reading from encrypted PKZip archive
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Ditto比cp命令更好的地方在于：
1. 它在复制过程中不仅能保留源文件或者文件夹的属性与权限，还能保留源文件的资源分支结构和文件夹的源结构。
2. 此命令能确保文件或者文件夹被如实复制。
3. 如果目标文件或者文件夹不存在，ditto将直接复制过去或创建新的文件和文件夹，相反，对于已经存在的文件，命令将与目标文件（夹）合并。
4. ditto还能提供完整符号链接。&lt;/p&gt;

&lt;p&gt;那么我们就拷贝出本地的debug包&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ditto -ck --sequesterRsrc --keepParent `ls -1 -d -t ~/Library/Developer/Xcode/DerivedData/*/Build/Products/*-iphonesimulator/*.app | head -n 1` /Users/YDZ/Desktop/app.zip
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;有几点需要说明的：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;上面命令最后一个路径(/Users/YDZ/Desktop/app.zip)，这个是自定义的，我这里举的例子是直接放在桌面。除了这里改一下路径，前面的都不需要改，包括 * 也都不用改。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;再来说一下命令里面的 * 的问题。当我们打开自己本地的~/Library/Developer/Xcode/DerivedData/ ，这个路径下，会发现里面装的都是在我们本地模拟器上运行过的app程序。前面是app的Bundle Identifier，横线后面是一堆字符串。上面的ditto里面带 * 的那个路径是为了动态匹配一个地址的，* 在这里也是一个通配符。后面的head说明了匹配的规则。head其实是找出最近一次我们运行模拟器的app的路径。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为了保证我们打包是正确的，建议先运行一下我们要打包的app，一般我们Scheme里面的Run都是debug product(如果这里有更改，那就改成对应debug的Scheme)，确保是我们要给设计师审核的app，之后再运行这个ditto命令。&lt;/p&gt;

&lt;h5 id=&quot;debug&quot;&gt;2.把debug包拷贝到另一个模拟器中&lt;/h5&gt;

&lt;p&gt;我们运行完上面的ditto命令会产生一个zip文件，解压出来，会得到一个app文件，这个就是debug包了。debug包就是我们要给设计师的app包了。&lt;/p&gt;

&lt;p&gt;如何能让设计师傻瓜式的安装这个app呢？&lt;/p&gt;

&lt;p&gt;这里介绍一个命令行工具，&lt;a href=&quot;https://github.com/appcelerator/ios-sim&quot;&gt;ios-sim&lt;/a&gt;命令行工具。&lt;/p&gt;

&lt;p&gt;ios-sim 是一个可以在命令控制iOS模拟器的工具。利用这个命令，我们可以启动一个模拟器，安装app，启动app，查询iOS SDK。它可以使我们像自动化测试一样不用打开Xcode。&lt;/p&gt;

&lt;p&gt;不过 ios-sim 只支持Xcode 6 以后的版本。&lt;/p&gt;

&lt;p&gt;安装ios-sim&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    $ npm install ios-sim -g
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;说明文档：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
    Usage: ios-sim &amp;lt;command&amp;gt; &amp;lt;options&amp;gt; [--args ...]
        
    Commands:
      showsdks                        List the available iOS SDK versions
      showdevicetypes                 List the available device types
      launch &amp;lt;application path&amp;gt;       Launch the application at the specified path on the iOS Simulator
      start                           Launch iOS Simulator without an app
      install &amp;lt;application path&amp;gt;      Install the application at the specified path on the iOS Simulator without launching the app

    Options:
      --version                       Print the version of ios-sim
      --help                          Show this help text
      --exit                          Exit after startup
      --log &amp;lt;log file path&amp;gt;           The path where log of the app running in the Simulator will be redirected to
      --devicetypeid &amp;lt;device type&amp;gt;    The id of the device type that should be simulated (Xcode6+). Use &#39;showdevicetypes&#39; to list devices.
                                      e.g &quot;com.apple.CoreSimulator.SimDeviceType.Resizable-iPhone6, 8.0&quot;
                                  
    Removed in version 4.x:
      --stdout &amp;lt;stdout file path&amp;gt;     The path where stdout of the simulator will be redirected to (defaults to stdout of ios-sim)
      --stderr &amp;lt;stderr file path&amp;gt;     The path where stderr of the simulator will be redirected to (defaults to stderr of ios-sim)
      --sdk &amp;lt;sdkversion&amp;gt;              The iOS SDK version to run the application on (defaults to the latest)
      --family &amp;lt;device family&amp;gt;        The device type that should be simulated (defaults to `iphone&#39;)
      --retina                        Start a retina device
      --tall                          In combination with --retina flag, start the tall version of the retina device (e.g. iPhone 5 (4-inch))
      --64bit                         In combination with --retina flag and the --tall flag, start the 64bit version of the tall retina device (e.g. iPhone 5S (4-inch 64bit))
                                    
    Unimplemented in this version:
      --verbose                       Set the output level to verbose
      --timeout &amp;lt;seconds&amp;gt;             The timeout time to wait for a response from the Simulator. Default value: 30 seconds
      --args &amp;lt;...&amp;gt;                    All following arguments will be passed on to the application
      --env &amp;lt;environment file path&amp;gt;   A plist file containing environment key-value pairs that should be set
      --setenv NAME=VALUE             Set an environment variable
                                  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;用法不难&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ios-sim launch /Users/YDZ/Desktop/app.app --devicetypeid iPhone-6s 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中，/Users/YDZ/Desktop/app.app这个是设计师收到app之后的路径。–devicetypeid参数后面是给定一个模拟器的版本。&lt;/p&gt;

&lt;p&gt;只需要把上面的命令发给设计师，无脑粘贴到命令行，装好app的模拟器就会自动启动，打开app了。&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;三.额外的尝试&lt;/h4&gt;

&lt;p&gt;好奇的同学肯定不会满足只给模拟器安装debug包吧，既然可以不用代码就可以给模拟器安装app，那我们能安装release包么？我好奇的尝试了一下。&lt;/p&gt;

&lt;p&gt;先从Appstore上面下载最新的微信，把ipa后缀改成zip，解压，把Payload文件夹里面的“WeChat”取出来，然后运行ios-sim命令。&lt;/p&gt;

&lt;p&gt;结果微信确实是安装到了模拟器了。不过一点击app，看见了月亮界面就退出了。控制台打印了一堆信息。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;An error was encountered processing the command (domain=FBSOpenApplicationErrorDomain, code=1):
The operation couldn’t be completed. (FBSOpenApplicationErrorDomain error 1.)
Aug 18 16:29:17 YDZdeMacBook-Pro nsurlsessiond[19213]: Task 1 for client &amp;lt;CFString 0x7fa810c047d0 [0x1073daa40]&amp;gt;{contents = &quot;com.apple.mobileassetd&quot;} completed with error - code: -999
Aug 18 16:29:17 YDZdeMacBook-Pro com.apple.CoreSimulator.SimDevice.D6BD3967-9BC4-4A8D-9AD0-23176B22B12A.launchd_sim[19096] (UIKitApplication:com.tencent.xin[0xdf6d][19774]): Program specified by service does not contain one of the requested architectures:
Aug 18 16:29:17 YDZdeMacBook-Pro SpringBoard[19181]: Unable to get pid for &#39;UIKitApplication:com.tencent.xin[0xdf6d]&#39;: No such process (err 3)
Aug 18 16:29:17 YDZdeMacBook-Pro SpringBoard[19181]: Bootstrapping failed for &amp;lt;FBApplicationProcess: 0x7fa83cd91840; com.tencent.xin; pid: -1&amp;gt;
Aug 18 16:29:17 YDZdeMacBook-Pro SpringBoard[19181]: Unable to delete job with label UIKitApplication:com.tencent.xin[0xdf6d]. Error: Operation now in progress
Aug 18 16:29:17 YDZdeMacBook-Pro SpringBoard[19181]: Application &#39;UIKitApplication:com.tencent.xin[0xdf6d]&#39; exited for an unknown reason.
Aug 18 16:29:17 YDZdeMacBook-Pro com.apple.CoreSimulator.SimDevice.D6BD3967-9BC4-4A8D-9AD0-23176B22B12A.launchd_sim[19096] (UIKitApplication:com.tencent.xin[0xdf6d][19774]): Trampoline was terminated before jumping to service: Killed: 9
Aug 18 16:29:18 YDZdeMacBook-Pro fileproviderd[19169]: (Note ) FileProvider: /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PrivateFrameworks/FileProvider.framework/Support/fileproviderd starting.
Aug 18 16:29:20 YDZdeMacBook-Pro pkd[19238]: assigning plug-in com.apple.ServerDocuments.ServerFileProvider(1.0) to plugin sandbox
Aug 18 16:29:20 YDZdeMacBook-Pro pkd[19238]: enabling pid=19169 for plug-in com.apple.ServerDocuments.ServerFileProvider(1.0) D12B6280-6DF1-434C-9BAA-BD9B0D0FB756 /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/Applications/ServerDocuments.app/PlugIns/ServerFileProvider.appex
Aug 18 16:29:22 YDZdeMacBook-Pro SpringBoard[19181]: Weekly asset update check did fire (force=NO)
Aug 18 16:29:22 YDZdeMacBook-Pro SpringBoard[19181]: Beginning check for asset updates (force: 0
Aug 18 16:29:22 YDZdeMacBook-Pro SpringBoard[19181]: Did not complete check for asset updates (force: 0, isVoiceOverRunning: 0
Aug 18 16:29:23 YDZdeMacBook-Pro mstreamd[19171]: (Note ) mstreamd: mstreamd starting up.
Aug 18 16:29:23 YDZdeMacBook-Pro DTServiceHub[19191]: DTServiceHub(19191) [error]: &#39;mach_msg_send&#39; failed: (ipc/send) invalid destination port (268435459)
Aug 18 16:29:25 YDZdeMacBook-Pro itunesstored[19744]: iTunes Store environment is: MR22
Aug 18 16:29:25 YDZdeMacBook-Pro itunesstored[19744]: Normal message received by listener connection. Ignoring.
Aug 18 16:29:25 --- last message repeated 1 time ---
Aug 18 16:29:25 YDZdeMacBook-Pro mstreamd[19171]: (Note ) PS: The subscription plugin class does not support push notification refreshing.
Aug 18 16:29:25 YDZdeMacBook-Pro itunesstored[19744]: libMobileGestalt MGIOKitSupport.c:387: value for udid-version property of IODeviceTree:/product is invalid ((null))
Aug 18 16:29:25 YDZdeMacBook-Pro itunesstored[19744]: Normal message received by listener connection. Ignoring.
Aug 18 16:29:25 YDZdeMacBook-Pro itunesstored[19744]: libMobileGestalt MGBasebandSupport.c:60: _CTServerConnectionCopyMobileEquipmentInfo: CommCenter error: 1:45 (Operation not supported)
Aug 18 16:29:25 YDZdeMacBook-Pro itunesstored[19744]: libMobileGestalt MGBasebandSupport.c:189: No CT mobile equipment info dictionary while fetching kCTMobileEquipmentInfoIMEI
Aug 18 16:29:26 YDZdeMacBook-Pro mstreamd[19171]: (Note ) PS: Media stream daemon starting...
Aug 18 16:29:27 YDZdeMacBook-Pro itunesstored[19744]: UpdateAssetsOperation: Error downloading manifest from URL https://apps.itunes.com/files/ios-music-app/: Error Domain=SSErrorDomain Code=109 &quot;无法连接到 iTunes Store&quot; UserInfo={NSLocalizedDescription=无法连接到 iTunes Store, SSErrorHTTPStatusCodeKey=503}
Aug 18 16:29:31 YDZdeMacBook-Pro healthd[19174]: (Error) MC: MobileContainerManager gave us a path we weren&#39;t expecting; file a radar against them
       	Expected: /private/var/containers/Shared/SystemGroup/systemgroup.com.apple.configurationprofiles
       	Actual: /Users/YDZ/Library/Developer/CoreSimulator/Devices/D6BD3967-9BC4-4A8D-9AD0-23176B22B12A/data/Containers/Shared/SystemGroup/systemgroup.com.apple.configurationprofiles
       	Overriding MCM with the one true path
Aug 18 16:29:31 YDZdeMacBook-Pro healthd[19174]: PairedSync, Debugging at level 0 for console and level 0 for log files
Aug 18 16:29:31 YDZdeMacBook-Pro healthd[19174]: Error: Could not create service from plist at path: file:///Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PairedSyncServices/com.apple.pairedsync.healthd.plist. Returning nil PSYSyncCoordinator for service name com.apple.pairedsync.healthd.  Please check that your plist exists and is in the correct format.
Aug 18 16:29:31 YDZdeMacBook-Pro healthd[19174]: Error: failed to load bundle &quot;/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Health/Plugins/CompanionHealth.bundle&quot;: Error Domain=NSCocoaErrorDomain Code=4 &quot;未能载入软件包“CompanionHealth.bundle”，因为未能找到其可执行文件的位置。&quot; UserInfo={NSLocalizedFailureReason=未能找到该软件包可执行文件的位置。, NSLocalizedRecoverySuggestion=请尝试重新安装软件包。, NSBundlePath=/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Health/Plugins/CompanionHealth.bundle, NSLocalizedDescription=未能载入软件包“CompanionHealth.bundle”，因为未能找到其可执行文件的位置。}
Aug 18 16:29:33 YDZdeMacBook-Pro wcd[19180]: libMobileGestalt MobileGestalt.c:2584: Failed to get battery level
Aug 18 16:29:34 --- last message repeated 1 time ---
Aug 18 16:29:34 YDZdeMacBook-Pro assertiond[19185]: assertion failed: 15G31 13E230: assertiond + 15801 [3C808658-78EC-3950-A264-79A64E0E463B]: 0x1
Aug 18 16:29:34 --- last message repeated 1 time ---
Aug 18 16:29:34 YDZdeMacBook-Pro SpringBoard[19181]: [MPUSystemMediaControls] Updating supported commands for now playing application.
Aug 18 16:29:34 YDZdeMacBook-Pro assertiond[19185]: assertion failed: 15G31 13E230: assertiond + 15801 [3C808658-78EC-3950-A264-79A64E0E463B]: 0x1
Aug 18 16:29:34 --- last message repeated 1 time ---
Aug 18 16:29:34 YDZdeMacBook-Pro fileproviderd[19169]: plugin com.apple.ServerDocuments.ServerFileProvider invalidated
Aug 18 16:29:34 YDZdeMacBook-Pro ServerFileProvider[19775]: host connection &amp;lt;NSXPCConnection: 0x7f880160bc30&amp;gt; connection from pid 19169 invalidated
Aug 18 16:30:08 YDZdeMacBook-Pro mstreamd[19171]: (Note ) PS: Media stream daemon stopping.
Aug 18 16:30:09 YDZdeMacBook-Pro mstreamd[19171]: (Note ) AS: &amp;lt;MSIOSAlbumSharingDaemon: 0x7fd139c0a020&amp;gt;: Shared Streams daemon has shut down.
Aug 18 16:30:09 YDZdeMacBook-Pro mstreamd[19171]: (Warn ) mstreamd: mstreamd shutting down.
Aug 18 16:30:09 YDZdeMacBook-Pro CoreSimulatorBridge[19190]: Switching to keyboard: zh-Hans
Aug 18 16:30:09 YDZdeMacBook-Pro CoreSimulatorBridge[19190]: KEYMAP: Failed to determine iOS keyboard layout for language zh-Hans.
Aug 18 16:30:09 YDZdeMacBook-Pro CoreSimulatorBridge[19190]: Switching to keyboard: zh-Hans
Aug 18 16:30:09 YDZdeMacBook-Pro CoreSimulatorBridge[19190]: KEYMAP: Failed to determine iOS keyboard layout for language zh-Hans.
Aug 18 16:30:10 YDZdeMacBook-Pro CoreSimulatorBridge[19190]: Switching to keyboard: zh-Hans
Aug 18 16:30:10 YDZdeMacBook-Pro CoreSimulatorBridge[19190]: KEYMAP: Failed to determine iOS keyboard layout for language zh-Hans.
Aug 18 16:30:10 YDZdeMacBook-Pro CoreSimulatorBridge[19190]: Switching to keyboard: zh-Hans
Aug 18 16:30:10 YDZdeMacBook-Pro CoreSimulatorBridge[19190]: KEYMAP: Failed to determine iOS keyboard layout for language zh-Hans.
Aug 18 16:30:16 YDZdeMacBook-Pro sharingd[19183]: 16:30:16.190 : Failed to send SDURLSessionProxy startup message, error Error Domain=com.apple.identityservices.error Code=23 &quot;Timed out&quot; UserInfo={NSLocalizedDescription=Timed out, NSUnderlyingError=0x7ff088e005a0 {Error Domain=com.apple.ids.idssenderrordomain Code=12 &quot;(null)&quot;}}
Aug 18 16:30:38 YDZdeMacBook-Pro CoreSimulatorBridge[19190]: Switching to keyboard: zh-Hans
Aug 18 16:30:38 YDZdeMacBook-Pro CoreSimulatorBridge[19190]: KEYMAP: Failed to determine iOS keyboard layout for language zh-Hans.
Aug 18 16:30:38 YDZdeMacBook-Pro CoreSimulatorBridge[19190]: Switching to keyboard: zh-Hans
Aug 18 16:30:38 YDZdeMacBook-Pro CoreSimulatorBridge[19190]: KEYMAP: Failed to determine iOS keyboard layout for language zh-Hans.
Aug 18 16:30:41 YDZdeMacBook-Pro CoreSimulatorBridge[19190]: Switching to keyboard: zh-Hans

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;仔细看了一下log，根本原因还是因为&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;com.apple.CoreSimulator.SimDevice.D6BD3967-9BC4-4A8D-9AD0-23176B22B12A.launchd_sim[19096] (UIKitApplication:com.tencent.xin[0xdf6d][19774]): Program specified by service does not contain one of the requested architectures:

Unable to get pid for &#39;UIKitApplication:com.tencent.xin[0xdf6d]&#39;: No such process (err 3)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;因为release包里面architectures打包的时候不包含模拟器的architectures。debug包里面就有。所以release就没法安装到模拟器了。&lt;/p&gt;

&lt;p&gt;由于笔者逆向方面的东西没有研究，所以也无法继续下去了。不知道逆向技术能不能把release包破壳之后能不能转成debug包呢？如果能转成debug包，通过ios-sim命令应该也是可以直接安装到模拟器的。&lt;/p&gt;

&lt;p&gt;至此，ios-sim给模拟器安装app就尝试到此了。因为只能给模拟器安装debug包，所以在题目上额外给安装加了双引号，并不是所有的app文件都可以安装到模拟器。&lt;/p&gt;

&lt;p&gt;请大家多多指教。&lt;/p&gt;
</description>
        <pubDate>Thu, 18 Aug 2016 18:58:02+0800</pubDate>
        <link>http://vno.onevcat.com/2016/08/%E7%BB%99iOS-%E6%A8%A1%E6%8B%9F%E5%99%A8-%E5%AE%89%E8%A3%85-app%E6%96%87%E4%BB%B6/</link>
        <guid isPermaLink="true">http://vno.onevcat.com/2016/08/%E7%BB%99iOS-%E6%A8%A1%E6%8B%9F%E5%99%A8-%E5%AE%89%E8%A3%85-app%E6%96%87%E4%BB%B6/</guid>
        
        <category>iOS</category>
        
        
        <category>Blog</category>
        
      </item>
    
      <item>
        <title>手把手教你给一个iOS app配置多个环境变量</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-fa88cb2e6feceae7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;前言&lt;/h4&gt;
&lt;p&gt;谈到多环境，相信现在大多公司都至少有2-3个app环境了，比如Test环境，UAT(User Acceptance Test)用户验收测试环境，Release环境等等。当需要开发打多个包的时候，一般常见做法就是直接代码里面修改环境变量，改完之后Archive一下就打包了。当然这种做法很正确，只不过不是很优雅很高效。如果搭建好了Jenkins(&lt;a href=&quot;http://www.jianshu.com/p/41ecb06ae95f&quot;&gt;搭建教程&lt;/a&gt;)，我们利用它来优雅的打包。如果利用Jenkins来打包，我们就需要来给app来配置一下多个环境变量了。之后Jenkins分别再不同环境下自动集成即可。接下来，我们来谈谈常见的2种做法。&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;目录&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;1.利用Build Configuration来配置多环境&lt;/li&gt;
  &lt;li&gt;2.利用&lt;a href=&quot;https://developer.apple.com/library/ios/recipes/xcode_help-project_editor/Articles/BasingBuildConfigurationsonConfigurationFiles.html&quot;&gt;xcconfig&lt;/a&gt;文件来配置多环境&lt;/li&gt;
  &lt;li&gt;3.利用Targets来配置多环境&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;build-configuration&quot;&gt;一.利用Build Configuration来配置多环境&lt;/h4&gt;
&lt;p&gt;前言里面我们先谈到了需求，由于需要配置多个环境，并且多个环境都需要安装到手机上，那么可以配置Build Configuration来完成这个任务。如果Build Configuration还不熟悉的，可以先温习一下&lt;a href=&quot;https://developer.apple.com/library/ios/recipes/xcode_help-project_editor/Articles/BasingBuildConfigurationsonConfigurationFiles.html&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;

&lt;h5 id=&quot;build-configuration-1&quot;&gt;1. 新建Build Configuration&lt;/h5&gt;
&lt;p&gt;先点击Project里面找到Configuration，然后选择添加，这里新加一个Configuration。系统默认是2个，一个Debug，一个Release。这里我们需要选择是复制一个Debug还是Release。Release和Debug的区别是，Release是不能调试程序，因为默认是屏蔽了可调试的一些参数，具体可以看BuildSetting里面的区别，而且Release编译时有做编译优化，会比用Debug打包出来的体积更小一点。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-bc2cd086f31d3263.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里我们选择一个Duplicate “Debug” Configuration，因为我们新的环境需要debug，添加完了之后就会多了一套Configuration了，这一套其实是包含了一些编译参数的配置集合。如果此时项目里面有cocopods的话，打开Configuration Set就会发现是如下的样子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-af56fd34c9b1bfc8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在我们自己的项目里面用了Pod，打开配置是会看到如下信息
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-770ea4347a9a0928.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意：刚刚新建完Build Configuration之后，这时如果有pod，请立即执行一下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
pod install  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;pod安装完成之后会自动生成xcconfig文件，如果你手动新建这个xcconfig，然后把原来的debug和release对应的pod xcconfig文件内容复制进来，这样做是无效的，需要pod自己去生成xcconfig文件才能被识别到。&lt;/p&gt;

&lt;p&gt;新建完Build Configuration，这个时候需要新建pod里面对应的Build Configuration，要不然一会编译会报错。如果没用pod，可以忽略一下这一段。&lt;/p&gt;

&lt;p&gt;如下图新建一个对应之前Porject里面新建的Build Configuration
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-0ecc3c2cb61b83d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;scheme&quot;&gt;2. 新建Scheme&lt;/h5&gt;

&lt;p&gt;接下来我们要为新的Configuration新建一个编译Scheme。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-3e882c6c04155c21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;新建完成之后，我们就可以编辑刚刚新建的Scheme，这里可以把Run模式和Archive都改成新建Scheme。如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-0ec7df2dfbea089e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意：如果是使用了Git这些协同工具的同学这里还需要把刚刚新建的Scheme共享出去，否则其他人看不到这个Scheme。选择“Manage Schemes”&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-5f6f36cacb4404f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;user-defined-build-settings&quot;&gt;3. 新建User-defined Build Settings&lt;/h5&gt;

&lt;p&gt;再次回到Project的Build Settings里面来，Add User-Defined Setting。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-b212148be039475c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们这里新加入2个参数，CustomAppBundleld是为了之后打包可以分开打成多个包，这里需要3个不同的Id，建议是直接在原来的Bundleld加上Scheme的名字即可。&lt;/p&gt;

&lt;p&gt;CustomProductName是为了app安装到手机上之后，手机上显示的名字，这里可以按照对应的环境给予描述，比如测试服，UAT，等等。如下图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-e53a11b9c0317976.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里值得提到的一点是，下面Pods的Build_DIR这些目录其实是Pods自己生成好的，之前执行过&lt;strong&gt;Pod install&lt;/strong&gt; 之后，这里默认都是配置好的，不需要再改动了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-b881321289e8b498.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;infoplist--imagesxcassets&quot;&gt;4. 修改info.plist文件 和 Images.xcassets&lt;/h5&gt;

&lt;p&gt;先来修改一下info.plist文件。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-030b30264df74e43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由于我们新添加了2个CustomAppBundleld 和 CustomProductName，这里我们需要把info.plist里面的Bundle display name修改成我们自定义的这个字典。编译过程中，编译器会根据我们设置好的Scheme去自己选择Debug，Release，TestRelease分别对应的ProductName。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-2936ad12b68610d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们还需要在Images.xcassets里面新添加2个New iOS App Icon，名字最好和scheme的名字相同，这样好区分。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-f886a8b706d306e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;新建完AppIcon之后，再在Build Setting里面找到&lt;strong&gt;Asset Catalog Compiler&lt;/strong&gt;里面，然后把这几种模式下的App Icon set
 Name分别设置上对应的图标。如上图。&lt;/p&gt;

&lt;p&gt;既然我们已经新建了这几个scheme，那接下来怎么把他们都打包成app呢？？这里有一份官方的文档&lt;a href=&quot;https://developer.apple.com/library/ios/technotes/tn2215/_index.html&quot;&gt;Troubleshooting Application Archiving in Xcode&lt;/a&gt;这里面详细记录了我们平时点击了Archive之后是怎么打包的。&lt;/p&gt;

&lt;p&gt;这里分享一下我分好这些环境的心得。一切切记，每个环境都要设置好Debug 和 Release！千万别认为线上的版本只设置Release就好，哪天需要调试线上版本，没有设置Debug就无从下手了。也千万别认为测试环境的版本只要设置Debug就好，万一哪天要发布一个测试环境需要发Release包，那又无从下手了。我的建议就是每个环境都配置Debug 和 Release，即使以后不用，也提前设置好，以防万一。合理的设置应该如下图这样。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  
| -------------------------- |------------------|
|           Scheme           |   Configurations |  
| -------------------------- |------------------| 
|      XXXXProjectTest       |      Debug       | 
|                            |------------------|
|                            |      Release     | 
| -------------------------- |------------------|
|      XXXXProjectAppStore   |      Debug       | 
|                            |------------------|
|                            |      Release     | 
| -------------------------- |------------------|
|      XXXXProjectUAT        |      Debug       | 
|                            |------------------|
|                            |      Release     | 
| -------------------------- |------------------|

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;注意这里一定要把Scheme的名字和编译方式区分开，选择了一个Scheme，只是相当于选择了一个环境，并不是代表这Debug还是Release。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-059d8650a96b18fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我建议Scheme只配置环境，而进来的Run和Archive来配置Debug和Release，我建议每个Scheme都按照上图来，Run对应的Debug，Archive对应的Release。&lt;/p&gt;

&lt;p&gt;配置好上述之后，就可以选择不同环境运行app了。可以在手机上生成不同的环境的app，可以同时安装。如下图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-a646aa4090d14d41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;section-2&quot;&gt;5. 配置和获取环境变量&lt;/h5&gt;

&lt;p&gt;接下来讲几种动态配置环境变量的方法&lt;/p&gt;

&lt;h6 id=&quot;gccgccpreprocessordefinitions&quot;&gt;1. 使用GCC预编译头参数GCC_PREPROCESSOR_DEFINITIONS&lt;/h6&gt;

&lt;p&gt;我们进入到Build Settings里面，可以找到Apple LLVM Preprocessing，这里我们可以找到&lt;strong&gt;Preprocessor Macros&lt;/strong&gt;在这里，我们是可以加一些环境变量的宏定义来标识符。Preprocessor Macros可以根据不同的环境预先制定不同定义的宏。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-427d4a19e32c41f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;
如上图，圈出来的地方其实就是一个标识符。&lt;/p&gt;

&lt;p&gt;有了这些我们预先设置的标识符之后，我们就可以在代码里面写入如下的代码了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
#ifdef DEVELOP
#define searchURL @&quot;http://www.baidu.com&quot;
#define sociaURL  @&quot;weibo.com&quot;
#elif UAT
#define searchURL @&quot;http://www.bing.com&quot;
#define sociaURL  @&quot;twitter.com&quot;
#else
#define searchURL @&quot;http://www.google.com&quot;
#define sociaURL  @&quot;facebook.com&quot;
#endif

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h6 id=&quot;plist&quot;&gt;2. 使用plist文件动态配置环境变量&lt;/h6&gt;

&lt;p&gt;我们先来新建3个名字一样的plist作为3个环境的配置文件。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-ea7dd9eeead81ce0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里名字一样的好处是写代码方便，因为就只需要去读取“Configuration.plist”就可以了，如果名字不一样，还要分别去把对应环境的plist名字拼接出来才能读取。&lt;/p&gt;

&lt;p&gt;众所周知，在一个文件夹里面新建2个相同名字的文件，Mac 系统都会提示我们名字相同，不允许我们新建。那我们怎么新建3个相同名字的文件呢？这其实很简单，分别放在3个不同文件夹下面即可。如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-34d9755680c0828e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我就是这样放置的，大家可以根据自己习惯去放置文件。&lt;/p&gt;

&lt;p&gt;接下来我们要做的是在编译的时候，运行app前，动态的copy Configuration.plist到app里面，这里需要设置一个copy脚本。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-11b5eb2740734f28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;进入到我们的Target里面，找到&lt;strong&gt;Build Phases&lt;/strong&gt;，我们新建一个&lt;strong&gt;New Copy Files Phase&lt;/strong&gt;，并且重命名为&lt;strong&gt;Copy Configuration Files&lt;/strong&gt;。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
echo &quot;CONFIGURATION -&amp;gt; ${CONFIGURATION}&quot;
RESOURCE_PATH=${SRCROOT}/${PRODUCT_NAME}/config/${CONFIGURATION}

BUILD_APP_DIR=${BUILT_PRODUCTS_DIR}/${PRODUCT_NAME}.app

echo &quot;Copying all files under ${RESOURCE_PATH} to ${BUILD_APP_DIR}&quot;
cp -v &quot;${RESOURCE_PATH}/&quot;* &quot;${BUILD_APP_DIR}/&quot;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这一段脚本就能保证我们的Configuration.plist 文件可以在编译的时候，选择其中一个打包进我们的app。&lt;/p&gt;

&lt;p&gt;再写代码每次读取这个plist里面的信息就可以做到动态化了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
- (NSString *) readValueFromConfigurationFile {
    NSBundle *bundle = [NSBundle mainBundle];
    NSString *path = [bundle pathForResource:@&quot;Configuration&quot; ofType:@&quot;plist&quot;];
    NSDictionary *config = [NSDictionary dictionaryWithContentsOfFile:path];
    return config[@&quot;serverURL&quot;];
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里我假设plist文件里面预设置了一个serverURL的字符串，用这种方式就可以读取出来了。当然在plist里面也可以设置数组，字典，相应的把返回值和Key值改一下就可以了。&lt;/p&gt;

&lt;h6 id=&quot;section-3&quot;&gt;3. 使用单例来处理环境切换&lt;/h6&gt;

&lt;p&gt;当然使用一个单例也可以做到环境切换。新建一个单例，然后可以在设置菜单里面加入一个列表，里面列出所有的环境，然后用户选择以后，单例就初始化用户所选的环境。和上面几种方式不同的是，这种方式就是在一个app里面切换多种环境。看大家的需求，任取所需。&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;二.利用文件来配置多环境&lt;/h4&gt;
&lt;p&gt;说道&lt;a href=&quot;https://developer.apple.com/library/ios/recipes/xcode_help-project_editor/Articles/BasingBuildConfigurationsonConfigurationFiles.html&quot;&gt;xcconfig&lt;/a&gt;，这个官方文档上面也提到的不是很详细，在网上寻找了一下，倒是找到了另外一份详细非官方文档。&lt;a href=&quot;http://pewpewthespells.com/blog/xcconfig_guide.html#CondVarSDK&quot;&gt;The Unofficial Guide to xcconfig files&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;提到xcconfig，就要先说说几个概念。&lt;/p&gt;

&lt;h5 id=&quot;section-5&quot;&gt;1. 区分几个概念&lt;/h5&gt;
&lt;p&gt;先来区分一下Xcode Workspace、Xcode Scheme、Xcode Project、Xcode Target、Build Settings 这5者的关系。这5者的关系在苹果官方文档上其实都已经说明的很清楚了。详情见文档&lt;a href=&quot;https://developer.apple.com/library/ios/featuredarticles/XcodeConcepts/Concept-Targets.html&quot;&gt;Xcode Concepts&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;我来简单来解读一下文档。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Xcode Workspace&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A workspace is an Xcode document that groups projects and other documents so you can work on them together. A workspace can contain any number of Xcode projects, plus any other files you want to include. In addition to organizing all the files in each Xcode project, a workspace provides implicit and explicit relationships among the included projects and their targets.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;workspace这个概念大家应该都很清楚了。它可以包含多个Project和其他文档文件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Xcode Project&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;An Xcode project is a repository for all the files, resources, and information required to build one or more software products. A project contains all the elements used to build your products and maintains the relationships between those elements. It contains one or more targets, which specify how to build products. A project defines default build settings for all the targets in the project (each target can also specify its own build settings, which override the project build settings).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;project就是一个个的仓库，里面会包含属于这个项目的所有文件，资源，以及生成一个或者多个软件产品的信息。每一个project会包含一个或者多个 targets，而每一个 target 告诉我们如何生产 products。project 会为所有 targets 定义了默认的 build settings，每一个 target 也能自定义自己的 build settings，且 target 的 build settings 会重写 project 的 build settings。&lt;/p&gt;

&lt;p&gt;最后这句话比较重要，下面设置xcconfig的时候就会用到这一点。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-3175b62b1a46caad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Xcode Project 文件会包含以下信息，对资源文件的引用(源码.h和.m文件，frame，资源文件plist，bundle文件等，图片文件image.xcassets还有Interface Builder(nib)，storyboard文件)、文件结构导航中用来组织源文件的组、Project-level build configurations(Debug\Release)、Targets、可执行环境，该环境用于调试或者测试程序。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Xcode Target&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A target specifies a product to build and contains the instructions for building the product from a set of files in a project or workspace. A target defines a single product; it organizes the inputs into the build system—the source files and instructions for processing those source files—required to build that product. Projects can contain one or more targets, each of which produces one product.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;target 会有且唯一生成一个 product, 它将构建该 product 所需的文件和处理这些文件所需的指令集整合进 build system 中。Projects 会包含一个或者多个 targets,每一个 target 将会产出一个 product。&lt;/p&gt;

&lt;p&gt;这里值得说明的是，每个target 中的 build setting 参数继承自 project 的 build settings, 一旦你在 target 中修改任意 settings 来重写 project settings，那么最终生效的 settings 参数以在 target 中设置的为准. Project 可以包含多个 target, 但是在同一时刻，只会有一个 target 生效，可用 Xcode 的 scheme 来指定是哪一个 target 生效。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Build Settings&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A build setting is a variable that contains information about how a particular aspect of a product’s build process should be performed. For example, the information in a build setting can specify which options Xcode passes to the compiler.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;build setting 中包含了 product 生成过程中所需的参数信息。project的build settings会对于整个project 中的所有targets生效，而target的build settings是重写了Project的build settings，重写的配置以target为准。&lt;/p&gt;

&lt;p&gt;一个 build configaration 指定了一套 build settings 用于生成某一 target 的 product，例如Debug和Release就属于build configaration。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Xcode Scheme&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;An Xcode scheme defines a collection of targets to build, a configuration to use when building, and a collection of tests to execute.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一个Scheme就包含了一套targets(这些targets之间可能有依赖关系)，一个configuration，一套待执行的tests。&lt;/p&gt;

&lt;p&gt;这5者的关系，举个可能不恰当的例子，
Xcode Workspace就如同工厂，Xcode Project如同车间，每个车间可以独立于工厂来生产产品(project可独立于workspace存在)，但是各个车间组合起来就需要工厂来组织(如果用了cocopods，就需要用workspace)。Xcode Target是一条条的流水线，一条流水线上面只生产一种产品。Build Settings是生产产品的秘方，如果是生产汽水，Build Settings就是其中各个原料的配方。Xcode Scheme是生产方案，包含了流水线生产，秘方，还包含生产完成之后的质检(test)。&lt;/p&gt;

&lt;h5 id=&quot;xcconfig&quot;&gt;2. 来创建一个xcconfig文件&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-bbb676bc468f1522.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后创建好了这个文件，我们在project里面设置一下。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-4d0d012da710a3f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在这些地方把配置文件换成我们刚刚新建的文件。&lt;/p&gt;

&lt;p&gt;接下来就要编写我们的xcconfig文件了。这个文件里面可以写的东西挺多的。细心的同学就会发现，其实我们一直使用的cocopods就是用这个文件来配置编译参数的。我们随便看一个简单的cocopods的xcconfig文件，就是下图这样子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
GCC_PREPROCESSOR_DEFINITIONS = $(inherited) COCOAPODS=1
HEADER_SEARCH_PATHS = $(inherited) &quot;${PODS_ROOT}/Headers/Public&quot; &quot;${PODS_ROOT}/Headers/Public/Forms&quot;
OTHER_CFLAGS = $(inherited) -isystem &quot;${PODS_ROOT}/Headers/Public&quot; -isystem &quot;${PODS_ROOT}/Headers/Public/Forms&quot;
OTHER_LDFLAGS = $(inherited) -ObjC -l&quot;Forms&quot;
PODS_ROOT = ${SRCROOT}/Pods
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们由于需要配置网络环境，那可以这样写&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//网络请求baseurl
REQUESTBASE_URL = @&quot;http:\\/\\/10.20.100.1&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当然也可以写成cocopods那样&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GCC_PREPROCESSOR_DEFINITIONS = $(inherited) WEBSERVICE_URL=&#39;$(REQUESTBASE_URL)&#39; MESSAGE_SYSTEM_URL=&#39;$(MESSAGE_SYSTEM_URL)&#39;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里利用了一个GCC_PREPROCESSOR_DEFINITIONS编译参数。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Space-separated list of option specifications. Specifies preprocessor macros in the form foo (for a simple #define) or foo=1 (for a value definition). This list is passed to the compiler through the gcc -D option when compiling precompiled headers and implementation files.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;GCC_PREPROCESSOR_DEFINITIONS 是 GCC 预编译头参数，通常我们可以在 Project 文件下的 Build Settings 对预编译宏定义进行默认赋值。&lt;/p&gt;

&lt;p&gt;它就是在Build Settings里面的 Apple LLVM 7.X - Preprocessing - Preprocessor Macros 这里。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-94666192eecdeb75.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Preprocessor Macros 其实是按照 Configuration 选项进行默认配置的, 它是可以根据不同的环境预先制定不同定义的宏，或者为不同环境下的相同变量定义不同的值。&lt;/p&gt;

&lt;p&gt;xcconfig 我们可以写入不同的 Configuration 选项配置不同的文件。每一个 xcconfig 可以配置 Build Settings 里的属性值, 其实实质就是通过 xcconfig 去修改 GCC_PREPROCESSOR_DEFINITIONS 的值，这样我们就可以做到动态配置环境的需求了。&lt;/p&gt;

&lt;p&gt;最后还需要提的一点是，这个配置文件的level的问题。现在本地有这么多配置，到底哪一个最终生效呢？打开Build 里面的level，我们来看一个例子。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-33b4ba6054123d00.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们目前可以看到有5个配置，他们是有优先级的。优先级是从左往右，依次降低的。Resolved = target-level &amp;gt; project-level &amp;gt; 自定义配置文件 &amp;gt; iOS 默认配置。左边第一列永远显示的是当前生效的最终配置结果。&lt;/p&gt;

&lt;p&gt;知道了这个优先级之后，我们可以更加灵活的配置我们的app了。&lt;/p&gt;

&lt;p&gt;最后关于xcconfig配置，基本使用就这些了。但是这里面的学问不仅仅这些。&lt;/p&gt;

&lt;p&gt;还能利用xcconfig动态配置Build Settings里面的很多参数。这其实类似于cocopods的做法。但是有一个大神的做法很优雅。值得大家感兴趣的人去学习学习。iOS大神&lt;a href=&quot;https://github.com/jspahrsummers&quot;&gt;Justin Spahr-Summers&lt;/a&gt;的开源库&lt;a href=&quot;https://github.com/jspahrsummers/xcconfigs&quot;&gt;xcconfigs&lt;/a&gt;提供了一个类权威的模板, 这是一个很好的学习使用xcconfig的库，强烈推荐。&lt;/p&gt;

&lt;p&gt;最后这里有一个Demo，配置了Cocopods，配置了xcconfig文件，还有Build Configuration的，大家可以看看，请多多指教，&lt;a href=&quot;https://github.com/halfrost/MultiEnvironmentsSettingDemo&quot;&gt;Demo&lt;/a&gt;。&lt;/p&gt;

&lt;h4 id=&quot;targets&quot;&gt;三.利用Targets来配置多环境&lt;/h4&gt;

&lt;p&gt;配置一个多环境其实一个Scheme和xcconfig已经完全够用了，为什么还要有这个第三点呢？虽说仅仅为了配置一个多环境这点“小事”，但是利用多个Targets也能实现需求，只不过有点“兴师动众”了。&lt;/p&gt;

&lt;p&gt;关于构建Targets这个技术，我也是在2年前的公司实践过。当时的需求是做一个OEM的产品。自己公司有主要产品，也帮其他公司做OEM。一说到OEM，大家应该就知道Targets用到这里的妙用了。利用Targets可以瞬间大批量产生大量的app。&lt;/p&gt;

&lt;p&gt;2013年巧哥也发过关于Targets的文章，&lt;a href=&quot;http://blog.devtang.com/2013/10/17/the-tech-detail-of-ape-client-1/&quot;&gt;猿题库iOS客户端的技术细节（一）：使用多target来构建大量相似App&lt;/a&gt;，我原来公司在2014年也实现了这种功能。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-40ecd04a0ed9b2f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;仅仅只用一套代码，就可以生产出7个app。7个app的证书都是不同的，配置也都不同，但是代码只需要维护一套代码，就可以完成维护7个app的目标。&lt;/p&gt;

&lt;p&gt;下面我们来看看怎么新建Targets，有2种方法。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-df956ff180fbef19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一种方法是完全新建一个Targets，另外一种方法是复制原有的Targets。&lt;/p&gt;

&lt;p&gt;其实第一种方法建立出Targets，之后看你需求是怎么样的。如果也想是做OEM这种，可以把新建出来的project删掉，本地还是维护一套代码，然后在新建的Targets 的Build Phases里面去把本地现有代码加上，参数自己可以随意配置。这样也是一套代码维护多个app。&lt;/p&gt;

&lt;p&gt;第二种方法就是复制一个原有的Targets，这种做法只用自己去改参数就可以了。&lt;/p&gt;

&lt;p&gt;再来说说Targets的参数。&lt;/p&gt;

&lt;p&gt;由于我们新建了Targets，相当于新建了一个app了。所以里面的所有的文件全部都可以更改。包括info.plist，源码引用，Build Settings……所有参数都可以改，这样就不仅仅局限于修改Scheme和xcconfig，所以之前说仅仅配置一个多环境用Targets有点兴师动众，但是它确实能完成目的。根据第二章里面我们也提到了，Targets相当于流水线，仅次于Project的地位，可以想象，有了Targets，我们没有什么不能修改的。&lt;/p&gt;

&lt;p&gt;PS.最后关于Targets还有一点想说的，如果大家有多个app，并且这几个app之间有超过80%的代码都是完全一样的，或者说仅仅只是个别界面显示不同，逻辑都完全相同，建议大家用Targets来做，这样只需要维护一套代码就可以了。维护多套相同的代码，实在太没有效率了。一个bug需要在多套代码上面来回改动，费时费力。&lt;/p&gt;

&lt;p&gt;这时候可能有人会问了，如果维护一套代码，以后这些app如果需求有不同怎么办？？比如要进入不同界面，跳转不同界面，页面也显示不同怎么办？？这个问题其实很简单。在Targets里面的&lt;strong&gt;Compile Sources&lt;/strong&gt;里面是可以给每个不同的Targets添加不同的编译代码的。只需要在每个不同的Targets里面加入不同界面的代码进行编译就可以了，在跳转的那个界面加上宏，来控制不同的app跳转到相应界面。这样本地还是维护的一套代码，只不过每个Targets编译的代码就是这套代码的子集了。这样维护起来还是很方便。也实现了不同app不同界面，不同需求了。&lt;/p&gt;

&lt;h4 id=&quot;section-6&quot;&gt;最后&lt;/h4&gt;
&lt;p&gt;其实这篇文章的需求源自于上篇Jenkins自动化持续集成，有一个需求是能打不同环境的包。之前没有Jenkins的时候就改改URL运行一遍就好，虽说做法不够优雅，但是也不麻烦。现在想持续集成，只好把环境都分好，参数配置正确，这样Jenkins可以一次性多个环境的包一起打。真正做到多环境的持续集成。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-83b1d03a7495cfe1.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后就可以打出不同环境的包了。请大家多多指教。&lt;/p&gt;
</description>
        <pubDate>Thu, 11 Aug 2016 09:01:02+0800</pubDate>
        <link>http://vno.onevcat.com/2016/08/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E7%BB%99%E4%B8%80%E4%B8%AAiOS-app%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AA%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</link>
        <guid isPermaLink="true">http://vno.onevcat.com/2016/08/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E7%BB%99%E4%B8%80%E4%B8%AAiOS-app%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AA%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</guid>
        
        <category>iOS</category>
        
        
        <category>Blog</category>
        
      </item>
    
      <item>
        <title>手把手教你利用Jenkins持续集成iOS项目</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-6a6d55579dcbe2d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;前言&lt;/h4&gt;
&lt;p&gt;众所周知，现在App的竞争已经到了用户体验为王，质量为上的白热化阶段。用户们都是很挑剔的。如果一个公司的推广团队好不容易砸了重金推广了一个APP，好不容易有了一些用户，由于一次线上的bug导致一批的用户在使用中纷纷出现闪退bug，轻则，很可能前期推广砸的钱都白费了，重则，口碑不好，未来也提升不起用户量来了。静下心来分析一下问题的原因，无外乎就是质量没有过关就上线了。除去主观的一些因素，很大部分的客观因素我觉得可以被我们防范的。根据大神们提出的一套开发规范建议，CI + FDD，就可以帮助我们极大程度的解决客观因素。本文接下来主要讨论 &lt;a href=&quot;http://martinfowler.com/articles/continuousIntegration.html&quot;&gt;Continuous Integration&lt;/a&gt; 持续集成（简称CI）&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;目录&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;1.为什么我们需要持续集成&lt;/li&gt;
  &lt;li&gt;2.持续化集成工具——Jenkins&lt;/li&gt;
  &lt;li&gt;3.iOS自动化打包命令——xcodebuild + xcrun 和 fastlane - gym 命令&lt;/li&gt;
  &lt;li&gt;4.打包完成自动化上传 fir / 蒲公英 第三方平台&lt;/li&gt;
  &lt;li&gt;5.完整的持续集成流程&lt;/li&gt;
  &lt;li&gt;6.Jenkins + Docker&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-2&quot;&gt;一. 为什么我们需要持续集成&lt;/h4&gt;
&lt;p&gt;谈到为什么需要的问题，我们就需要从什么是来说起。那什么是持续集成呢。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;持续集成是一种软件开发实践：许多团队频繁地集成他们的工作，每位成员通常进行日常集成，进而每天会有多种集成。每个集成会由自动的构建（包括测试）来尽可能快地检测错误。许多团队发现这种方法可以显著的减少集成问题并且可以使团队开发更加快捷。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;CI是一种开发实践。实践应该包含3个基本模块，一个可以自动构建的过程，自动编译代码，可以自动分发，部署和测试。一个代码仓库，SVN或者Git。最后一个是一个持续集成的服务器。通过持续集成，可以让我们通过自动化等手段高频率地去获取产品反馈并响应反馈的过程。&lt;/p&gt;

&lt;p&gt;那么持续集成能给我们带来些什么好处呢？这里推荐一篇&lt;a href=&quot;http://apiumtech.com/blog/top-benefits-of-continuous-integration-2/&quot;&gt;文章&lt;/a&gt;，文章中把&lt;a href=&quot;http://apiumtech.com/blog/top-benefits-of-continuous-integration-2/&quot;&gt;Continuous integration&lt;/a&gt; (CI) and &lt;a href=&quot;http://apiumtech.com/blog/20-benefits-of-test-driven-development/&quot;&gt;test-driven development&lt;/a&gt; (TDD)分成了12个步骤。然而带来的好处成倍增加，有24点好处。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-420f52f842539d5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我来说说用了CI以后带来的一些深有体会的优点。&lt;/p&gt;

&lt;h5 id=&quot;section-3&quot;&gt;1. 缩减开发周期，快速迭代版本&lt;/h5&gt;
&lt;p&gt;每个版本开始都会估算好开发周期，但是总会因为各种事情而延期。这其中包括了一些客观因素。由于产品线增多，迭代速度越来越快，给测试带来的压力也越来越大。如果测试都在开发完全开发完成之后再来测试，那就会影响很长一段时间。这时候由于集成晚就会严重拖慢项目节奏。如果能尽早的持续集成，尽快进入上图的12步骤的迭代环中，就可以尽早的暴露出问题，提早解决，尽量在规定时间内完成任务。&lt;/p&gt;

&lt;h5 id=&quot;section-4&quot;&gt;2. 自动化流水线操作带来的高效&lt;/h5&gt;
&lt;p&gt;其实打包对于开发人员来说是一件很耗时，而且没有很大技术含量的工作。如果开发人员一多，相互改的代码冲突的几率就越大，加上没有产线管理机制，代码仓库的代码质量很难保证。团队里面会花一些时间来解决冲突，解决完了冲突还需要自己手动打包。这个时候如果证书又不对，又要耽误好长时间。这些时间其实可以用持续集成来节约起来的。一天两天看着不多，但是按照年的单位来计算，可以节约很多时间！&lt;/p&gt;

&lt;h5 id=&quot;section-5&quot;&gt;3. 随时可部署&lt;/h5&gt;
&lt;p&gt;有了持续集成以后，我们可以以天为单位来打包，这种高频率的集成带来的最大的优点就是可以随时部署上线。这样就不会导致快要上线，到处是漏洞，到处是bug，手忙脚乱弄完以后还不能部署，严重影响上线时间。&lt;/p&gt;

&lt;h5 id=&quot;section-6&quot;&gt;4. 极大程度避免低级错误&lt;/h5&gt;
&lt;p&gt;我们可以犯错误，但是犯低级错误就很不应该。这里指的低级错误包括以下几点：编译错误，安装问题，接口问题，性能问题。
以天为单位的持续集成，可以很快发现编译问题，自动打包直接无法通过。打完包以后，测试扫码无法安装，这种问题也会立即被暴露出来。接口问题和性能问题就有自动化测试脚本来发现。这些低级问题由持续集成来暴露展现出来，提醒我们避免低级错误。&lt;/p&gt;

&lt;h4 id=&quot;jenkins&quot;&gt;二. 持续化集成工具——Jenkins&lt;/h4&gt;

&lt;p&gt;Jenkins 是一个开源项目，提供了一种易于使用的持续集成系统，使开发者从繁杂的集成中解脱出来，专注于更为重要的业务逻辑实现上。同时 Jenkins 能实施监控集成中存在的错误，提供详细的日志文件和提醒功能，还能用图表的形式形象地展示项目构建的趋势和稳定性。&lt;/p&gt;

&lt;p&gt;根据官方定义，Jenkins有以下的用途：
1. 构建项目
2. 跑测试用例检测bug
3. 静态代码检测
4. 部署&lt;/p&gt;

&lt;p&gt;关于这4点，实际使用中还是比较方便的：
1.构建项目自动化打包可以省去开发人员好多时间，重要的是，Jenkins为我们维护了一套高质量可用的代码，而且保证了一个纯净的环境。我们经常会出现由于本地配置出错而导致打包失败的情况。现在Jenkins就是一个公平的评判者，它无法正确的编译出ipa，那就是有编译错误或者配置问题。开发人员没必要去争论本地是可以运行的，拉取了谁谁谁的代码以后就不能运行了。共同维护Jenkins的正常编译，因为Jenkins的编译环境比我们本地简单的多，它是最纯净无污染的编译环境。开发者就只用专注于编码。这是给开发者带来的便利。&lt;/p&gt;

&lt;p&gt;2.这个可以用来自动化测试。在本地生成大批的测试用例。每天利用服务器不断的跑这些用例。每天每个接口都跑一遍。看上去没必要，但是实际上今天运行正常的系统，很可能由于今天的代码改动，明天就出现问题了。有了Jenkins可以以天为单位的进行回归测试，代码只要有改动，Jenkins就把所有的回归测试的用例全部都跑一遍。在项目工期紧张的情况下，很多情况测试都不是很重视回归测试，毕竟很可能测一遍之后是徒劳的“无用功”。然而由于回归测试不及时，就导致到最后发版的时候系统不可用了，这时候回头查找原因是比较耗时的，查看提交记录，看到上百条提交记录，排查起来也是头疼的事情。以天为单位的回归测试能立即发现问题。测试人员每天可以专注按单元测试，一周手动一次回归测试。这是给测试者带来的便利。&lt;/p&gt;

&lt;p&gt;3.这个是静态代码分析，可以检测出很多代码的问题，比如潜在的内存泄露的问题。由于Jenkins所在环境的纯净，还是可以发现一些我们本地复杂环境无法发现的问题，进一步的提高代码质量。这是给质检带来的便利。&lt;/p&gt;

&lt;p&gt;4.随时部署。Jenkins在打包完成之后可以设定之后的操作，这个时候往往就是提交app到跑测试用例的系统，或者部署到内测平台生成二维码。部署中不能安装等一些低级问题随之立即暴露。测试人员也只需要扫一下二维码即可安装，很方便。这也算是给测试带来的便利。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-9c822836315163c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;以下的例子以2016-07-24 22:35的Weekly Release 2.15的版本为例。&lt;/p&gt;

&lt;p&gt;我们来开始安装Jenkins。从官网https://jenkins.io/ 上下载最新的pkg安装包。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-6a2c3d6d42f35d31.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-75539c56443392df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-126a68ae31c21e6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-1a24ed942db2a9d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-179ec0017a364cc5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-982058c2d4701b31.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;也可以下载jenkins.war, 然后运行Java -jar jenkins.war，进行安装。&lt;/p&gt;

&lt;p&gt;安装完成之后，Safari可能会自动打开，如果没有自动打开，打开浏览器，输入http://localhost:8080&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-086f6fe08841b673.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个时候可能会报一个错误。如果出现了这面的问题。出现这个问题的原因就是Java环境有问题，重新Java环境即可。&lt;/p&gt;

&lt;p&gt;这个时候如果你重启电脑会发现Jenkins给你新增了一个用户，名字就叫Jenkins，不过这个时候你不知道密码。你可能会去试密码，肯定是是不对的，因为初始密码很复杂。这个时候正确做法是打开http://localhost:8080 会出现下图的重设初始密码的界面。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-c8468fd91737f725.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;按照提示，找到/Users/Shared/Jenkins/Home/ 这个目录下，这个目录虽然是共享目录，但是有权限的，非Jenkins用户/secrets/目录是没有读写权限的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-1d3da60f2fb25127.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-ad7089207c1a3dcd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;打开initialAdminPassword文件，复制出密码，就可以填到网页上去重置密码了。如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-0bb3a8b2025ab014.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-cd9979b853d14ac6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-56431c2d22013dcd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-578857333787630a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-a5636c896f987a50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-f4e6e0284534291b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-7ac78a54760114dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一路安装过来，输入用户名，密码，邮件这些，就算安装完成了。&lt;/p&gt;

&lt;p&gt;还是继续登录localhost:8080  ，选择“系统管理”——“管理插件”，我们要先安装一些辅助插件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;安装GitLab插件&lt;/strong&gt;
因为我们用的是GitLab来管理源代码，Jenkins本身并没有自带GitLab插件，所以我们需要依次选择 &lt;strong&gt;系统管理&lt;/strong&gt;-&amp;gt;&lt;strong&gt;管理插件&lt;/strong&gt;，在“&lt;strong&gt;可选插件&lt;/strong&gt;”中选中“&lt;strong&gt;GitLab Plugin&lt;/strong&gt;”和“&lt;strong&gt;Gitlab Hook Plugin&lt;/strong&gt;”这两项，然后安装。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;安装Xcode插件&lt;/strong&gt;
同安装GitLab插件的步骤一样，我们依次选择&lt;strong&gt;系统管理&lt;/strong&gt;-&amp;gt;&lt;strong&gt;管理插件&lt;/strong&gt;，在“&lt;strong&gt;可选插件&lt;/strong&gt;”中选中“&lt;strong&gt;Xcode integration&lt;/strong&gt;”安装。&lt;/p&gt;

&lt;p&gt;安装完了这个，我们就可以配置一个构建项目了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-06d0118a5e04dadf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-b52d3d102c21f004.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击新建好的项目，进来配置一下&lt;strong&gt;General&lt;/strong&gt;参数。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-cc08dd2e01f3e230.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里可以设置包的保留天数还有天数。&lt;/p&gt;

&lt;p&gt;接着设置&lt;strong&gt;源码管理&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;由于现在我用到的是GitLab，先配置SSH Key，在Jenkins的证书管理中添加SSH。在Jenkins管理页面，选择“&lt;strong&gt;Credentials&lt;/strong&gt;”，然后选择“&lt;strong&gt;Global credentials (unrestricted)&lt;/strong&gt;”，点击“&lt;strong&gt;Add Credentials&lt;/strong&gt;”，如下图所示，我们填写自己的SSH信息，然后点击“&lt;strong&gt;Save&lt;/strong&gt;”，这样就把SSH添加到Jenkins的全局域中去了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-6d1b6f56e4dac318.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果正常的配置正确的话，是不会出现下图中的那段红色的警告。如果有下图的提示，就说明Jenkins还没有连通GitLab或者SVN，那就请再检查SSH Key是否配置正确。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-268313680eb7a9ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;构建触发器设置&lt;/strong&gt;这里是设置自动化测试的地方。这里涉及的内容很多，暂时我也没有深入研究，这里暂时先不设置。有自动化测试需求的可以好好研究研究这里的设置。&lt;/p&gt;

&lt;p&gt;不过这里有两个配置还是需要是配置的&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Poll SCM&lt;/strong&gt;  (poll source code management)  轮询源码管理
需要设置源码的路径才能起到轮询的效果。一般设置为类似结果： 0/5 * * * * 每5分钟轮询一次
&lt;strong&gt;Build periodically&lt;/strong&gt; (定时build) 
一般设置为类似： 00 20 * * *   每天 20点执行定时build 。当然两者的设置都是一样可以通用的。&lt;/p&gt;

&lt;p&gt;格式是这样的&lt;/p&gt;

&lt;p&gt;分钟(0-59) 小时(0-23) 日期(1-31) 月(1-12) 周几(0-7,0和7都是周日) &lt;a href=&quot;http://www.scmgalaxy.com/scm/setting-up-the-cron-jobs-in-jenkins-using-build-periodically-scheduling-the-jenins-job.html&quot;&gt;更加详细的设置看这里&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-af09deb5eb53c6f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;构建环境设置&lt;/strong&gt;
iOS打包需要签名文件和证书，所以这部分我们勾选“&lt;strong&gt;Keychains and Code Signing Identities&lt;/strong&gt;”和“&lt;strong&gt;Mobile Provisioning Profiles&lt;/strong&gt;”。
这里我们又需要用到Jenkins的插件，在系统管理页面，选择“&lt;strong&gt;Keychains and Provisioning Profiles Management&lt;/strong&gt;”。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-63ed7bd1daee82fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;进入&lt;strong&gt;Keychains and Provisioning Profiles Management&lt;/strong&gt;页面，点击“&lt;strong&gt;浏览&lt;/strong&gt;”按钮，分别上传自己的keychain和证书。上传成功后，我们再为keychain指明签名文件的名称。点击“&lt;strong&gt;Add Code Signing Identity&lt;/strong&gt;”，最后添加成功后如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-7fcfb1bcd4543907.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;
注意：我第一次导入证书和Provisioning Profiles文件，就遇到了一点小“坑”，我当时以为是需要证书，但是这里需要的Keychain，并不是cer证书文件。这个Keychain其实在/Users/管理员用户名/Library/keychains/login.keychain,当把这个Keychain设置好了之后，Jenkins会把这个Keychain拷贝到/Users/Shared/Jenkins/Library/keychains这里，(Library是隐藏文件)。Provisioning Profiles文件也直接拷贝到/Users/Shared/Jenkins/Library/MobileDevice文件目录下。&lt;/p&gt;

&lt;p&gt;这样Adhoc证书和签名文件就在Jenkins中配置好了，接下来我们只需要在item设置中指定相关文件即可。
回到我们新建的item，找到&lt;strong&gt;构建环境&lt;/strong&gt;，按下图选好自己的相关证书和签名文件。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-849e17d402c0b8c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接下来在进行&lt;strong&gt;构建&lt;/strong&gt;的设置
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-4ae0a5ae5d914ae8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们这里选择执行一段打包脚本。脚本在下一章节详细的讲解。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;构建后操作&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-0e5e09ad80e0c42b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里我们选择&lt;strong&gt;Execute a set of scripts&lt;/strong&gt;，这里也是一个脚本，这个脚本用来上传自动打包好的ipa文件。脚本在第四章节有详细的讲解。&lt;/p&gt;

&lt;p&gt;至此，我们的Jenkins设置就全部完成了。点击&lt;strong&gt;构建&lt;/strong&gt;，就会开始构建项目了。&lt;/p&gt;

&lt;p&gt;构建一次，各个颜色代表的意义如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-7f2d51581dd7d16a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;天气的晴雨表代表了项目的质量，这也是Jenkins的一个特色。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-4bbbd2b19dea15eb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果构建失败了，可以去查看&lt;strong&gt;Console Output&lt;/strong&gt;可以查看log日志。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-ccd34e26b402960e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;iosxcodebuild--xcrun--fastlane---gym-&quot;&gt;三. iOS自动化打包命令——xcodebuild + xcrun 和 fastlane - gym 命令&lt;/h4&gt;

&lt;p&gt;在日常开发中，打包是最后上线不可缺少的环节，如果需要把工程打包成 ipa 文件，通常的做法就是在 Xcode 里点击 「Product -&amp;gt; Archive」，当整个工程 archive 后，然后在自动弹出的 「Organizer」 中进行选择，根据需要导出 ad hoc，enterprise 类型的 ipa 包。虽然Xcode已经可以很完美的做到打包的事情，但是还是需要我们手动点击5，6下。加上我们现在需要持续集成，用打包命令自动化执行就顺其自然的需要了。&lt;/p&gt;

&lt;h5 id=&quot;xcodebuild--xcrun&quot;&gt;1. xcodebuild + xcrun命令&lt;/h5&gt;

&lt;p&gt;Xcode为我们开发者提供了一套构建打包的命令，就是xcodebuild
和xcrun命令。xcodebuild把我们指定的项目打包成.app文件，xcrun将指定的.app文件转换为对应的.ipa文件。&lt;/p&gt;

&lt;p&gt;具体的文档如下， &lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/xcodebuild.1.html&quot;&gt;xcodebuild官方文档&lt;/a&gt;、&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/xcrun.1.html&quot;&gt;xcrun官方文档&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NAME
xcodebuild – build Xcode projects and workspaces

SYNOPSIS
1. xcodebuild [-project name.xcodeproj] [[-target targetname] … | -alltargets] [-configuration configurationname] [-sdk [sdkfullpath | sdkname]] [action …] [buildsetting=value …] [-userdefault=value …]

2. xcodebuild [-project name.xcodeproj] -scheme schemename [[-destination destinationspecifier] …] [-destination-timeout value] [-configuration configurationname] [-sdk [sdkfullpath | sdkname]] [action …] [buildsetting=value …] [-userdefault=value …]

3. xcodebuild -workspace name.xcworkspace -scheme schemename [[-destination destinationspecifier] …] [-destination-timeout value] [-configuration configurationname] [-sdk [sdkfullpath | sdkname]] [action …] [buildsetting=value …] [-userdefault=value …]

4. xcodebuild -version [-sdk [sdkfullpath | sdkname]] [infoitem]

5. xcodebuild -showsdks

6. xcodebuild -showBuildSettings [-project name.xcodeproj | [-workspace name.xcworkspace -scheme schemename]]

7. xcodebuild -list [-project name.xcodeproj | -workspace name.xcworkspace]

8. xcodebuild -exportArchive -archivePath xcarchivepath -exportPath destinationpath -exportOptionsPlist path

9. xcodebuild -exportLocalizations -project name.xcodeproj -localizationPath path [[-exportLanguage language] …]

10. xcodebuild -importLocalizations -project name.xcodeproj -localizationPath path
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面10个命令最主要的还是前3个。&lt;/p&gt;

&lt;p&gt;接下来来说明一下参数：
-project -workspace：这两个对应的就是项目的名字。如果有多个工程，这里又没有指定，则默认为第一个工程。
-target：打包对应的targets，如果没有指定这默认第一个。
-configuration：如果没有修改这个配置，默认就是Debug和Release这两个版本，没有指定默认为Release版本。
-buildsetting=value …：使用此命令去修改工程的配置。
-scheme：指定打包的scheme。&lt;/p&gt;

&lt;p&gt;上面这些是最最基本的命令。&lt;/p&gt;

&lt;p&gt;上面10个命令的第一个和第二个里面的参数，其中 -target
 和 -configuration 参数可以使用 xcodebuild -list
获得，-sdk 参数可由 xcodebuild -showsdks
 获得，[buildsetting=value …] 用来覆盖工程中已有的配置。可覆盖的参数参考官方文档 &lt;a href=&quot;https://developer.apple.com/documentation/DeveloperTools/Reference/XcodeBuildSettingRef/&quot;&gt;Xcode Build Setting Reference&lt;/a&gt;。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;build
Build the target in the build root (SYMROOT). This is the default action, and is used if no action is given.

analyze
Build and analyze a target or scheme from the build root (SYMROOT). This requires specifying a scheme.

archive
Archive a scheme from the build root (SYMROOT). This requires specifying a scheme.

test
Test a scheme from the build root (SYMROOT). This requires specifying a scheme and optionally a destination.

installsrc
Copy the source of the project to the source root (SRCROOT).

install
Build the target and install it into the target’s installation directory in the distribution root (DSTROOT).

clean
Remove build products and intermediate files from the build root (SYMROOT).

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面第3个命令就是专门用来打带有Cocopods的项目，因为这个时候项目工程文件不再是xcodeproj了，而是变成了xcworkspace了。&lt;/p&gt;

&lt;p&gt;再来说说xcrun命令。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Usage:
PackageApplication [-s signature] application [-o output_directory] [-verbose] [-plugin plugin] || -man || -help

Options:

[-s signature]: certificate name to resign application before packaging
[-o output_directory]: specify output filename
[-plugin plugin]: specify an optional plugin
-help: brief help message
-man: full documentation
-v[erbose]: provide details during operation

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;参数不多，使用方法也很简单，xcrun -sdk iphoneos -v PackageApplication  + 上述一些参数。&lt;/p&gt;

&lt;p&gt;参数都了解之后，我们就来看看该如何用了。下面这个是使用了xcodebuild + xcrun命令写的自动化打包脚本&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 工程名
APP_NAME=&quot;YourProjectName&quot;
# 证书
CODE_SIGN_DISTRIBUTION=&quot;iPhone Distribution: Shanghai ******* Co., Ltd.&quot;
# info.plist路径
project_infoplist_path=&quot;./${APP_NAME}/Info.plist&quot;

#取版本号
bundleShortVersion=$(/usr/libexec/PlistBuddy -c &quot;print CFBundleShortVersionString&quot; &quot;${project_infoplist_path}&quot;)

#取build值
bundleVersion=$(/usr/libexec/PlistBuddy -c &quot;print CFBundleVersion&quot; &quot;${project_infoplist_path}&quot;)

DATE=&quot;$(date +%Y%m%d)&quot;
IPANAME=&quot;${APP_NAME}_V${bundleShortVersion}_${DATE}.ipa&quot;

#要上传的ipa文件路径
IPA_PATH=&quot;$HOME/${IPANAME}&quot;
echo ${IPA_PATH}
echo &quot;${IPA_PATH}&quot;&amp;gt;&amp;gt; text.txt

//下面2行是没有Cocopods的用法
echo &quot;=================clean=================&quot;
xcodebuild -target &quot;${APP_NAME}&quot;  -configuration &#39;Release&#39; clean

echo &quot;+++++++++++++++++build+++++++++++++++++&quot;
xcodebuild -target &quot;${APP_NAME}&quot; -sdk iphoneos -configuration &#39;Release&#39; CODE_SIGN_IDENTITY=&quot;${CODE_SIGN_DISTRIBUTION}&quot; SYMROOT=&#39;$(PWD)&#39;

//下面2行是集成有Cocopods的用法
echo &quot;=================clean=================&quot;
xcodebuild -workspace &quot;${APP_NAME}.xcworkspace&quot; -scheme &quot;${APP_NAME}&quot;  -configuration &#39;Release&#39; clean

echo &quot;+++++++++++++++++build+++++++++++++++++&quot;
xcodebuild -workspace &quot;${APP_NAME}.xcworkspace&quot; -scheme &quot;${APP_NAME}&quot; -sdk iphoneos -configuration &#39;Release&#39; CODE_SIGN_IDENTITY=&quot;${CODE_SIGN_DISTRIBUTION}&quot; SYMROOT=&#39;$(PWD)&#39;

xcrun -sdk iphoneos PackageApplication &quot;./Release-iphoneos/${APP_NAME}.app&quot; -o ~/&quot;${IPANAME}&quot;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;gym-&quot;&gt;2. gym 命令&lt;/h5&gt;
&lt;p&gt;说到gym，就要先说一下fastlane。
fastlane是一套自动化打包的工具集，用 Ruby 写的，用于 iOS 和 Android 的自动化打包和发布等工作。gym是其中的打包命令。&lt;/p&gt;

&lt;p&gt;fastlane 的官网看&lt;a href=&quot;https://fastlane.tools/&quot;&gt;这里&lt;/a&gt;, fastlane 的 github 看&lt;a href=&quot;https://github.com/fastlane/fastlane&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;要想使用gym，先要安装fastlane。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo gem install fastlane --verbose
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;fastlane包含了我们日常编码之后要上线时候进行操作的所有命令。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;deliver：上传屏幕截图、二进制程序数据和应用程序到AppStore
snapshot：自动截取你的程序在每个设备上的图片
frameit：应用截屏外添加设备框架
pem：可以自动化地生成和更新应用推送通知描述文件
sigh：生成下载开发商店的配置文件
produce：利用命令行在iTunes Connect创建一个新的iOS app
cert：自动创建iOS证书
pilot：最好的在终端管理测试和建立的文件
boarding：很容易的方式邀请beta测试
gym：建立新的发布的版本，打包
match：使用git同步你成员间的开发者证书和文件配置
scan：在iOS和Mac app上执行测试用例
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;整个发布过程可以用fastlane描述成下面这样&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;lane :appstore do
  increment_build_number
  cocoapods
  xctool
  snapshot
  sigh
  deliver
  frameit
  sh &quot;./customScript.sh&quot;

  slack
end

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Ps：这里可能大家还会听过一个命令叫 &lt;a href=&quot;https://github.com/facebook/xctool&quot;&gt;xctool&lt;/a&gt;
xctool是官方xcodebuild命令的一个增强实现，输出的内容比xcodebuild直观可读得多。通过brew即可安装。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;brew install xctool
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;使用gym自动化打包，&lt;a href=&quot;https://github.com/xilin/ios-build-script/blob/master/build_using_gym.sh&quot;&gt;脚本&lt;/a&gt;如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#计时

SECONDS=0

#假设脚本放置在与项目相同的路径下

project_path=$(pwd)

#取当前时间字符串添加到文件结尾

now=$(date +&quot;%Y_%m_%d_%H_%M_%S&quot;)

#指定项目的scheme名称

scheme=&quot;DemoScheme&quot;

#指定要打包的配置名

configuration=&quot;Adhoc&quot;

#指定打包所使用的输出方式，目前支持app-store, package, ad-hoc, enterprise, development, 和developer-id，即xcodebuild的method参数

export_method=&#39;ad-hoc&#39;

#指定项目地址

workspace_path=&quot;$project_path/Demo.xcworkspace&quot;

#指定输出路径

output_path=&quot;/Users/your_username/Documents/&quot;

#指定输出归档文件地址

archive_path=&quot;$output_path/Demo_${now}.xcarchive&quot;

#指定输出ipa地址

ipa_path=&quot;$output_path/Demo_${now}.ipa&quot;

#指定输出ipa名称

ipa_name=&quot;Demo_${now}.ipa&quot;

#获取执行命令时的commit message

commit_msg=&quot;$1&quot;

#输出设定的变量值

echo &quot;===workspace path: ${workspace_path}===&quot;

echo &quot;===archive path: ${archive_path}===&quot;

echo &quot;===ipa path: ${ipa_path}===&quot;

echo &quot;===export method: ${export_method}===&quot;

echo &quot;===commit msg: $1===&quot;

#先清空前一次build

gym --workspace ${workspace_path} --scheme ${scheme} --clean --configuration ${configuration} --archive_path ${archive_path} --export_method ${export_method} --output_directory ${output_path} --output_name ${ipa_name}

#输出总用时

echo &quot;===Finished. Total time: ${SECONDS}s===&quot;


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;fir---&quot;&gt;四. 打包完成自动化上传 fir / 蒲公英 第三方平台&lt;/h4&gt;

&lt;p&gt;要上传到 fir / 蒲公英 第三方平台，都需要注册一个账号，获得token，之后才能进行脚本化操作。&lt;/p&gt;

&lt;h5 id=&quot;fir&quot;&gt;1. 自动化上传fir&lt;/h5&gt;
&lt;p&gt;安装fir-clifir的命令行工具
需要先装好ruby再执行&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gem install fir-cli
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#上传到fir
fir publish ${ipa_path} -T fir_token -c &quot;${commit_msg}&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;section-7&quot;&gt;2.自动化上传蒲公英&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#蒲公英上的User Key
uKey=&quot;7381f97070*****c01fae439fb8b24e&quot;
#蒲公英上的API Key
apiKey=&quot;0b27b5c145*****718508f2ad0409ef4&quot;
#要上传的ipa文件路径
IPA_PATH=$(cat text.txt)

rm -rf text.txt

#执行上传至蒲公英的命令
echo &quot;++++++++++++++upload+++++++++++++&quot;
curl -F &quot;file=@${IPA_PATH}&quot; -F &quot;uKey=${uKey}&quot; -F &quot;_api_key=${apiKey}&quot; http://www.pgyer.com/apiv1/app/upload
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-8&quot;&gt;五. 完整的持续集成流程&lt;/h4&gt;

&lt;p&gt;经过上面的持续化集成，现在我们就拥有了如下完整持续集成的流程&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-60e101c4e6cc14fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;jenkins--docker&quot;&gt;六. Jenkins + Docker&lt;/h4&gt;

&lt;p&gt;关于Jenkins的部署，其实是分以下两种：
单节点（Master）部署
这种部署适用于大多数项目，其构建任务较轻，数量较少，单个节点就足以满足日常开发所需。
多节点(Master-Slave)部署
通常规模较大，代码提交频繁（意味着构建频繁），自动化测试压力较大的项目都会采取这种部署结构。在这种部署结构下，Master通常只充当管理者的角色，负责任务的调度，slave节点的管理，任务状态的收集等工作，而具体的构建任务则会分配给slave节点。一个Master节点理论上可以管理的slave节点数是没有上限的，但通常随着数量的增加，其性能以及稳定性就会有不同程度的下降，具体的影响则因Master硬件性能的高低而不同。&lt;/p&gt;

&lt;p&gt;但是多节点部署又会有一些缺陷，当测试用例变得海量以后，会造成一些问题，于是有人设计出了下面这种部署结构，Jenkins + Docker&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-71ccde99201bf290.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由于笔者现在的项目还处于单节点（Master）部署，关于多节点(Master-Slave)部署也没有实践经验，改进版本的Docker更是没有接触过，但是如果有这种海量测试用例，高压力的大量复杂的回归测试的需求的，那推荐大家看这篇&lt;a href=&quot;http://www.zjbonline.com/2016/03/05/Jenkins-Docker%E6%90%AD%E5%BB%BA%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83/&quot;&gt;文章&lt;/a&gt;。&lt;/p&gt;

&lt;h4 id=&quot;section-9&quot;&gt;最后&lt;/h4&gt;

&lt;p&gt;以上就是我关于Jenkins持续集成的一次实践经验。分享给大家，如果里面有什么错误，欢迎大家多多指教。&lt;/p&gt;
</description>
        <pubDate>Sun, 31 Jul 2016 15:04:02+0800</pubDate>
        <link>http://vno.onevcat.com/2016/07/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%88%A9%E7%94%A8Jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90iOS%E9%A1%B9%E7%9B%AE/</link>
        <guid isPermaLink="true">http://vno.onevcat.com/2016/07/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%88%A9%E7%94%A8Jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90iOS%E9%A1%B9%E7%9B%AE/</guid>
        
        <category>iOS</category>
        
        
        <category>Blog</category>
        
      </item>
    
      <item>
        <title>关于IB_DESIGNABLE / IBInspectable的那些需要注意的事</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-0c431c95e1f76510.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;前言&lt;/h4&gt;

&lt;p&gt;IB_DESIGNABLE / IBInspectable 这两个关键字是在WWDC 2014年”What’s New in Interface Builder”这个Session里面，用Swift讲过一个例子。也是随着Xcode 6 新加入的关键字。&lt;/p&gt;

&lt;p&gt;这两个关键字是用在我们自定义View上的，&lt;strong&gt;目前暂时只能用在UIView的子类中&lt;/strong&gt;所以系统自带的原生的那些控件使用这个关键字都没有效果。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Live RenderingYou can use two different attributes—@IBDesignable and @IBInspectable—to enable live, interactive custom view design in Interface Builder. When you create a custom view that inherits from the UIView class or the NSView class, you can add the @IBDesignable attribute just before the class declaration. After you add the custom view to Interface Builder (by setting the custom class of the view in the inspector pane), Interface Builder renders your view in the canvas.You can also add the @IBInspectable attribute to properties with types compatible with user defined runtime attributes. After you add your custom view to Interface Builder, you can edit these properties in the inspector.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其大意就是说，“所见即所得”的思想，我们可以将自定义的代码实时渲染到Interface Builder中。而它们之间的桥梁就是通过两个指令来完成，即@IBDesignable和@IBInspectable。我们通过@IBDesignable告诉Interface Builder这个类可以实时渲染到界面中，无论我们drawRect里面多么复杂，自定义有多复杂，Xib / Storyboard都可以把它编译出来，并且渲染展示出来。但是这个类必须是UIView或者NSView的子类。通过@IBInspectable可以定义动态属性，即可在Attributes inspector面板中可视化修改属性值。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; @IBInspectable var integer: Int = 0
 @IBInspectable var float: CGFloat = 0
 @IBInspectable var double: Double = 0
 @IBInspectable var point: CGPoint = CGPointZero
 @IBInspectable var size: CGSize = CGSizeZero
 @IBInspectable var customFrame: CGRect = CGRectZero
 @IBInspectable var color: UIColor = UIColor.clearColor()
 @IBInspectable var string: String = &quot;&quot;
 @IBInspectable var bool: Bool = false
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-19b37e597b722379.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这两个关键字不是今天的重点，看个Demo就会使用了。
&lt;a href=&quot;https://github.com/halfrost/CircleSlider&quot;&gt;Demo地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如果想看Session的话，可以看这两个WWDC 2014的链接&lt;br /&gt;
&lt;a href=&quot;http://devstreaming.apple.com/videos/wwdc/2014/401xxfkzfrjyb93/401/401_whats_new_in_xcode_6.pdf?dl=1&quot;&gt;whats_new_in_xcode_6&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://devstreaming.apple.com/videos/wwdc/2014/411xx0xo98zzoor/411/411_whats_new_in_interface_builder.pdf?dl=1&quot;&gt;whats_new_in_interface_builder&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://developer.apple.com/library/ios/recipes/xcode_help-IB_objects_media/Chapters/CreatingaLiveViewofaCustomObject.html#//apple_ref/doc/uid/TP40014224-CH41-SW1&quot;&gt;苹果官方文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;今天来分享一下我使用这两个关键字的时候遇到的一些问题和解决过程。&lt;/p&gt;

&lt;h4 id=&quot;the-agent-raised-a-nsinternalinconsistencyexception-exception&quot;&gt;1.The agent raised a “NSInternalInconsistencyException” exception&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 
file://BottomCommentView-master/BottomCommentView/Base.lproj/Main.storyboard: error: 
IB Designables: Failed to update auto layout status: The agent raised a &quot;NSInternalInconsistencyException&quot; exception: Could not load NIB in bundle: &#39;NSBundle &amp;lt;/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/Library/Xcode/Overlays&amp;gt; (loaded)&#39; with name &#39;BottomCommentView&#39;

file://BottomCommentView/Base.lproj/Main.storyboard: error:
 IB Designables: Failed to render instance of BottomCommentView: The agent threw an exception.   
 

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们会看到面板上Designables这里显示的是一个Crashed，Xib / Storyboard 居然也会Crashed！整个app是跑起来了，但是报了2个错，不能忍！这两个错其实是编译时候Xib报的错误，并不是运行时的错误。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-548c7e2d005a5da0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当我们看到Debug的时候，肯定第一想到的就是点Debug。但是很不幸的是，在这种情况下，点击Debug，每次都会告诉你“Finishing debugging instance of XXXX for interface Builder”，即使你在你自定义的View里面打了断点，也无济于事。&lt;/p&gt;

&lt;p&gt;回到问题上来，我们来仔细看看崩溃信息。信息上说Could not load NIB in bundle，并且还给了我们一个类似地址一样的东西’NSBundle &amp;lt;/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/Library/Xcode/Overlays&amp;gt; (loaded)’，我们可以定位到时Xib在从bundle中读取出来出错了。&lt;/p&gt;

&lt;p&gt;通过在网上查找资料，问题其实是这样的。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;When loading the nib, we’re relying on the fact that passing bundle: nil defaults to your app’s mainBundle at run time.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;每次我们取mainBundle的时候，都是用的默认的方法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let nib = UINib(nibName: String(StripyView), bundle: nil)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里在Xib / Storyboard 编译的时候，我们需要告诉iOS系统，我们要指定哪一个bundle类去读取。把上面的代码改成下面这样就可以了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let bundle = NSBundle(forClass: self.dynamicType)
let nib = UINib(nibName: String(StripyView), bundle: bundle)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;或者这样&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#if TARGET_INTERFACE_BUILDER
        NSBundle *bundle = [NSBundle bundleForClass:[self class]];
        [bundle loadNibNamed:@&quot;BottomCommentView&quot; owner:self options:nil];
#else
        [[NSBundle mainBundle] loadNibNamed:@&quot;BottomCommentView&quot; owner:self options:nil];
        
#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Ps:如果你自定义的View不显示在Xib / Storyboard上，但是程序一运行就又能显示出View来，原因也有可能是这个原因，虽然Xib / Storyboard没有报错，因为app没有运行起来，Xib / Storyboard并不知道上下文，所以没有把我们自定义的View加载出来。&lt;/p&gt;

&lt;h4 id=&quot;xib&quot;&gt;2.代码或者Xib依旧不显示自定义控件的样子&lt;/h4&gt;

&lt;p&gt;如果你按照上面的第一个问题里面加上了bundle的代码之后还是不显示，那可能是你代码加的地方不对。&lt;/p&gt;

&lt;p&gt;如果是代码手动创建控件的话，会调用initWithFrame方法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
- (instancetype)initWithFrame:(CGRect)frame
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果是通过Xib / Storyboard 拖拽显示控件的话，会调用initWithCoder方法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
- (instancetype)initWithCoder:(NSCoder *)aDecoder
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;需要在对应的这两个方法里面去加上bundle的方法。如果为了保险起见，那这两个init方法里面都加上问题一里面的代码吧。&lt;/p&gt;

&lt;h4 id=&quot;failed-to-update-auto-layout-status-the-agent-crashed--failed-to-render-instance-of-xxxxxxx-the-agent-crashed&quot;&gt;3.Failed to update auto layout status: The agent crashed / Failed to render instance of XXXXXXX: The agent crashed&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;file://BottomCommentView/Base.lproj/Main.storyboard: error: 
IB Designables: Failed to update auto layout status: The agent crashed

file://BottomCommentView/Base.lproj/Main.storyboard: error: 
IB Designables: Failed to render instance of BottomCommentView: The agent crashed

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果是遇到了这个问题，是比较严重的，这个问题不像问题一，问题一整个app是可以运行的，错误来源于Xib / Storyboard编译时候的错误，但是并不影响这个app的运行。&lt;/p&gt;

&lt;p&gt;但是这个问题会直接导致整个app闪退，直接Crashed掉！没办法，我们只能打断点debug一下。&lt;/p&gt;

&lt;p&gt;如果你在Designables 那里把Debug打开，然后断点打到initWithCoder 和 initWithFrame那里，会发现程序总是运行到这一行&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
self = [super initWithCoder:aDecoder];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;或者这一行&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
self = [super initWithFrame:frame];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;就崩溃了。其实从下面的栈信息也可以很快看出发生了什么：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-ee0d98669a4889f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-ca3fcc8e1ef9a9e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以很明显的看到，是initWithCoder这个方法陷入了死循环。由于这个死循环导致了程序Crashed了。&lt;/p&gt;

&lt;p&gt;可是这里为什么会死循环呢？其实根本原因在于，我们自定义的类的class写成自己了。&lt;/p&gt;

&lt;p&gt;来看看到底发生了什么。现在在Xode 7中，我们默认创建一个View，是不给我们默认生成一个XIB文件，ViewController会有下面那个选项，可以选择勾上。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-747a4d232003df04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在我们创建完这个类的时候，我们还要再创建一个Xib和这个类进行关联。&lt;/p&gt;

&lt;p&gt;再对比一下我们创建TableviewCell的过程&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-736c5bf9967f48af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一般我们会勾选上那个“Also create XIB file”，创建完成之后，我们就会在Custom Class里面把我们这个cell的类名填上。&lt;/p&gt;

&lt;p&gt;如果我们现在自定义View的时候也是相同做法，创建完Xib文件之后，File‘s owner关联好了之后。然后在Custom Class里面填上了我们自定义的类之后，这个时候就错了！&lt;/p&gt;

&lt;p&gt;为什么我们平时相同的做法，到这里就错误了呢？&lt;/p&gt;

&lt;p&gt;我们来考虑一下我们自定义View加载的过程。我们这个自定义View肯定是放在了一个ViewController上面，代码创建出来或者直接拖拽到Xib / Storyboard 上。用代码或者SB上面拖一个View，这个时候我们需要指定这个类是什么，这个毋庸置疑，是绝对没有问题的。SB上面拖的View的class肯定要选择我们自定义的这个View。&lt;/p&gt;

&lt;p&gt;但是在加载我们这个View的时候，会走initWithCoder / initWithFrame 方法，在这里方法里面又会去调用super的这个方法，现在我们把这个class写成了自己，依照我们上面调试的log，可以看到，initWithCoder以后，会按照以下的路线去调用.&lt;/p&gt;

&lt;p&gt;[NSBundle loadNibName] —— [UINib instantiateWithOwner:options] ——[UINibDecoder decodeObjectForKey:]——UINibDecoderDecodeObjectForValue——[UIRuntimeConnection initWithCoder]——[UINibDecoder decodeObjectForKey:]——UINibDecoderDecodeObjectForValue——[UIClassSwapper initWithCoder:]——[BottomCommentView initWithCoder:]&lt;/p&gt;

&lt;p&gt;从NSBundle加载开始，解析完之后会调用到ClassSwapper 的initWithCoder，由于我们class写了自己，这里就陷入死循环了。程序崩溃！这里就跟set方法里面调用点语法赋值一样，无限的递归调用了。&lt;/p&gt;

&lt;p&gt;经过上面的分析之后，我们就知道了问题就出在我们在initWithCoder里面又调用了loadNibName，loadNibName又会去最终调UIClassSwapper initWithCoder。难道是我们custom class不对么？对比一下我们自定义tableViewCell的class就是本身，怎么就没有这个问题呢。&lt;/p&gt;

&lt;p&gt;我们来仔细看看tableViewCell我们是怎么加载的，我们的Xib的class还是自己，但是registerWithNibName的方法调用在tableView中，这样就不会无限递归了。&lt;/p&gt;

&lt;p&gt;这里当然我们也可以仿照这个方法做，那我们需要把loadNibName写到另外一个类中去。class还是写自己本身，用那个类来加载我们这个View，这样就可以不崩溃，不会无限递归了。但是问题又来了，我们无法在Xib/Storyboard上实时预览到我们的View了。&lt;/p&gt;

&lt;p&gt;这里需要提一下IB_DESIGNABLE的工作原理。当我们用了IB_DESIGNABLE关键字以后，Xib/StoryBoard会在不运行整个程序的情况下，把这个View代码编译跑一遍，由于没有程序上下文，所有的编译就只在这个view的代码中进行。&lt;/p&gt;

&lt;p&gt;我们在ViewController里面拖拽了一个View，并且更改它的class为我们自定义的class，那么接下来所有view的绘制都会交给我们这个自定义view的class，由这个class来管理。这里就分两种情况了。第一种情况就是我文章一开头给的Demo的例子，用DrawRect代码绘制出这个View的样子。这里不会出现任何问题。第二种情况就是我们还想用一个Xib来显示View，这种情况就是Xib/StoryBoard里面再次加载Xib的情况了。由于现在我们自定义的class有了接管整个view的绘制权利，那么我们就应该在initWithCoder中loadNibName，把整个View在初始化的时候load出来。根据上面的分析，我们找到崩溃的原因是无限递归，这里又必须要调用initWithCoder，我们的唯一办法就是把class改成父类的class，即UIView，这时候一切就好了，Xib/Storyboard不报错，也能及时显示出view的样子来了。&lt;/p&gt;

&lt;p&gt;总结一下：
&amp;gt; when using loadNibNamed:owner:options:, the File’s Owner should be NSObject, the main view should be your class type, and all outlets should be hooked up to the view, not the File’s Owner.&lt;/p&gt;

&lt;p&gt;Ps.这里说的仅仅是loadNibNamed而不是initWithNibName。顺带提一下他们俩的不同点。initWithNibName要加载的Xib的类为我们定义的ViewController。loadNibNamed要加载的Xib的类为NSOjbect。他们的加载方式也不同，initWithNibName方法：是延迟加载，这个View上的控件是 nil 的，只有到需要显示时，才会不是 nil。loadNibNamed是立即加载，调用这个方法加载的xib对象中的各个元素都已经存在。&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;当我第一次知道IB_DESIGNABLE / IBInspectable之后，感觉到特别的神奇，连我们自定义化的View也可以及时可见了。不过经过一段研究以后就发现。IB_DESIGNABLE / IBInspectable还是有一些缺陷的。IB_DESIGNABLE暂时只能在UIView的子类中用，常用的UIButton加圆角这些暂时也没法预览。IBInspectable实质是在Runtime Attributes设置了值，这也使得IBInspectable只能使用常用类型。NSDate这种类型没法设置成IBInspectable。&lt;/p&gt;

&lt;p&gt;以上就是我和大家分享的IB_DESIGNABLE / IBInspectable使用过程中遇到的一些“坑”。&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;更新：&lt;/h4&gt;
&lt;p&gt;下面这一段要感谢@&lt;strong&gt;Andy矢倉&lt;/strong&gt; 微博上面指点我，其实系统的子类可以这么做：抽了几个常用的控件的公共类，顺便用External剥离常用属性，更复杂的移步这个库&lt;a href=&quot;https://github.com/JakeLin/IBAnimatable&quot;&gt;IBAnimatable&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;@&lt;strong&gt;Andy矢倉&lt;/strong&gt;还提醒说，用这个特性最好是iOS8 + Swift，OC或者iOS7都会出现Failed to update而且无解，再次感谢@&lt;strong&gt;Andy矢倉&lt;/strong&gt;大神的指点！！！下图是他对系统控件的可视化改造！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-932768201a4dae84.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 22 Jul 2016 21:13:02+0800</pubDate>
        <link>http://vno.onevcat.com/2016/07/%E5%85%B3%E4%BA%8EIB_DESIGNABLE-IBInspectable%E7%9A%84%E9%82%A3%E4%BA%9B%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E4%BA%8B/</link>
        <guid isPermaLink="true">http://vno.onevcat.com/2016/07/%E5%85%B3%E4%BA%8EIB_DESIGNABLE-IBInspectable%E7%9A%84%E9%82%A3%E4%BA%9B%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E4%BA%8B/</guid>
        
        <category>iOS</category>
        
        
        <category>Blog</category>
        
      </item>
    
      <item>
        <title>WWDC2016 Session笔记 - Xcode 8 Auto Layout新特性</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-520084e0dda3ed1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;目录&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;1.Incrementally Adopting Auto Layout&lt;/li&gt;
  &lt;li&gt;2.Design and Runtime Constraints&lt;/li&gt;
  &lt;li&gt;3.NSGridView&lt;/li&gt;
  &lt;li&gt;4.Layout Feedback Loop Debugging&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;incrementally-adopting-auto-layout&quot;&gt;一.Incrementally Adopting Auto Layout&lt;/h4&gt;
&lt;p&gt;Incrementally Adopting Auto Layout是什么意思呢？在我们IB里面布局我们的View的时候，我们并不需要一次性就添加好所有的constraints。我们可以一步步的增加constraints，简化我们的步骤，而且能让我们的设置起来更加灵活。&lt;/p&gt;

&lt;p&gt;再谈新特性之前，先介绍一下这个特性对应的背景来源。&lt;/p&gt;

&lt;p&gt;有这样一种场景，试想，我们把一个view放在父view上，这个时候并没有设置constraints，当我们运行完程序，就会出现下图的样子。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-637527eb1a0ca498.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看上去一切都还正常。但是一旦当我们把设备旋转90°以后，就会出现下图的样子。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-d716316a84356bf1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个时候可以发现，这个View的长，宽，以及top和left的边距都没有发生变化。这时我们并没有设置constraints，这是怎么做到的呢？&lt;/p&gt;

&lt;p&gt;在程序的编译期，Auto Layout的引擎会自动隐式的给View加上一些constraints约束，以保证View的大小不会发生变化。这个例子中，View被加上了top，left，width，height这4个约束。&lt;/p&gt;

&lt;p&gt;如果我们需要更加动态的resize的行为，就需要我们在IB里面自定义约束了。现在问题就来了，有没有更好的方式来做这件事情？最好是能有一种不用约束的方法，也能达到简单的resize的效果。&lt;/p&gt;

&lt;p&gt;现在这个问题有了解决办法。在Xcode8中，我们可以给View指定autoresizing masks，而不用去设置constraints。这就意味着我们可以不用约束，我们也能做到简单的resize的效果。&lt;/p&gt;

&lt;p&gt;在Autolayout时代之前，可能会有人认出这种UI方式。这是一种Springs &amp;amp; Struts的UI。我们可以设定边缘约束(注：这里的约束并不是指的是Autolayout里面的constraints，是autoresizing masks里面的规则)，无论View的长宽如何变化，这些View都会跟随着设置了约束的view一起变化。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-d66036d42faa95e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上述的例子中，Xcode 8 中在没有加如何constraint就可以做到旋转屏幕之后，View的边距并没有发生变化。这是怎么做到的呢？事实上，Xcode 8的做法是先取出autoresizing masks，然后把它转换成对应的constraints，这个转换的时机发生在Runtime期间。生成对应的constraints是发生在运行时，而不是编译时的原因是可以给我们开发者更加便利的方式为View添加更加细致的约束。&lt;/p&gt;

&lt;p&gt;在View上，我们可以设置translatesAutoresizingMaskIntoConstraints属性。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;translatesAutoresizingMaskIntoConstraints == true  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;假设如果View已经在Interface Builder里面加过constraints，“Show the Size inspector”面板依旧会和以前一样。点击View，查看给它加的所有的constraints，这个时候Autoresizing masks就被忽略了，而且translatesAutoresizingMask的属性也会变成false。如下图，我们这个时候在“Show the Size inspector”面板上面就已经看不到AutoresizingMask的设置面板了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-8fa2f4a12705805d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-a572a36604c85ffd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;
上图就是在Autolayout时代之前，我们一直使用的是autoresizing masks，但是Autolayout时代来临之后，一旦勾选上了这个Autolayout，之前的AutoresizingMask也就失效了。&lt;/p&gt;

&lt;p&gt;回到我们最原始的问题上来，Xcode 8 现在针对View可以支持增量的适用Autolayout。这就意味着我们可以从AutoresizingMask开始，先做简单的resize的工作，然后如果有更加复杂的需求，我们再加上适当的约束constraints来进行适配。简而概之，Xcode 8 Autolayout ≈ AutoresizingMask + Autolayout 。&lt;/p&gt;

&lt;p&gt;接下来用一个demo的例子来说明一下Xcode 8 Autolayout新特性。&lt;br /&gt;
在说例子之前我们先来说一下Xcode 8在storyboard上新增了哪些功能。如下图，我们可以看到，在最下方新增加了一栏，可以切换不同的屏幕大小，可以看出，iPhone现在已经分化成6种屏幕大小需要我们适配了，从大到小，依次是：iPad pro 12.9, iPad 9.7 , iPhone 6s Plus/iPhone 6 Plus , iPhone 6s/iPhone 6, iPhone SE/iPhone5s/iPhone5, iPhone4s/iPhone4。下面还可以选择横竖屏，和不用屏幕百分比的适应性。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-ccd7ee3afb97128c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;回到例子，我们现在对页面上这些view来做简单的AutoresizingMask。右边的那个预览界面是可以看到我们加上这些Mask之后的效果。&lt;/p&gt;

&lt;p&gt;先是粉色的父View，我们给它加上如下的AutoresizingMask。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-541263982f9d5004.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;给”雨天”的imageView加上如下AutoresizingMask
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-a72576207ebe4447.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;给”阴天”的imageView加上如下的AutoresizingMask&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-c17df0eec79dd816.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后给我们的中间的Label加上AutoresizingMask&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-d8df43f7952321be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个时候我们旋转一下屏幕，一切正常，View的排版都如我们所愿。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-4df96205a8480096.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个时候我们再选择一下，3：2分屏，这个时候就出现了不对的情况了。Label的Width被挤压了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-55bf242088854780.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;原因是因为Autoresizing masks并不会向Autolayout一样，会考虑View的content，所以这里被挤压了。&lt;/p&gt;

&lt;p&gt;想fix这个Label，我们可以很容易的添加一个constraints来修复。不过这里我们来谈谈另外一种做法。&lt;/p&gt;

&lt;p&gt;进入到Attributes Inspector面板，找到Autoshrink属性，把“fixed font size”切换成“minimum font size”&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-79b7038d7df03eb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个时候就fix上述的问题了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-d140165f6ca54036.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此时就算是回到landscape，分屏的情况下，已经可以显示正常。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-02e1709fd25a60e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接着我们再来处理一下中间的温度的Label。这个时候我们有比较复杂的需求。这个时候我们就需要用到constraint了。&lt;/p&gt;

&lt;p&gt;这个时候我们按时control键，然后拖到父View上，释放，会弹出菜单。我们再按住shift，这样我们可以一次性选择多个constraints。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-793f4205c747a333.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-95aab84ae9baace3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们一次性选择“Center Horizontally in Container” 和 “Center Vertically in Container”。注意这个时候右边还是AutoresizingMask的面板，因为这个时候Label还没有任何的constraint。当我们点击“Add Constraints”的时候，就给Label加上了约束，右边的面板也变成了constraints面板了。&lt;/p&gt;

&lt;p&gt;我们再给这个Label继续加2个constraints。“Horizontal Spacing”和“Baseline”。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-48e850a152987d86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;同样的，从Label拖拽到“太阳”的那个imageView上，再添加“Horizontal Spacing”和“Baseline”约束。&lt;/p&gt;

&lt;p&gt;这个时候我们更新一下frame。如下图所示，选择“Update Frames”，这个时候所有的frame就都完成了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-23546d448e5c177d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-04a9232b13c71d6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个时候我们更新一下中间温度的Label的字体大小，这时候计算变大，由于我们的constraints都是正确的，两边的View也会随着Label字体变大而变大。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-3da0a819491ff184.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Xocde 8在这个时候就变得更加智能了，会立即自动更新frame。&lt;/p&gt;

&lt;p&gt;我们在继续给晴天的上海加上一个背景图。添加一个imageView，然后大小铺满整个父View，把mode 选择成“Aspect Fill”&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-7639cec83cd526d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接下面一般的做法就是在这个imageView上面添加constraints，来使这个View和父View大小一样。但是这种简单的resize的行为在Xocde 8里面就不需要再添加Constraint了，这里我们改用Autoresizing masks来实现。给imageView添加一下这些mask。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-badadb886e9ff91e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们把imageView放到背景去。这时，我们所有的界面就布局完成了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-4917418adeac2aec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;测试一下横屏的效果
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-9c3f8c4a5c4db2b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;甚至分屏的一样可以完成任务！
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-29ed778b3ce5e7aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/halfrost/Xcode8AutolayoutDemo&quot;&gt;Demo的Github地址&lt;/a&gt;，这个demo没啥难的，就是看看效果。&lt;/p&gt;

&lt;p&gt;这就是Xcode 8 的Incrementally Adopting Auto Layout，Autoresizing masks + Auto Layout Constraint 一起协同工作！&lt;/p&gt;

&lt;h4 id=&quot;design-and-runtime-constraints&quot;&gt;二.Design and Runtime Constraints&lt;/h4&gt;

&lt;p&gt;在我们开发过程中有这样一种情况，View的constraints会依据你所加载的数据来添加的。所以在app运行之前，我们是无法知道所有的constraints的。&lt;/p&gt;

&lt;p&gt;这里有3种方法可以对应以上的情况。&lt;/p&gt;

&lt;h5 id=&quot;placeholder-constraints&quot;&gt;1.Placeholder Constraints&lt;/h5&gt;

&lt;p&gt;假设现在我们需要把一张图片放在View的垂直和水平的中间，并且距离左边的边缘有一个leading margin。并且还需要保持其长宽的比例。而这种图片的最终样子，我们并不知道。只有到运行时，我们才能知道这样图片的样子。&lt;/p&gt;

&lt;p&gt;为了能在Interface Builder看到我们的图片，我们要先预估一下图片的长宽比例。假设我们估计为4：3。这时候就给图片加上constraints，并且勾上“place order constraint”，这个约束会在build time的时候被移除。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-ed8c011d75371e39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当我们在运行时拿到图片之后，这个是时候我们再给它加上适当的约束和长宽比例即可。&lt;/p&gt;

&lt;h5 id=&quot;intrinsic-content-size&quot;&gt;2.Intrinsic Content Size&lt;/h5&gt;

&lt;p&gt;还是类似上面那种场景，我们有时候会自定义一些UIView或者NSView，这些View里面的content是动态的。Interface Builder并不会运行我们的代码，所以不到app运行的时候我们并不知道里面的大小。我们可以给它设置一个内在的content的大小。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-5f22d602933155e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Setting a design time intrinsic content size only affects a view while editing in Interface Builder.The view will not have this intrinsic content size at runtime.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;注意一下上面的说明intrinsic content size仅仅相当于是在布局的时候一个placeholder，在运行时这个size就没有了。所以如果开发过程中真的需要用到这个内在的content的大小，那么我们需要overriding的content size&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;override var intrinsicContentSize: CGSize  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;turn-off-ambiguity-per-view&quot;&gt;3.Turn Off Ambiguity Per View&lt;/h5&gt;

&lt;p&gt;这个是Xcode 8的一个新特性。当上述2种方法都无法解决我们的需求的时候。这个时候就需要用到这种方法了。Xcode 8给了我们可以在constraints产生歧义的时候，可以动态调整警告级别的能力。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-4f433ddf72781326.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在这个场景中，我们仅仅只知道我们需要把这个imageView放在水平位置的中央，但是imageView的大小和它的水平位置我们并不知道。如果我们仅仅只加上了这一个约束的话，Interface Builder就会报红，因为IB这时候根据我们给的constraints，并不能唯一确定当前的view的位置。&lt;/p&gt;

&lt;p&gt;如果我们在之后的运行时，拿到图片的完整信息之后，我们自己知道该如何去加constraints，我们知道该如何去排版保证imageView能唯一确定位置的时候，这时我们可以关掉IB的红色警告。找到“Ambiguous”，这里是警告的级别，我们这里选择“Never Verify”，这时就没有红色的警告和错误提醒了。但是选择这一项的前提是，我们能保证之后运行时我们可以加上足够的constraints保证view的位置信息完整。&lt;/p&gt;

&lt;p&gt;以上3种方法就是我们在运行时给view增加constraints的解决办法。&lt;/p&gt;

&lt;h4 id=&quot;nsgridview&quot;&gt;三.NSGridView&lt;/h4&gt;

&lt;p&gt;这是macOS给我们带来的一个新的layout容器。&lt;/p&gt;

&lt;p&gt;有时候我们为了维护constraints的正确性是件比较麻烦的事情，比如即使我们就是一组简单的checkboxes，维护constraints也不容易。这个时候我们会选择用stack view来让我们开发更容易一些。&lt;/p&gt;

&lt;p&gt;下图是macOS的app常见到的一组checkboxes。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-9cc9080a7861603d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这时候我们选用NS/UIStackView来实现，因为它有以下的优点，它可以排列一组items，重要的是它可以处理好content size并且可以控制好每个item之间的spacing。&lt;/p&gt;

&lt;p&gt;但是stack view依旧有一些场景无法很顺手的处理。例如下图的场景。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-e7c6eb85adbd76db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这时依旧可以用stack view来实现，但是它不能帮我们根据content完成行和列的对齐。&lt;/p&gt;

&lt;p&gt;这就是为什么要引入新的NSGridView的原因。&lt;/p&gt;

&lt;p&gt;使用NSGridView，我们可以很容易的做到content在X轴和Y轴上的对齐。仅仅只需要我们把content放进预先定义好的网格中即可，NSGridView会帮我们管理好接下来对齐的一切事情。&lt;/p&gt;

&lt;p&gt;我们来看看下面的例子。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-a7194363c60b4d99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;NSGridView有2个子类，NSGridRow 和 NSGridColumn，它们俩会自动的管理好content的大小。当然我们可以在需要的时候指定size的大小，padding和spacing的大小。我们也可以动态的隐藏一些rows行和colunms列。&lt;/p&gt;

&lt;p&gt;NSGridCell的工作就是管理每个cell里面content view的layout。如果某个cell的内容超出cell的边界，cell会合并起来，就像普通的电子表格app的做法一样。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-0240de67714b42b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们来构建一个简单的界面。设计图如下：
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-ef33742918f3879a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们并不需要去关心网格的sizing，我们只用关心每一行每一列究竟有多少个content需要被显示出来。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let empty = NSGridCell.emptyContentView  
let gridView = NSGridView(views: [
 [brailleTranslationLabel, brailleTranslationPopup], 
 [empty, showContractedCheckbox], 
 [empty, showEightDotCheckbox], 
 [statusCellsLabel, showGeneralDisplayCB],
 [empty, textStyleCB], 
 [showAlertCB] 
])
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;用上述代码运行出来的界面是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-a561bbdcb0ff07c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;虽然我们调用构造函数没错，但是出来的界面和设计的明显有一些差距。最明显的问题就是UI被拉开了，有很多空白的地方。&lt;/p&gt;

&lt;p&gt;产生问题的原因就在于，网格被约束到了window的边缘。我们的意图应该是window来匹配我们的网格大小，但是现在出现的问题变成了，网格被拉伸了，去匹配window的大小了。&lt;/p&gt;

&lt;p&gt;我们解决这个问题的办法就是去改变 grid view内容的hugging的优先级。尽管页面上的constraints已经具有了高优先级，但是我们现在仍可以继续提高优先级，来让constraints推动content，使其远离window的边缘。我们提高一些优先级：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gridView.setContentHuggingPriority(600, for: .horizontal)
gridView.setContentHuggingPriority(600, for: .vertical)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-a1dd15524cd1dcf0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们会发现，window里面的content更加聚合了，中间的大段空白消失了。&lt;/p&gt;

&lt;p&gt;我们再来解决一下window中间的空白，左边的label和右边的content距离太远。根据设计，我们应该让label居右排列。这件事很容易，只要我们调整一下cell的位置信息即可完成。排列的位置信息会影响到cell，行，列，网格视图。&lt;/p&gt;

&lt;p&gt;如果没有指定cell的placement这个属性值，那么行列就会根据gridview的placement属性值来确定。这个规则可以使我们在一处设定好placement，瞬间可以改变大量的cell的布局。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//first column needs to be right-justified:
gridView.column(at: 0).xPlacement = .trailing
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;我们找到gridView的第一列，改变它的xPlacement属性值，这样一列的cell都会变成居右排列。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-1225a9d45ea39661.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;居右之后，我们又会出现新的问题，baseline不对齐了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-74949bdfced19d16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;行的对齐和列的对齐原理一样的，同理，我们只需要设置一处，将会影响整个网格视图。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// all cells use firstBaseline alignment
gridView.rowAlignment = .firstBaseline
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-a61900a27d2bd610.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;设置完成之后，整个网格视图就对齐了。&lt;/p&gt;

&lt;p&gt;接下来我们再来改变一下pop-up button的边距。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-3201fb8701df1ed6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let row = gridView.cell(for: brailleTranslationPopup)!.row!
row.topPadding = 5
row.bottomPadding = 5
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里取第一行的做法也可以和之前取第一列的做法一样，直接取下标0的row即可。这里换一种更好的做法来做。在gridView里面找到包含pop-up button的cell，根据cell找到对应的row行。这种方式比直接去下标index的好处在于，日后如果有人在index 0的位置又增加了一行，那么代码就出错了，而我们这里的代码一直都不会出错，因为保证是取出了包含pop-up button的cell。所以代码里面尽量不要写死固定的index，这样以后维护起来比较困难。&lt;/p&gt;

&lt;p&gt;同理，我们也给“status cells”也一起加上Padding&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ridView.cell(for:statusCellsLabel)!.row!.topPadding = 6
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里需要对比一下padding 和 spacing的区别。&lt;/p&gt;

&lt;p&gt;padding是针对每个行或者每个列之间的间距，我们可以增加padding来改变两两之间的间距。
spacing是针对整个gridview来说的，改变了它，将会影响整个网格视图的布局。&lt;/p&gt;

&lt;p&gt;再来看看我们的设计图：
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-ef33742918f3879a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果没有padding那么就是下图的样子：
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-a44097139cef38b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果没有spacing那么就会出现下图的样子：
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-559a56f9aa2f175e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果spacing和padding都没有的话，那就都挤在一起了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-13509a34450af8b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后我们来处理一下最下面那一行包含checkbox的cell&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-73c75d29bd25b172.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里就需要用到之前提到了，合并2个cell了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Special treatment for centered checkbox:
let cell = gridView.cell(for: showAlertCB)!
cell.row!.topPadding = 4
cell.row!.mergeCells(in: NSMakeRange(0, 2))
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里我们直接指出了，合并前2个cell。&lt;/p&gt;

&lt;p&gt;执行完代码之后，就会是这个样子。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-b181efe7718f5ae4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后一行的cell就会横跨2个cell的位置。虽然占了2个cell的位置，但是它依旧还继承着第一列的居右的排列规则。&lt;/p&gt;

&lt;p&gt;现在我们的需求是既不希望它居右，也不希望它居左。
checkbox其实是支持排列在2个列之间的，但是由于这相邻的2个列的宽度并不相等，所以gridview不知道该怎么排列了。这时就需要我们手动来改变布局了。&lt;/p&gt;

&lt;p&gt;这里可能有人会想，直接把&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cell.xPlacement = .none
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;把cell的xPlacement直接变成none，这样做会一下子打乱整个gridview的constraints布局，我们不能这样做。我们需要再继续给cell加上额外的constraints来维护整个gridview的constraints的平衡。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cell.xPlacement = .none
let centering = showAlertCB.centerXAnchor.constraint(equalTo: textStyleCB.leadingAnchor)
cell.customPlacementConstraints = [centering]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;我们只需要在给出checkbox在x轴方面的锚点即可。这时候checkbox就会排列成我们想要的样子了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-6d6d0fdb84291a2d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;至此，我们就完成了需求。总结一下，NSGridView是一个新的控件，能很好的帮助我们进行网格似布局。它能很快很方便的把我们需要展示的content排列整齐。之后我们仅仅只需要调整一下padding和spacing这些信息即可。&lt;/p&gt;

&lt;h4 id=&quot;layout-feedback-loop-debugging&quot;&gt;四.Layout Feedback Loop Debugging&lt;/h4&gt;

&lt;p&gt;有时候我们设置好了constraint之后，没有报任何错误，但是有些情况当我们运行起来的时候就有一堆constraint冲突在debug窗口里面，严重的还会使app直接崩溃。崩溃的情况就是遇到了layout feedback loop。&lt;/p&gt;

&lt;p&gt;遇到这种情况，往往是发生在“过渡期”，开始或者结束的时候。如果说你点击了一个button，button相应了你的点击，但是之后button不弹起，一直保持着被按下的状态。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-c7f7e77d4a5642a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后会观察到CPU使用率爆表，内存倍增，然后app就崩溃了，与此同时返回了一大堆的layout的栈回溯信息。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-614c97ca5d350293.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;发生这个情况的原因是某个view的layout被一直执行，一直执行，陷入了死循环中。Runloop就不会停下，CPU的使用率会一直处于峰值。所有的消息都会被收集到自动释放的对象中去，消息一直发送，就会一直收集。所以内存也会倍增。&lt;/p&gt;

&lt;p&gt;导致这个原因之一，是setNeedsLayout这个方法。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-775542406d024aca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当其中一个view调用完setNeedsLayout之后，会传递到父视图继续调用setNeedsLayout，父视图的setNeedsLayout可能又会调用到其他视图的layout信息。如果我们能在这相互之后调用找到调用者，也就是那个view调用了这个方法，那我们就可以分析清楚这些setNeedsLayout从哪里来，到哪里去，就能找到死循环的地方了。&lt;/p&gt;

&lt;p&gt;这些信息确实很难收集，这也是为何苹果要为我们专门开发这样一个工具，方便我们来调试，查找问题的原因。&lt;/p&gt;

&lt;p&gt;开启这个工具的开关在“Arguments”选项里面。如下图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-a46ee65eca84ff69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-UIViewLayoutFeedbackLoopDebuggingThreshold 100 // 50...1000
-NSViewLayoutFeedbackLoopDebuggingThreshold 100 // 50...1000
// Logs to com.apple.UIKit:LayoutLoop or com.apple.AppKit:LayoutLoop
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;UIView是在iOS里面使用的，NSView是在macOS里面使用的。一旦我们开启了这个开关，那么layout feedback loop debugger就会开始记录每一个调用了setNeedsLayout的信息。&lt;/p&gt;

&lt;p&gt;这里我给它设置了阀值是100。&lt;/p&gt;

&lt;p&gt;如果发现在一个Runloop中，layout在一个view上面调用的次数超过了阀值，这里设置的是100，也就是说次数超过100，这个死循环还会在跑一小段，因为这个时候要给debugger一个记录信息的时间。当记录完成之后，就会立即抛出异常。并且信息会显示在logs中。log会被记录在com.apple.UIKit:LayoutLoop(iOS)/com.apple.AppKit:LayoutLoop(macOS)中&lt;/p&gt;

&lt;p&gt;我们也可以打全局的异常断点exception break point。
在调试窗口也可以用LLDB命令po出一些调试信息。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-a83832771675c027.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接下来看2个实用的例子。&lt;/p&gt;

&lt;h5 id=&quot;upstream-geometry-change&quot;&gt;1.Upstream Geometry Change&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-68dca9ff105c7c61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里有这么多个view，层级如上图。&lt;/p&gt;

&lt;p&gt;现在右子串上面10个子view在一次的层级变化中，被移除了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-4014b85c072a588b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;那么最上层圈起来的3个view都会被影响。&lt;del&gt;于是这3个view的bounds就发生了变化。于是就会隐式的调用setNeedsLayout，来获取新的bounds的信息。&lt;/del&gt;&lt;strong&gt;(这里经过@kuailejim @冬瓜争做全栈瓜 和大神们实验，setNeedsLayout是需要我们开发者手动调用的，系统并不会在bounds改变的时候隐式调用setNeedsLayout方法)&lt;/strong&gt;。当前view的bounds改变，但是如果父view没有layout完成，那么父view也会继续收到setNeedsLayout消息。这个消息就会一直被往上传递，直到传到最顶层的view，顶层的view layout完成之后，将会重置下面关联的view的bounds，调用layoutSubview()方法。这时候，死循环就产生了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-8a4946f8c09e222c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;
&lt;del&gt;这3个view就是上面3个view，下面的view需要setNeedsLayout，需要获取最新的bounds信息，中间蓝色的view也同样需要setNeedsLayout，于是又会让上层的view调用setNeedsLayout()方法，这个时候死循环就产生了。上下各有2个环，共同的view就是中间蓝色的view。环内的view都在相互的请求setNeedsLayout()，并且在自己layout完成以后又会去重置关联的view的bounds。这就形成了triggers layout。&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;大家对这里产生2个环产生了极大的好奇，热烈讨论这里会产生环的情况。目前可以想到会产生环的场景是这样子的:在上面的3颗子树，当某种场景下，突然删掉了右边的子树，假设用户的屏幕现在是全屏，由于一下子突然删掉了一堆view，那么原来那里就会变成空白，这个时候开发者想要把其他的view平铺到屏幕上。这个时候就需要改变上面父view的bounds，最下面的view会代码里面手动调用上面蓝色的view，setNeedsLayout()方法，并且把蓝色view的bounds设置成全屏，由于蓝色view的bounds改变，这个时候开发者代码里面又手动调用了蓝色view的父view，去执行setNeedsLayout()方法。top view代码里面又写了bounds = origRect，这时候就触发了蓝色view的layout，更新bounds。这样就产生了循环。同理下面也会形成循环。这样就产生了2个死循环了。&lt;strong&gt;这些总结需要感谢@kuailejim @冬瓜争做全栈瓜 给出的指点。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-71863fde64ba8227.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里是我们用工具收集到的log，第一行就是top-level view，接下来的就是递归的过程。往下看，我们会看见一些数字，这些数字就是view接到layout的次数，并且这些数字是有序的。一次死循环中这些数字就是循环时候的顺序。当然一个循环中，每个view可以是起点也可以是终点。这里我们默认把top view设置成起点。这样就可以向我们展示出死循环中一共牵扯进来了多少个view。&lt;/p&gt;

&lt;p&gt;从log上看，上面有3个view，下面有10个view，加起来也不等于23，这是为什么呢？我们继续往下看log，来看看“Views receiving layout in order”这里面记录了些什么吧。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-333285494519f9d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里我们可以很明显的看到，view接收到layout的顺序，一共正好23个。也可以看出，在一起循环中，一个view接收到layout的次数不止一次。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-1a2647a8c347ad9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如上图所标示的，有2段在循环，有10个view接收到layout之后，再是2个view，紧接着又是10个view，再是1个view。&lt;/p&gt;

&lt;p&gt;回到最初我们使用这个工具的用途上来，最初我们使用这个工具是用来查看 top-level view 接收到setNeedsLayout消息到底从哪里来。继续往下查找，找到调用的栈信息那里。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-b10dc1deecd2a7e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;
从上往下看，前几行肯定都是UIViewLayoutFeedbackLoopDebugging的信息。往下看，看到第6行，可以看到DropShadowView接受到了信息，准备setBounds。回看之前的层级信息，我们会发现DropShadowView是TransitionView的子view。&lt;/p&gt;

&lt;p&gt;引起DropShadowView触发setBounds的唯一途径是，它的父view，TransitionView触发了setNeedsLayout()方法。因为这个时候TransitionView还没有layout。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-415e97e9fcf8b94f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;
回到“geometry change records”,这个时候我们可以看到选中的这3行信息在一遍遍的循环。看第2行和第3行，我们可以看到是来自于TransitionView的layout。这时是合理的。再看第一行，会发现这个时候有一个TransitionView的子view调用了viewLayoutSubviews。&lt;/p&gt;

&lt;p&gt;这个时候我们就定位到了bug的根源了，只要想方设法在layout的时候，不要改变superview的bounds即可以去掉这个死循环。&lt;/p&gt;

&lt;h5 id=&quot;ambiguous-layout-from-constraints&quot;&gt;2.Ambiguous Layout From Constraints&lt;/h5&gt;

&lt;p&gt;在我们设置constraints约束的时候，常常会产生一些歧义的constraints。歧义的constraints通常不可怕，我们只需要稍稍做些调整，然后update all frame即可。&lt;/p&gt;

&lt;p&gt;但是有如下的场景会导出形成环：&lt;/p&gt;

&lt;p&gt;当你的view在旋转之后，constraints也随之变化，然后有些view在旋转之后的constraint就会相互冲突。因次有些constraint就形成了环。&lt;/p&gt;

&lt;p&gt;这个问题在没有这个debugger工具的时候，思考起来很烧脑，没有任何头绪，这也是为什么log把top-level view放在第一行的原因，给我们暗示，从这里开始找bug的原因。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-bd525917ccd858da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;
在log，我们会看到好多的“Ambiguous Layout”。注意：tAMIC是Translates Auto Resizing Mask into Constraints的缩写。&lt;/p&gt;

&lt;p&gt;我们来看看详细的log。看log之前，我们应该知道，constraint虽然冲突很多，但是可能引起冲突的constraint只有一个，也就是说当我们更正了其中一个constraint，很可能所有的冲突都解决了。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-2cc7f461bc91b5e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;
如上图log所示，在minX这里我们设置了2个带有冲突性的constraint，一个是-60，一个是-120。我们可以一个个的检查约束，但是这个列表很长，检查起来也比较麻烦。&lt;/p&gt;

&lt;p&gt;那我们画图来分析一下这个问题。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-be202345d46bf519.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如图，label有leading和trailing padding，label是container的子view，container是action的子父，action是representation的子view。container和action view之间有一个居中的centering constraint。action view在representation view上有一个autoresizing mask constraints。&lt;/p&gt;

&lt;p&gt;然后每个representation view之间是alignment对齐的。自此看来，这些view并没有足够的constraints能让这些view都能确定位置信息。比如在X轴上，这一串view是可以存在在任何的位置，所以产生了歧义的constraint。&lt;/p&gt;

&lt;p&gt;解决上面的歧义的&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-UIViewLayoutFeedbackLoopDebuggingThreshold 100 // 50...1000
-NSViewLayoutFeedbackLoopDebuggingThreshold 100 // 50...1000
 //Logs to com.apple.UIKit:LayoutLoop or com.apple.AppKit:LayoutLoop
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;用debugger就可以解决上述的问题。&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;这个Xcode 8 给我们的Autolayout融合了之前Autoresizing masks的用法，使两个合并在一起使用，这样不同场景我们可以有更多的选择，可以更加灵活的处理布局的问题。还允许我们能手动调节constraints警告优先级别。&lt;/p&gt;

&lt;p&gt;针对macOS的布局问题，又给我们带来了新的控件NSGridView&lt;/p&gt;

&lt;p&gt;最后给我们带来的新的调试Layout Feedback Loop Debugging的工具，能让我们平时调试起来比较头疼的问题，有了工具可以有据可循，迅速定位问题，查找问题。&lt;/p&gt;

&lt;p&gt;最后，请大家多多指教。&lt;/p&gt;
</description>
        <pubDate>Sun, 17 Jul 2016 19:36:02+0800</pubDate>
        <link>http://vno.onevcat.com/2016/07/WWDC2016-Session%E7%AC%94%E8%AE%B0-Xcode-8-Auto-Layout%E6%96%B0%E7%89%B9%E6%80%A7/</link>
        <guid isPermaLink="true">http://vno.onevcat.com/2016/07/WWDC2016-Session%E7%AC%94%E8%AE%B0-Xcode-8-Auto-Layout%E6%96%B0%E7%89%B9%E6%80%A7/</guid>
        
        <category>iOS</category>
        
        
        <category>Blog</category>
        
      </item>
    
      <item>
        <title>函数响应式编程(FRP)从入门到&quot;放弃&quot;——基础概念篇</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-903db38916fcf0cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;前言&lt;/h4&gt;
&lt;p&gt;研究ReactiveCocoa一段时间了，是时候总结一下学到的一些知识了。&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;一.函数响应式编程&lt;/h4&gt;
&lt;p&gt;说道函数响应式编程，就不得不提到函数式编程，它们俩到底有什么关系呢？今天我们就详细的解析一下他们的关系。&lt;/p&gt;

&lt;p&gt;现在有下面4个概念，需要我们理清一下它们之间的关系：
面向对象编程 Object Oriented Programming
响应式编程  Reactive Programming
函数式编程 Functional Programming
函数响应式编程 Functional Reactive Programming&lt;/p&gt;

&lt;p&gt;我们先来说说什么是函数式编程Functional Programming，我们先来看看&lt;a href=&quot;https://en.wikipedia.org/wiki/Functional_programming&quot;&gt;wikipedia&lt;/a&gt;上的相关定义：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Functional Programming is a programming paradigm &lt;br /&gt;
1. treats computation as the evaluation of  mathematical functions.
2. avoids changing-state and mutable data&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;总结一下函数式编程具有以下几个特点：
1. 函数是”第一等公民”&lt;br /&gt;
2. 闭包和高阶函数
3. 不改变状态(由此延伸出”引用透明”的概念) 
4. 递归
5. 只用”表达式”，不用”语句”，没有副作用&lt;/p&gt;

&lt;p&gt;接下来我们依次说明一下这些特点。
##### 一.  函数是”第一等公民” &lt;br /&gt;
所谓”第一等公民”（first class），指的是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。&lt;/p&gt;

&lt;p&gt;一等函数的理念可以追溯到 Church 的 lambda 演算 (Church 1941; Barendregt 1984)。此后，包括 Haskell，OCaml，Standard ML，Scala 和 F# 在内的大量 (函数式) 编程语言都不同程度地借鉴了这个概念。&lt;/p&gt;

&lt;p&gt;Ps：世界上最纯粹的函数式编程语言非Haskell莫属。&lt;/p&gt;

&lt;h5 id=&quot;section-2&quot;&gt;二.闭包和高阶函数&lt;/h5&gt;
&lt;p&gt;闭包是起函数的作用并可以像对象一样操作的对象。与此类似，函数式编程语言支持高阶函数。高阶函数可以用另一个函数（间接地，用一个表达式） 作为其输入参数，在大多数情况下，它甚至返回一个函数作为其输出参数。这两种结构结合在一起使得可以用优雅的方式进行模块化编程，这是使用函数式编程的最大好处。&lt;/p&gt;

&lt;h5 id=&quot;section-3&quot;&gt;三. 不改变状态(由此延伸出”引用透明”的概念)&lt;/h5&gt;

&lt;p&gt;不改变状态：
函数式编程只是返回新的值，不修改系统变量。因此，不修改变量，也是它的一个重要特点。在其他类型的语言中，变量往往用来保存”状态”（state）。不修改变量，意味着状态不能保存在变量中。函数式编程使用参数保存状态，最好的例子就是递归。&lt;/p&gt;

&lt;p&gt;避免使用程序状态和可变对象，是降低程序复杂度的有效方式之一，而这也正是函数式编程的精髓。函数式编程强调执行的结果，而非执行的过程。我们先构建一系列简单却具有一定功能的小函数，然后再将这些函数进行组装以实现完整的逻辑和复杂的运算，这是函数式编程的基本思想。&lt;/p&gt;

&lt;p&gt;引用透明： 
如果提供同样的输入，那么函数总是返回同样的结果。就是说，表达式的值不依赖于可以改变值的全局状态。这使您可以从形式上推断程序行为，因为表达式的意义只取决于其子表达式而不是计算顺序或者其他表达式的副作用。&lt;/p&gt;

&lt;p&gt;这里有出现了一个问题：&lt;/p&gt;

&lt;p&gt;面试题:** 纯函数式的闭包是否满足函数式编程里面不改变函数状态的特性？**&lt;/p&gt;

&lt;p&gt;根据&lt;a href=&quot;http://en.wikipedia.org/wiki/Pure_function&quot;&gt;纯函数&lt;/a&gt;的定义
&amp;gt; 在计算机编程中，假如满足下面这两个句子的约束，一个函数可能被描述为一个纯函数：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;给出同样的参数值，该函数总是求出同样的结果。该函数结果值不依赖任何隐藏信息或程序执行处理可能改变的状态或在程序的两个不同的执行，也不能依赖来自I/O装置的任何外部的输入（通常是这样的–看下面的描述）。&lt;/li&gt;
    &lt;li&gt;结果的求值不会促使任何可语义上可观察的副作用或输出，例如易变对象的变化或输出到I/O装置。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;函数的返回值是不需要依赖所有（或任何）参数值，必须不依赖参数值以外的东西。函数可能返回多重结果值，并且对于被认为是纯函数的函数，这些条件必须应用到所有返回值。假如一个参数通过引用调用，任何内部参数变化将改变函数外部的输入参数值，它将使函数变为非纯函数。&lt;/p&gt;

&lt;p&gt;回到我们讨论的这个问题上来:&lt;/p&gt;

&lt;p&gt;闭包虽然可以把闭包外部的变量捕获到闭包内部，但是闭包还是满足不改变状态的特性的。假设f(x)的返回值是g(x)，而g(x)是会依靠f(x)的参数返回的,g(x)相当于拥有f(x)的闭包。这个时候就会有一种错误的感觉，g(x)捕捉了f(x)入参的变量，从而产生了不同的闭包。从而得出g(x)不是纯函数式的，因为它改变了状态。如果我们站在更高的层面去看待这个问题，函数在函数式编程里面是一等值，和结构体，整型，布尔类型没有区别。回到上述的问题中来，由于我们传入了不同参数，但是闭包里面的整体算法是没有变化的。更加详细的例子，f(x)返回一个计算x平方的函数g(x)，g(x)虽然每次都会由f(x)传入的x值变化而变化，但是g(x)整体算法就是计算x的平方，这个计算方法是没有变化的，不根据外部状态改变而改变的。那么这个g(x)的block是满足函数式编程的不改变函数状态的特性的。所以它也是引用透明的。&lt;/p&gt;

&lt;p&gt;额外需要说明的一点，__block这个关键字其实是破坏了函数式编程的。&lt;/p&gt;

&lt;p&gt;面试题:&lt;strong&gt;如何理解引用透明？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果一个函数只会受到入参的变化，那么这个函数每次的调用都会是相同的
一个函数f(x),里面调用了g(x),g(x)里面又调用了h(x),h(x)最终计算出了结果，作为f(x)的返回值返回了。如果所有的状态都没有改变，f(x)下一次再调用相同的参数的时候，应该会得到完全一样的结果,那这个时候其实不用再调用g(x)和h(x)了，也可以得到完全一样的结果。当一个函数，不依赖“外部”变量和状态，只依赖入参的变化而影响函数最终返回值，也就是说入参相同，得到的返回值结果一定相同，如果函数具有这种性质，就可以说这个函数是引用透明的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef int(^intFx)(int a);

intFx transparent(intFx origin) {
    NSMutableDictionary *results = [NSMutableDictionary dictionary];
    return ^int(int p) {
        if (results[@(p)]) {
            return [results[@(p)] intValue];
        }
        results[@(p)] = @(origin(p));
        return [results[@(p)] intValue];
    };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;在上述例子中可以看到，如果result里面有我们需要的值了，我们就不会再去调用回调的闭包，这样transparent的函数每次传入相同的值，肯定会返回相同的结果。&lt;/p&gt;

&lt;p&gt;一个纯函数在执行的过程中，只跟入参有关，在函数体中并不会引用外部全局变量，或者说是一个类方法里面的其他成员变量。另外，纯函数除了返回值之外，也不会去改变外部的变量值。满足上面这两点的纯函数，就可以说它是引用透明的。也有说法叫这种特性为&lt;strong&gt;幂等性&lt;/strong&gt;&lt;/p&gt;

&lt;h5 id=&quot;section-4&quot;&gt;四.递归&lt;/h5&gt;
&lt;p&gt;函数式编程是用递归做为控制流程的机制。&lt;/p&gt;

&lt;h5 id=&quot;section-5&quot;&gt;五.只用”表达式”，不用”语句”，没有副作用&lt;/h5&gt;

&lt;p&gt;“表达式”（expression）是一个单纯的运算过程，总是有返回值；”语句”（statement）是执行某种操作，没有返回值。函数式编程要求，只使用表达式，不使用语句。也就是说，每一步都是单纯的运算，而且都有返回值。
原因是函数式编程的开发动机，一开始就是为了处理运算（computation），不考虑系统的读写（I/O）。”语句”属于读写操作，所以就被排斥在外。 
函数式编程强调没有”副作用”，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。&lt;/p&gt;

&lt;p&gt;举个例子来说明一下函数式编程和指令式编程的区别：
```&lt;/p&gt;

&lt;p&gt;// 指令式编程
int factorial1(int x) {
    int result = 1;
    for (int i = 1; i &amp;lt;= x; i ++) {
        result *= i;
    }
    return result;
}&lt;/p&gt;

&lt;p&gt;// 函数式编程
int factorial2(int x) {
    if (x == 1) return 1;
    return x * factorial2(x - 1);
}&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;上面这个例子就是计算阶乘的例子。我们先来看看指令式编程。指令式编程，像机器一条条命令一样思考问题。指令式的思想就类似于汇编，一条条指令告诉计算机该怎么去处理这个问题。所以在指令式编程里面就有很多的**状态量**和**语句**。而在函数式编程里面，思想是利用数学方法来思考问题。阶乘在数学定义里面就是f(n) = n _*_ f(n - 1) (n &amp;gt; 1),f(n) = 1(n = 1)。在函数式编程里面是基本上没有**状态量**，只有**表达式**，也没有赋值语句。利用了递归解决了问题。

再来看看指令式编程和响应式编程的区别
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;void test() {
    int a = 5;
    int b = 8;
    int c = a + b;
    a = 10;
    NSLog(@”%d”,c);
}
```&lt;br /&gt;
在指令式编程里面，计算是一种瞬间的操作。而响应式编程，计算是相互相应的，相互之间都存在关系，某些变化了，相互之间的关系会使相应的值随之变化。响应式编程有2个典型的例子：Excel，当单元格变化了，相互之间的单元格也会立即变化。Autolayout，当父View变化了，根据相互之间的关系Constraint，子View的frame也会随之变化。&lt;/p&gt;

&lt;p&gt;在面向对象语言中也是可以实现响应式编程的，具体做法应该是，把关系抽象出来，然后把变化抽象出来，用关系把变化事件传递下去。Cocoa框架下RAC的实现就是如此。&lt;/p&gt;

&lt;p&gt;最后再来说说函数响应式编程。
首先函数响应式编程肯定是满足函数式编程的上述特性的。函数响应式编程是面向离散事件流的，在一个时间轴上会产生一些离散事件，这些事件会依次向下传递。&lt;/p&gt;

&lt;p&gt;RAC就是Cocoa框架下的函数响应式编程的实现。它提供了基于时间变化的数据流的组合和变化。&lt;/p&gt;

&lt;p&gt;接着再来说说之前说的4种编程范式，总结出来，如果按照类似继承图谱来看的话，应该如下图：
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-92e858ac89ee627f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;首先在声明式编程里面有2大家族，那就是函数式编程和数据流编程，数据流编程下面就是响应式编程，而函数响应式编程是”继承”于函数式编程和响应式编程的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-b7b30d442802c2d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;面向对象编程就属于指令式编程的范畴。从上面2张图来看，我们可以很明显看出这4者是什么关系了。&lt;/p&gt;

&lt;p&gt;面试题:&lt;strong&gt;函数式编程是面向对象编程的升级产品&lt;/strong&gt;&lt;br /&gt;
由上面的说明来看，这个说法肯定是错误的，关系根据上面2图来看就很明显了。&lt;/p&gt;

&lt;p&gt;面试题:&lt;strong&gt;函数式语言主张不变量的原因是什么？&lt;/strong&gt;  &lt;br /&gt;
1. 函数保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不修改外部变量的值。由于这一主张，我们不需要考虑线程”死锁”问题，线程之间一定是安全的，因为它不修改变量，所以根本不存在”锁”线程的问题。&lt;br /&gt;
2. 进一步，函数式语言更加趋向于数学公式的推导，在数学公式里面其实是完全不存在变量这一概念的，此时如果又不存在变量了，那整个程序的执行顺序其实就不必要了，这样可以使我们更加容易的进行并发编程，更加有效率的利用多核cpu的计算处理能力。&lt;/p&gt;

&lt;h4 id=&quot;section-6&quot;&gt;二.链式调用&lt;/h4&gt;
&lt;p&gt;定义：f(x)，表示的是一种态射，从x的定义域到f(x)值域的态射。如果定义域和值域是完全相同的话，这种映射也成为单元态射。那么满足单元态射的函数，就可以进行链式调用。&lt;/p&gt;

&lt;p&gt;以RAC为例，把RACSignal链式传递下去，subscribeNext就会返回一个RACSignal，定义域和值域都是RACSignal，那么就满足了单元态射的要求，就可以链式调用下去。&lt;/p&gt;

&lt;p&gt;面试题:&lt;strong&gt;组成链式调用的必要条件就是在方法里面返回对象自己&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个说法是错误，举个例子：RAC每次做信号变换的时候，都产生了一个新的信号，所以返回自己就并不是必要条件。其实如果返回自己的同类或者和自己类似的类型，里面也包含可以继续链式调用的方法，也是可以组成链式调用的。&lt;/p&gt;

&lt;h4 id=&quot;rac&quot;&gt;三.关于RAC的其他一些概念&lt;/h4&gt;
&lt;p&gt;面试题:&lt;strong&gt;ReactiveCocoa是Facebook出的一个FRP开源库&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;错误，是写Github客户端时候的附属品，附带开发出的一个开源框架。&lt;/p&gt;

&lt;p&gt;面试题:**ReactiveCocoa是基于KVO的一个开源库 **&lt;/p&gt;

&lt;p&gt;错误。KVO是RAC非常次要的部分，甚至可以说没有KVO，RAC依旧可以存在。&lt;/p&gt;

&lt;p&gt;面试题:**ReactiveCocoa是一个纯函数式编程的库 **&lt;/p&gt;

&lt;p&gt;错误，由于Cocoa框架并不是函数式，RAC又是在Cocoa框架下，所以就不是纯函数式。在命令式编程的语言范畴里面实现纯函数编程，需要折中的方法，我们可以封装命令式编程，使其向上层可以形成纯函数式的，但是下层肯定就是命令式编程实现的。&lt;/p&gt;

&lt;p&gt;最后我们再来区分一个概念:&lt;/p&gt;

&lt;p&gt;面试题:&lt;strong&gt;RAC中Pull-driver和Push-driver的区别？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Pull-driver是指的是任何时刻，我们如果需要数据了，都可以从pull-driver里面拿走数据，因为数据先存储了。整个取数据的时间控制在调用者手上。典型的例子就是for-in循环，这就是一个pull-driver的操作。不管你循环几次，每次循环如何操作，数组或者字典里面的数据都一直存在在那里，“躺”在那里。
Push-driver是相反的，在任何时刻，当有数据或者事件产生，都会push给你，如果你此时没有处理，该事件或者数据就丢失了。整个取数据的时间并不控制在调用者的手里。&lt;/p&gt;

&lt;p&gt;Pull-driver可以类比看书，知识和文字不管你看不看，一直都在书里。
Push-driver可以类比看电视，节目不管你看不看，都一直播放，你错过了就是错过了。&lt;/p&gt;

&lt;p&gt;在RAC里面，Sequence就是一个pull-driver，Signal就是一个push-driver。&lt;/p&gt;

&lt;h4 id=&quot;section-7&quot;&gt;未完待续……&lt;/h4&gt;

&lt;p&gt;我会不定期把关于RAC相关难理解易混淆的概念都整理进来……欢迎大家指点。&lt;/p&gt;
</description>
        <pubDate>Mon, 11 Jul 2016 15:36:02+0800</pubDate>
        <link>http://vno.onevcat.com/2016/07/%E5%87%BD%E6%95%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B(FRP)%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0-%E6%94%BE%E5%BC%83-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E7%AF%87/</link>
        <guid isPermaLink="true">http://vno.onevcat.com/2016/07/%E5%87%BD%E6%95%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B(FRP)%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0-%E6%94%BE%E5%BC%83-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E7%AF%87/</guid>
        
        <category>iOS</category>
        
        
        <category>Blog</category>
        
      </item>
    
      <item>
        <title>WWDC2016 Session笔记 - iOS 10 UICollectionView新特性</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-520084e0dda3ed1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;前言&lt;/h4&gt;
&lt;p&gt;关于 iOS 10  UICollectionView的新特性，主要还是体现在如下3个方面&lt;br /&gt;
1. 顺滑的滑动体验
现在基本上人人都离不开手机，手机的app也每天都有人在用。一个app的好坏由它的用户体验决定。在可以滑动的视图里面，必须要更加丝滑柔顺才能获得用户的青睐。这些UICollectionView的新特性可以让你们的app比原来更加顺滑，而且这些特性只需要你加入少量的代码即可达到目的。&lt;br /&gt;
2. 针对self-sizing的改进
self-sizing的API在iOS8的时候被引进，iOS10中加入更多特性使cell更加容易去适配。&lt;br /&gt;
3. Interactive reordering重排
这个功能在iOS9的时候介绍过了，苹果在iOS 10的API里面大大增强了这一功能。&lt;/p&gt;

&lt;p&gt;####目录
- 1.UICollectionViewCell顺滑的滑动体验
- 2.UICollectionViewCell的Pre-Fetching预加载
- 3.UITableViewCell的Pre-Fetching预加载
- 4.针对self-sizing的改进
- 5.Interactive Reordering
- 6.UIRefreshControl&lt;/p&gt;

&lt;h4 id=&quot;uicollectionviewcell&quot;&gt;一. UICollectionViewCell顺滑的滑动体验&lt;/h4&gt;
&lt;p&gt;众所周知，iOS设备已良好的用户体验赢得了广大的用户群。iOS系统在用户点击屏幕会立即做出响应。而且很大一部分的操作是来自于用户的滑动操作。所以滑动的顺滑是使用户沉浸在app中享受的必要条件。接下来我们就谈谈iOS 10 中增加了那些新特性。&lt;/p&gt;

&lt;p&gt;我们先来看一下之前 UICollectionView 的体验，假设我们每个cell都是简单的蓝色，实际开发app中，cell会比这复杂很多。 我们先生成100个cell。当用户滑动不是很快的时候，还感觉不出来卡顿，当用户大幅度滑动，整个UICollectionView的卡顿就很明显了。如果整个cell的DataSource又是从网络加载的，那就更加卡顿了。效果如下图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-2357f133fd5961cf.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果这种app上架，用户使用过后，很可能就直接给1星评价了。但是为什么会造成这种问题呢？我们来分析一下，我们模拟一下系统如何处理重用机制的，效果如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-f3aebac8fa099ff6.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在上图中，我们可以看出，当cell准备加载进屏幕的时候，整个cell都已经加载完成，等待在屏幕外面了。而且更重要的是，在屏幕外面等待加载的cell是整整一行！这一行的cell都已经加载完数据。这是UICollectionView在用户大幅度滑动时卡顿的根本原因。用专业的术语来说，掉帧。&lt;/p&gt;

&lt;p&gt;接下来我们就来详细的说说掉帧的问题。&lt;/p&gt;

&lt;p&gt;当今的用户是很挑剔的，用户需要一个很顺滑的体验，只要有一点卡顿，很可能一言不合就卸载app了。要想用户感觉不到卡顿，那么我们的app必须帧率达到60帧/秒。用数学换算一下就是每帧16毫秒就必须刷新一次。&lt;/p&gt;

&lt;p&gt;我们用图标来分析一下掉帧的问题。下面会出现2种不同的帧。&lt;/p&gt;

&lt;p&gt;第一种情况，下图是当用户轻微的上下小幅度滑动。这个时候每个cell的加载压力都不大，iOS针对这种情况，已经做了很好的优化了，所以用户感觉不到任何卡顿。这种情况是不会掉帧，用户也希望能使用如此顺滑的app。&lt;br /&gt;
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-61e63f9cf0819c8b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;第二种情况，当用户大幅度滑动，每个cell加载的压力很大，也许需要网络请求，也许需要读取数据库，而且每次都加载一行cell出来，这样每个cell的加载时间都增加了，加载一行的总时间也就大大增加了，如下图所示。这样，不仅仅当前帧在加载cell，总的时间还会挤压到下一帧的时间里面去。这种情况下，用户就感觉到了卡顿了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-c1c21562f28f212a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们换种方式在说明一下2种情况下掉帧的情况。我们用下图的标准来衡量一下上面2种情况。下图分为2部分，上面红色的区域，就是表示掉帧的区域，因为高于16ms。红色和绿色区域的分界线就在16ms处。y轴我们表示的是CPU在主线程中花费的时间。x轴表示的是在用户滑动中发生的刷新事件。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-5b3c7220a9742932.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;针对上述掉帧的情况，绘制出实验数据，如下图。值得我们关注的是，曲线是很曲折的，非常的不平滑。当用户大幅度滑动的时候，峰值超过了16ms，当用户慢速滑动的时候，帧率又能保持在比较顺滑的区域。处于绿色区域内的cell加载压力都是很小的。这就是时而掉帧时而顺滑的场景。这种场景下，用户体验是很糟糕的。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-742100ebb16ca993.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;那怎么解决这么问题的呢？我们来看下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-66aee8c339f703c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;
上图中的曲线我们看着就很平缓了，而且这种情况也不会出现掉帧的情况了，每个滑动中的时间都能达到60帧了。这是怎样做到的呢？因为把每个cell的加载事件都平分了，每个cell不会再出现很忙和很闲的两个极端。这样我们就取消了之前的波峰和波谷。从而让该曲线达到近乎水平的直线。&lt;/p&gt;

&lt;p&gt;如何让每个cell都分摊加载任务的压力？这就要谈到新的cell的生命周期了。&lt;/p&gt;

&lt;p&gt;先来看看老的 UICollectionViewCell的声明周期。当用户滑动屏幕，屏幕外有一个cell准备加载显示进来。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-1e6f8e72fba43498.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个时候我们把这个cell从reuse队列里面拿出来，然后调用prepareForReuse方法。这个方法就给了cell时间，用来重置cell，重置状态，刷新cell，加载新的数据。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-c26df5728427d953.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;再滑动，我们就会调用cellForItemAtIndexPath方法了。这个方法里面就是我们开发者自定义的填充cell的方式了。这里会填充data model，然后赋值给cell，再把cell返回给iOS系统。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-91a745c8edf6f8e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;
当cell马上要进入屏幕的时候，就会调用willDisplayCell的方法。这个方法给了我们app最后一次机会，为cell进入屏幕做最后的准备工作。执行完willDisplayCell之后，cell就进入屏幕了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-1339cb009c3810bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;
当cell完全离开屏幕之后，就会调用didEndDisplayingCell方法。以上就是在iOS10之前的整个UICollectionViewCell的生命周期。&lt;/p&gt;

&lt;p&gt;接下来我们就来看看iOS 10的UICollectionViewCell生命周期是怎么样的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-67440aea27bca091.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里还是和iOS9一样的，当用户滑动UICollectionView的时候，需要一个cell，我们就从reuse队列里面拿出一个cell，并调用prepareForReuse方法。注意调用这个方法的时间，当cell还没有进入屏幕的时候，就已经提前调用这个方法了。注意对比和iOS 9的区别，iOS 9 是在cell上边缘马上进入屏幕的时候才调用方法，而这里，cell整个生命周期都被提前了，提前到cell还在设备外面的时候。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-a17f0da0f0c23533.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里还是和之前一样，在cellForItemAtIndexPath中创建cell，填充数据，刷新状态等等操作。注意，这里生命周期也比iOS 9提前了。&lt;/p&gt;

&lt;p&gt;用户继续滑动，这个时候就有不同了！&lt;/p&gt;

&lt;p&gt;这个时候我们并不去调用willDisplayCell方法了！这里遵循的原则是，何时去显示，何时再去调用willDisplayCell。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-84563cde3084c866.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;
当cell要马上就需要显示的时候，我们再调用willDisplayCell方法。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-0f7c0d6a0c5ad1fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;
当整个cell要从UICollectionView的可见区域消失的时候，这个时候会调用didEndDisplayingCell方法。接下来发生的事情和iOS9一样，cell会进入重用队列中。&lt;/p&gt;

&lt;p&gt;如果用户想要显示某个cell，在iOS 9 当中，cell只能从重用队列里面取出，再次走一遍生命周期。并调用cellForItemAtIndexPath去创建或者生成一个cell。&lt;/p&gt;

&lt;p&gt;在iOS 10 当中，系统会把cell保持一段时间。在iOS中，如果用户把cell滑出屏幕后，如果突然又想回来，这个时候cell并不需要再走一段的生命周期了。只需要直接调用willDisplayCell就可以了。cell就又会重新出现在屏幕中。这就是iOS 10 的整个UICollectionView的生命周期。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-38285868d022c65d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-e76c5772fe94b6de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-d98623c78588707f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-aec86f77678e3d84.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-0d966174af80472f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上面说的iOS 10里面的场景同样适用于多列的情况。 这时我们每次只加载一个cell，而不是每次加载一行的cell。当第一个cell准备好之后再叫第二个cell准备。当2个cell都准备好了之后，接着我们再调用willDisplayCell给每个cell，发送完这个消息之后，cell就会出现在屏幕上了。&lt;/p&gt;

&lt;p&gt;这虽然看起来是一个很小的改动，但是这小小的改动就提升了很多的用户体验！&lt;/p&gt;

&lt;p&gt;让我们来看看上述的改动对滑动的影响&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-c832a32902927e60.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;滑动比iOS 9流程很多，这里可以看到整个过程都很平缓，不卡顿。&lt;/p&gt;

&lt;p&gt;还是和iOS 9一样，我们来模拟一下系统是如何加载cell的情况。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-561985a86edbd74a.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们可以很明显的看到，iOS 系统是一个个的加载cell的，一个cell加载完之后再去加载下一个cell。这里和iOS 9 的有很大的不同，iOS 9是加载整整一行的cell。&lt;/p&gt;

&lt;p&gt;这是因为我们用了新的 UICollectionViewCell的生命周期。整个app完全没有加一行代码。现在iOS 10是丝滑的滑动体验实在是太棒了！！&lt;/p&gt;

&lt;h4 id=&quot;uicollectionviewcellpre-fetching&quot;&gt;二. UICollectionViewCell的Pre-Fetching预加载&lt;/h4&gt;

&lt;p&gt;当我们编译iOS 10的app的时候，这个Pre-Fetching默认是enable的。当然，如果有一些原因导致你必须用到iOS 10之前老的生命周期，你只需要给collectionView加入新的isPrefetchingEnabled属性即可。如果你不想用到Pre-Fetching，那么把这个属性变成false即可。
&lt;code class=&quot;highlighter-rouge&quot;&gt;
collectionView.isPrefetchingEnabled = false
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;为了最佳实践一下这个新特性。我们先改变一下我们加载cell的方式。我们把很重的读取数据的操作，所有内容的创建都放到cellForItemAtIndexPath方法里面去完成。保证我们在willDisplayCell 和 didEndDisplayCell这两个方法里面基本不做其他事情。最后，需要注意的是cellForItemAtIndexPath生成的某些cell，可能永远都不会被展示在屏幕上，有这样一种情况，当cell将要展示在屏幕上的时候，用户突然滑动离开了这个界面。&lt;/p&gt;

&lt;p&gt;如果这个时候当你用iOS 10编译出你的app，那么非常顺滑的用户体验就会自动的优化出来。&lt;/p&gt;

&lt;p&gt;UICollectionView的流畅的滑动解决了，那么在UICollectionViewCell在加载的时候所花费的时间，怎么解决呢？？&lt;/p&gt;

&lt;p&gt;UICollectionViewCell加载的时间取决于DataModel。DataModel很可能回去加载图片，来自于网络或者来自于本地的数据库。这些操作大多数都是异步的操作。为了使data加载更快，iOS 10引入了新的API来解决这个问题。&lt;/p&gt;

&lt;p&gt;UICollectionView有2个“小伙伴”，那就是data source和delegate。在iOS 10中，将会迎来第3个“小伙伴”。这个“小伙伴”叫prefetchDataSource。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protocol UICollectionViewDataSourcePrefetching {
    func collectionView(_ collectionView: UICollectionView,
                        prefetchItemsAt indexPaths: [NSIndexPath])
    optional func collectionView(_ collectionView: UICollectionView,
                                 cancelPrefetchingForItemsAt indexPaths: [NSIndexPath])
}
class UICollectionView : UIScrollView {
    weak var prefetchDataSource: UICollectionViewDataSourcePrefetching?
    var isPrefetchingEnabled: Bool
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个协议里面只有一个必须要实现的方法——ColletionView prefetchItemsAt indexPaths。这个方法会在prefetchDataSource里面被调用，用来给你异步的预加载数据的。indexPaths数组是有序的，就是接下来item接收数据的顺序，让我们model异步处理数据更加方便。&lt;/p&gt;

&lt;p&gt;在这个协议里面还有第二个方法CollectionView cancelPrefetcingForItemsAt indexPaths，不过这个方法是optional的。我们可以利用这个方法来处理在滑动中取消或者降低提前加载数据的优先级。&lt;/p&gt;

&lt;p&gt;值得说明的是，新增加的这个“小伙伴”prefetchDataSource并不能代替原来的读取数据的方法，这个预加载仅仅只是辅助加载数据，并不能
删除原来我们读取数据的方法。&lt;/p&gt;

&lt;p&gt;至此，我们来看看从文章开始到现在，UICollectionView的性能提升了多少。我们还是用掉帧的方法来看看UICollectionView的性能。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-5b6b9e2c3350a172.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图是iOS 9 UICollectionView的性能，很明显的看见，波峰波谷很明显，并且还掉了8帧，有明显的卡顿现象。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-0f8356b077664bae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图是iOS 10 UICollectionView的性能，我们可以很明显的看到，经过iOS 10的优化，整个曲线很明显平缓了一些，没有极端的波峰掉帧现象。但是依旧存在少量的波峰快到16ms分界线了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-24bf2be2c051eb80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图是iOS 10 + Pre-Fetching API 之后的性能，已经优化的效果很明显了！整条曲线基本都水平了。近乎完美。但是还是能发现有个别波峰特别高。波峰特别高的地方就是那个cell加载压力大，时间花的比较长导致的。接下来我们继续优化！&lt;/p&gt;

&lt;p&gt;先来总结一下使用Pre-Fetching API需要注意的地方。
1. 在我们使用Pre-Fetching API的时候，我们一定要保证整个预加载的过程都放在后台线程中进行。合理使用GCD 和 NSOperationQueue处理好多线程。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;请切记，Pre-Fetching API是一种自适应的技术。何为自适应技术呢？当我们滑动速度很慢的时候，在这种“安静”的时期，Pre-Fetching API会默默的在后台帮我们预加载数据，但是一旦当我们快速滑动，我们需要频繁的刷新，我们不会去执行Pre-Fetching API。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;最后，用cancelPrefetchingAPI去迎合用户的滑动动作的变换，比如说用户在快速滑动突然发现了有趣的感兴趣的事情，这个时候停下来滑动了，甚至快速反向滑动了，或者点击了事件，进去看详情了，这些时刻我们都应该开启cancelPrefetchingAPI。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;综上所述，Pre-Fetching API对于提高UICollectionView的性能提升是很有帮助的，而且并不需要加入太多的代码。加入少量的代码就可以获得巨大的性能提升！&lt;/p&gt;

&lt;h4 id=&quot;uitableviewcellpre-fetching&quot;&gt;三. UITableViewCell的Pre-Fetching预加载&lt;/h4&gt;

&lt;p&gt;在iOS 10中，UITableViewCell也跟着UICollectionView一起得到了性能的提升，一样拥有了Pre-Fetching API。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protocol UITableViewDataSourcePrefetching {
    func tableView(_ tableView: UITableView, prefetchRowsAt indexPaths: [NSIndexPath])
    optional func tableView(_ tableView: UITableView, cancelPrefetchingForRowsAt indexPaths:
                            [NSIndexPath])
}
class UITableView : UIScrollView {
    weak var prefetchDataSource: UITableViewDataSourcePrefetching?
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里和上面 UICollectionView一样，会调用TableView prefetchRowsAt indexPaths方法。indexPaths还是一个有序数字，顺序就是列表上可见的顺序。第二个可选的API还是TableView cancelPrefetchingForRowsAt indexPaths，和之前提到的一样，也是用来取消预加载的。性能的提升和UICollectionView一样的，对UITableView的性能提升很大！&lt;/p&gt;

&lt;h4 id=&quot;self-sizing&quot;&gt;四. 针对self-sizing的改进&lt;/h4&gt;

&lt;p&gt;self-sizing API 第一次被引入是在iOS 8，然而现在在iOS 10中得到了一些改进。&lt;/p&gt;

&lt;p&gt;在UICollectionView 中有一个固定的类，叫UICollectionViewFlowLayout，iOS已经在这个类中完全支持了self-sizing。为了能开启这一特性，需要我们开发者为一些不能为0的CGSize的cell设置一下estimated item size。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
layout.estimatedItemSize = CGSize(width:50,height:50)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这会告诉UICollectionView我们想要开启动态计算内容的布局。&lt;/p&gt;

&lt;p&gt;至今，我们能有3种方法来动态的布局。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;第一种方法是使用autolayout
当我们合理的加上了constrain，当cell加载的时候，就会根据内容动态的加载布局。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第二种方法，如果你不想使用autolayout的方法，想更加手动的控制它，那么我们就需要重写sizeThatFits()方法。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第三种方法，终极的方法是重写preferredLayoutAttributesFittingAttributes()方法。在这个方法里面不仅仅可以提供size的信息，更可以得到alpha和transform的信息。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;所以想指定cell的大小，就可以用上面3个方法之一。&lt;/p&gt;

&lt;p&gt;但是实际操作中，我们可以发现，有时候设置一个合适的estimated item size，对于我们来说是很困难的事情。如果flow layout可以用数学的方法动态的计算布局，而不是根据我们给的size去布局，那会是件很酷的事情。&lt;/p&gt;

&lt;p&gt;iOS 10中就引入了新的API来解决上述的问题。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;layout.estimatedItemSize = UICollectionViewFlowLayoutAutomaticSize
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;对于开发者，我们需要做的事情，仅仅就是设置好flow layout ，然后给estimatedItemSize设定一个新的常数, 最后UICollectionViewFlowLayout 就会自动计算高度了。&lt;/p&gt;

&lt;p&gt;系统会自动计算好所有的布局，包括已经定下来的size的cell，并且还会动态的给出接下来cell的大小的预测。&lt;/p&gt;

&lt;p&gt;接下来看2个例子就可以很明显看出iOS 10针对self-sizing的改进了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-8c9bad76b1cf453c.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图可以看到，iOS 9 的布局是针对单个cell计算的，当改变了单个的cell，其他的cell依旧没有变化，还是需要重新计算。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-38a291c2d0daacc0.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里例子就可以很明显的看出差别了。当我们改变了第一个cell的size以后，系统会自动计算出所有的cell的size，并且每一行，每一个section的size都会被动态的计算出来，并且刷新界面！&lt;/p&gt;

&lt;p&gt;以上就是iOS 10针对self-sizing的改进。&lt;/p&gt;

&lt;h4 id=&quot;interactive-reordering&quot;&gt;五. Interactive Reordering&lt;/h4&gt;

&lt;p&gt;谈到重新排列，这是我们就需要类比一下UITableView了，UICollectionView的重新排列就如同UITableView 把cell上下移动，只不过UITableView的重排是针对垂直方向的。&lt;/p&gt;

&lt;p&gt;在iOS 9中，引入了UICollectionView的Interactive Reordering，在今年的iOS 10中，又加入了一些新的API。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-fedd66fb206d0beb.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在上图中，我们可以看到，我们即使任意拖动cell，整个界面也会重新排列，并且我们改变了cell的大小，整个 UICollectionView 也会重新动态的布局。&lt;/p&gt;

&lt;p&gt;我们先来看看iOS 9里面的API&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
class UICollectionView : UIScrollView {
    func beginInteractiveMovementForItem(at indexPath: NSIndexPath) -&amp;gt; Bool
    func updateInteractiveMovementTargetPosition(_ targetPosition: CGPoint)
    func endInteractiveMovement()
    func cancelInteractiveMovement()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;要想开启interactive movement，我们就需要调用beginInteractiveMovementForItem()方法，其中indexPath代表了我们将要移动走的cell。接着每次手势的刷新，我们都需要刷新cell的位置，去响应我们手指的移动操作。这时我们就需要调用updateInteractiveMovementTargetPosition()方法。我们通过手势来传递坐标的变化。当我们移动结束之后，就会调用endInteractiveMovement()方法。 UICollectionView 就会放下cell，处理完整个layout，此时你也可以重新刷新model或者处理数据model。如果中间突然手势取消了，那么这个时候就应该调用cancelInteractiveMovement()方法。如果我们重新把cell移动一圈之后又放回原位，其实就是取消了移动，那这个时候就应该在cancelInteractiveMovement()方法里面不用去刷新data source。&lt;/p&gt;

&lt;p&gt;在iOS 10中，如果你使用UICollectionViewController，那么这个重排对于你来说会更加的简单。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
class UICollectionViewController : UIViewController {
    var installsStandardGestureForInteractiveMovement: Bool
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;你只需要把installsStandardGestureForInteractiveMovement这个属性设置为True即可。CollectionViewController会自动为你加入手势，并且自动为你调用上面的方法。&lt;/p&gt;

&lt;p&gt;以上就是去年iOS 9为我们增加的API。&lt;/p&gt;

&lt;p&gt;今年的iOS 10新加入的API是在iOS 9的基础上增加了翻页的功能。&lt;br /&gt;
UICollectionView继承自UIScrollView，所以只需要你做的是把isPagingEnabled属性设置为True，即可开启分页的功能。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
collectionView.isPagingEnabled = true
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;开启分页之前：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-843decaf48445ce9.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;开启分页之后就长这样子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-7d2a6304b914cc59.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每次移动一次就会以页为单位的翻页。&lt;/p&gt;

&lt;h4 id=&quot;uirefreshcontrol&quot;&gt;六.UIRefreshControl&lt;/h4&gt;

&lt;p&gt;UIRefreshControl现在可以直接在CollectionView里面使用，同样的，也可以直接在UITableView里面使用，并且可以脱离UITableViewController。因为现在RefreshControl成为了ScrollView的一个属性了。&lt;/p&gt;

&lt;p&gt;UIRefreshControl的使用方法很简单，就三步：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
let refreshControl = UIRefreshControl()
refreshControl.addTarget(self, action: #selector(refreshControlDidFire(_:)),
                         for: .valueChanged)
collectionView.refreshControl = refreshControl
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;先创建一个refreshControl，再关联一个action事件，最后把这个新的refreshControl赋给想要的控件的对应的属性即可。&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;总结&lt;/h4&gt;

&lt;p&gt;通过以上，我们谈到了以下的知识：&lt;br /&gt;
1. UICollectionView cell pre-fetching预加载机制&lt;br /&gt;
2. UICollectionView and UITableView prefetchDataSource 新增的API &lt;br /&gt;
3. 针对self-sizing cells 的改进&lt;br /&gt;
4. Interactive reordering&lt;/p&gt;

&lt;p&gt;最后，谈谈我看了iOS 10 UICollectionView的优化的看法吧，原来有些地方用到AsyncDisplayKit优化UICollectionView速度的，现在可以考虑不用第三方库优化了，系统自带的方法可以解决一般性的卡顿的问题了。我感觉iOS 10的UICollectionView才像是一个完整版的，之前的系统优化的都不够。我还是很看好iOS 10的UICollectionView。&lt;/p&gt;

&lt;p&gt;请大家多多指教。&lt;/p&gt;
</description>
        <pubDate>Mon, 04 Jul 2016 01:02:02+0800</pubDate>
        <link>http://vno.onevcat.com/2016/07/WWDC2016-Session%E7%AC%94%E8%AE%B0-iOS-10-UICollectionView%E6%96%B0%E7%89%B9%E6%80%A7/</link>
        <guid isPermaLink="true">http://vno.onevcat.com/2016/07/WWDC2016-Session%E7%AC%94%E8%AE%B0-iOS-10-UICollectionView%E6%96%B0%E7%89%B9%E6%80%A7/</guid>
        
        <category>iOS</category>
        
        
        <category>Blog</category>
        
      </item>
    
      <item>
        <title>WWDC2016 Session笔记 - iOS 10  推送Notification新特性</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-520084e0dda3ed1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;前言&lt;/h4&gt;
&lt;p&gt;在今年6月14号苹果WWDC开发者大会上，苹果带来了新的iOS系统——iOS 10。苹果为iOS 10带来了十大项更新。苹果高级副总裁Craig Federighi称此次对iOS的更新是“苹果史上最大的iOS更新”。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-4416fe3f0633a60e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;新的屏幕通知查看方式：苹果为iOS 10带来了全新的通知查看功能，即抬起iPhone的屏幕，用户就能看到目前的通知和更新情况。&lt;/li&gt;
  &lt;li&gt;苹果将Siri开放给第三方开发者: 现在用户可以让Siri实现更多的功能，例如让Siri向自己的联系人发送微信信息等。目前Siri可以直接支持的应用有微信、WhatsApp以及Uber、滴滴、Skype等。&lt;/li&gt;
  &lt;li&gt;Siri将会更加智能：Siri将拥有更多对语境的意识。基于用户的地点、日历、联系人、联系地址等，Siri会做出智能建议。Siri将越来越成为一个人工智能机器人，具备深度学习功能。&lt;/li&gt;
  &lt;li&gt;照片应用更新：基于深度学习技术，iOS 10对照片应用有比较大的更新。iOS 10对照片的搜索能力进一步增强，可以检测到新的人物和景色。未来的iPhone能够将相关的照片组织在一起，比如某次旅行的照片、某个周末的照片，并且能够进行自动编辑。iOS 10照片还新增了一个“记忆”标签。&lt;/li&gt;
  &lt;li&gt;苹果地图：有点类似Siri和照片的更新，苹果地图也增加了很多预测功能，例如苹果地图能够将提供附近的餐厅建议。苹果地图的界面也得到了重新设计，更加的简洁，并增加了交通实时信息。新的苹果地图还将整合在苹果CarPlay中，将为用户提供turn-by-turn导航功能。和Siri一样，地图也将开放给开发者。&lt;/li&gt;
  &lt;li&gt;苹果音乐：苹果音乐的界面得到了更新，界面会更加简洁、支持多任务，增加最近播放列表。苹果音乐现在已经有1500万付费用户。&lt;/li&gt;
  &lt;li&gt;HomeKit：iOS 10新增智能家庭应用，支持一键场景模式，HomeKit可以与Siri相连接。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-dd5070c430b37cc7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;苹果电话：苹果更新了电话功能，来电时可以区别出骚扰电话。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-20115aefabb1c770.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;iMesseage：在iMessage方面，用户可以直接在文本框内发送视频、链接，分享实时照片。另外，苹果还增添了表情预测功能，打出的文字若和表情相符，将会直接推荐相关表情。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以下是我关于关于iOS 10中变化比较大的推送通知的学习笔记。&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;目录&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;1.Notification User Interface&lt;/li&gt;
  &lt;li&gt;2.Media Attachments&lt;/li&gt;
  &lt;li&gt;3.Customize user interface&lt;/li&gt;
  &lt;li&gt;4.Customize Actions&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;notification-user-interface&quot;&gt;一. Notification User Interface&lt;/h4&gt;
&lt;p&gt;让我们先来看看用户推送在iOS X中的样子，如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-3439e7712872c625.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图这是在锁屏界面下的推送。支持抬起手机唤醒功能。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-a74bf10dc32c739b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;
上图是Banner，可以看到这个推送更加的易读，并且包含更多的内容。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-d9dbd2a57d18d8ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图是通知中心。从上面三种图可以看到，它们都长一个样。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-55e35bda6f792759.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在iOS 8 中，我们可以给推送增加用户操作，这样使推送更加具有交互性，并且允许用户去处理用户推送更加的迅速。到了iOS 9 中，苹果又再次增加了快速回复功能，进一步的提高了通知的响应性。开发者可以允许用户通过点击推送，并用文字进行回复。再就到了iOS 10 中，推送变得更加给力。因为在iOS X中，推送对iOS系统来说，是很重要的一部分。在日常使用中，我们会经常和推送打交道。推送是我们和设备进行互动非常重要的方式。&lt;/p&gt;

&lt;p&gt;在iOS X 中，你可以按压推送，推送就会被展开，展示出更加详细的用户界面。展示出来的详细界面对用户来说，提供了更加有用的信息。用户可以通过点击下面的按钮，来处理一些事件，并且推送的详细界面也会跟着用户的操作进行更新UI界面。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-28f89dc9b23bb018.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;iOS 8 中iMessage支持了快速回复功能，但是你只能看见一条信息，并且你也只能回复一条信息。但是在iOS X中，你可以展开推送，这个时候你就可以看到整个对话的内容了。你可以等待你的朋友回复，你再回复他，并且可以回复很多条。&lt;/p&gt;

&lt;p&gt;以上就是iOS X的强大功能。以上的所有功能都能通过iOS X的新API来实现。所有的新特性都能在我们开发者开发的app里面有所体现。&lt;/p&gt;

&lt;h4 id=&quot;media-attachments&quot;&gt;二. Media Attachments&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-51beb1aaef4af5ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果经常使用iMessage的朋友们，就会经常收到一些信息，附带了一些照片或者视频，所以推送中能附带这些多媒体是非常重要的。如果推送中包含了这些多媒体信息，可以使用户不用打开app，不用下载就可以快速浏览到内容。众所周知，推送通知中带了push payload，及时去年苹果已经把payload的size提升到了4k bites，但是这么小的容量也无法使用户能发送一张高清的图片，甚至把这张图的缩略图包含在推送通知里面，也不一定放的下去。在iOS X中，我们可以使用新特性来解决这个问题。我们可以通过新的service extensions来解决这个问题。&lt;/p&gt;

&lt;p&gt;为了能去下载service extension 里面的attachment，我们必须去按照如下的要求去设置你的推送通知，使你的推送通知是动态可变的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;aps:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;{……&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;mutable-content&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;my-attachment&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;https://example.com/phtos.jpg&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;在上面代码中，可以看到加载了一个mutable-content 的flag，然后我们就可以引用一个链接，把你想加入到推送里面的attachments加入到里面来。在上面的例子里面，我们就加入了一个URL。更复杂的，你甚至可以去加入一个identifier来标示你想加入到推送里面的内容，这个identifier是你app知道的，app能通过拿到identifier，然后知道去你自己的服务器哪里去下载内容。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-ba7069e754c5bcf8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过设置完上述的部分，推送就被推送到了每个设备的Service Extension那里了。在每个设备里面的Service Extension里面，就可以下载任意想要的attachment了。然后推送就会带着下载好的attachment推送到手机并显示出来了。&lt;/p&gt;

&lt;p&gt;如果来设置Service Extension呢？来看看如下的代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
// Adding an attachment to a user notification

public class NotificationService: UNNotificationServiceExtension {
    override public func didReceive(_ request: UNNotificationRequest, withContentHandler contentHandler: (UNNotificationContent) -&amp;gt; Void)
    {
        let fileURL = // ...
        let attachment = UNNotificationAttachment(identifier: &quot;image&quot;,
                                                  url: fileURL,
                                                  options: nil)
        let content = request.content.mutableCopy as! UNMutableNotificationContent 
        content.attachments = [ attachment ]
        contentHandler(content)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;首先定义了一个didReceive的方法，用来接收request，后面跟着withContentHandler的回调函数。
这个NotificationServiceExtension会在收到推送之后，被调用，然后在这个方法里面去下载自己的attachment。下载可以通过URL，或者任何你喜欢的方式。当下载完成之后，就可以创建attachment对象了。创建完UNMutableNotificationContent，我们就可以把这个加入到推送的content中了。最后，通过contentHandler回调，把它传递给iOS系统，iOS 系统就会展示给用户。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-a02ca43edd228bc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过以上的设置，我们就能在推送中看到丰富的媒体信息了。用户并不需要去打开app，也不用去点击下载。&lt;/p&gt;

&lt;p&gt;简单的概述一下Media Attachments：&lt;br /&gt;
1. 新特性使推送支持附带Media Attachments。本地推送和远程推送同时都可支持。&lt;br /&gt;
2. attachment支持图片，音频，视频，系统会自动提供一套可自定义化的UI，专门针对这3种内容。&lt;br /&gt;
3. 在service extension里面去下载attachment，但是需要注意，service extension会限制下载的时间，并且下载的文件大小也会同样被限制。这里毕竟是一个推送，而不是把所有的内容都推送给用户。所以你应该去推送一些缩小比例之后的版本。比如图片，推送里面附带缩略图，当用户打开app之后，再去下载完整的高清图。视频就附带视频的关键帧或者开头的几秒，当用户打开app之后再去下载完整视频。&lt;br /&gt;
4. 把下载完成的attachment加入到notification中。  &lt;br /&gt;
5. 推送里面包含的attachment这些文件，是由系统帮你管理的，系统会把这些文件放在单独的一个地方，然后统一管理。&lt;br /&gt;
6. 额外说明一点，推送的attachment的图片还可以包含GIF图。&lt;/p&gt;

&lt;p&gt;通过以上可以看出，Media Attachments非常的酷，它为我们提供了更加丰富的推送内容。&lt;/p&gt;

&lt;p&gt;接下来我们再来看看如何自定义推送的用户界面&lt;/p&gt;

&lt;h4 id=&quot;customize-user-interface&quot;&gt;三. Customize user interface&lt;/h4&gt;

&lt;p&gt;要想创建一个自定义的用户界面，需要用到Notification content extension。&lt;/p&gt;

&lt;p&gt;先来说说下面这个例子的应用场景：&lt;/p&gt;

&lt;p&gt;比如有个朋友在日历中给我了一个聚会的邀请，这个时候就来了推送，推送里面的内容就是包含了聚会的时间地点信息，推送下面有三个按钮，接受，谢绝。下面的例子都以此为例。&lt;/p&gt;

&lt;p&gt;Notification content extension允许开发者加入自定义的界面，在这个界面里面，你可以绘制任何你想要的东西。但是有一个最重要的限制就是，这个自定义的界面没有交互。它们不能接受点击事件，用户并不能点击它们。但是推送通知还是可以继续与用户进行交互，因为用户可以使用notificaiton的actions。extension可以处理这些actions。&lt;/p&gt;

&lt;p&gt;接下来我们就来说说如何自定义界面&lt;/p&gt;

&lt;h5 id=&quot;section-2&quot;&gt;1.   推送的四部分&lt;/h5&gt;

&lt;p&gt;先来看一个日历的推送例子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-15b9cc813f3c40cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图，整个推送分4段。用户可以通过点击Header里面的icon来打开app，点击取消来取消显示推送。Header的UI是系统提供的一套标准的UI。这套UI会提供给所有的推送通知。&lt;/p&gt;

&lt;p&gt;Header下面是自定义内容，这里就是显示的Notification content extension。在这里，就可以显示任何你想绘制的内容了。你可以展示任何额外的有用的信息给用户。&lt;/p&gt;

&lt;p&gt;content extension下面就是default content。这里是系统的界面。这里的系统界面就是上面推送里面payload里面附带的内容。这也就是iOS 9 之前的推送的样子。&lt;/p&gt;

&lt;p&gt;最下面一段就是notification action了。在这一段，用户可以触发一些操作。并且这些操作还会相应的反映到上面的自定义的推送界面content extension中。&lt;/p&gt;

&lt;h5 id=&quot;notification-content-extension&quot;&gt;2.创建Notification content extension&lt;/h5&gt;

&lt;p&gt;接下来我们就来看看如何创建一个Notification content extension&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-b8b69cdab7aee38e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;第一件事就是去创建一个新的target。创建好了之后，Xcode会自动帮我们生成一个template。template会在新的target里面生成3个文件，一个新的ViewController，main Interface storyboard，info.plist。info.plist中就是可以定义化一些target的配置。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-bffc21df9faf33e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;打开Notification content extension的ViewController&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
// Minimal Content Extension
class NotificationViewController: UIViewController, UNNotificationContentExtension {
    @IBOutlet var label: UILabel?
    override func viewDidLoad() {
        super.viewDidLoad()
        // Do any required interface initialization here.
    }
    func didReceive(_ notification: UNNotification) {
        label?.text = notification.request.content.body
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;我们会发现，这个ViewController是UIViewController的子类，其实就是一个很普通的ViewController，和我们平时使用的没有啥两样。后面是UNNotificationContentExtension的protocol，这里是系统要求你必须实现的协议。&lt;/p&gt;

&lt;p&gt;UNNotificationContentExtension只有一个required的方法，就是didReceive方法。当推送到达你的设备之后，这个didReceive方法会随着ViewController的生命周期的方法 ，一起被调用。当开发者给推送加上expands的时候，一旦推送送达以后，这时会接到所有的ViewController生命周期的方法，和didReceive方法。这样，我们就可以接收notification object ，接着更新UI。&lt;/p&gt;

&lt;h5 id=&quot;target&quot;&gt;3. 配置target&lt;/h5&gt;
&lt;p&gt;接下来，我们需要做的是，告诉iOS系统，推送送达之后，iOS系统如何找到你自定义的Notification content extension。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-9cafc7af30c557d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Notification content extension和我们注册notification actions一样，注册的相同的category。这个例子中，我们使用event-invite。值得提到的一点是，这里的extension是可以为一个数组的，里面可以为多个category，这样做的目的是多个category共用同一套UI。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-33d02a0c6572c81b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图中，event-invite 和 event-update就共用了一套UI。这样我们就可以把他们打包到一个extension里面来。但是不同的category是独立的，他们可以相应不同的actions。&lt;/p&gt;

&lt;p&gt;通过以上设置，iOS系统就知道了我们的target了。&lt;/p&gt;

&lt;h5 id=&quot;ui&quot;&gt;4. 自定义用户UI界面&lt;/h5&gt;

&lt;p&gt;接下来我们来自定义UI界面。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
// Notification Content Extension
class NotificationViewController: UIViewController, UNNotificationContentExtension {
    @IBOutlet var eventTitle: UILabel!
    @IBOutlet var eventDate: UILabel!
    @IBOutlet var eventLocation: UILabel!
    @IBOutlet var eventMessage: UILabel!
    
    func didReceive(_ notification: UNNotification) {
        let content = notification.request.content
        
        eventTitle.text = content.title
        eventDate.text = content.subtitle
        eventMessage.text = content.body
        
        if let location = content.userInfo[&quot;location&quot;] as? String {
            eventLocation.text = location
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上述代码中，我们在stroyboard 里面加入了一些labels 。当接收到推送的时候，我们提取出内容，得到我们想要的内容，然后把这些内容设置到label上面去，并展示出来。在content的userinfo里面我们还能加入一些额外的信息，这些信息是标准的payload无法展示的，比如说位置信息等等。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-c1962c798ad01273.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;代码完成之后就是如上的样子，中间就是我们自定义的UIView了。但是这样子会有2个问题。第一个问题就是这个自定义的View实在太大了。大量的空白不需要显示出来。第二个问题就是我们自定义的内容和下面默认的推送内容重复了。我们需要去掉一份。&lt;/p&gt;

&lt;h5 id=&quot;section-3&quot;&gt;5.改进&lt;/h5&gt;

&lt;p&gt;我们先来改进上面说的第二个问题。
这个问题很简单，其实就是一个plist的设置。我们可以在plist里面把默认的content隐藏。设置如下图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-b4dc0be29fdce509.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;再来说说第一个问题，界面大小的问题。
我们可以通过平时我们Resize其他ViewController一样，来Resize这个ViewController。来看看如下的代码。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
// Notification Content Extension
class NotificationViewController: UIViewController, UNNotificationContentExtension {
    override func viewDidLoad() {
        
        super.viewDidLoad()
        let size = view.bounds.size
        
        preferredContentSize = CGSize(width: size.width, height: size.width / 2)
    }
    
    func didReceive(_ notification: UNNotification) {
        // ...
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里我们也可以加入constraints来做autolayout。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-7f7cc4a4fc88a599.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;解决完上面2个问题，界面就会变成这个样子。看上去比之前好很多了。正常的尺寸，没有多余的空白。没有重复信息。但是这又出现了另外一个问题。当通知展示出来之后，它的大小并不是正常的我们想要的尺寸。iOS系统会去做一个动画来Resize它的大小。如下图，系统会先展现出第一张图，然后紧接着展示第二张图，这个用户体验很差。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-7d887c3b6ec3fe57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-20779263e0de3c19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;会出现上面这张图的原因是，在推送送达的那一刻，iOS系统需要知道我们推送界面的最终大小。但是我们自定义的extension在系统打算展示推送通知的那一刻，并还没有启动。所以这个时候，在我们代码都还没有跑起来之前，我们需要告诉iOS系统，我们的View最终要展示的大小。&lt;/p&gt;

&lt;p&gt;现在问题又来了。这些通知会跑在不同的设备上，不同的设备的屏幕尺寸不同。为了解决这个问题，我们需要设置一个content size ratio。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-e7cd9adac20e2730.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个属性定义了宽和高的比例。当然设置了这个比例以后，也并不是万能的。因为你并不知道你会接受到多长的content。当你仅仅只设置比例，还是不能完整的展示所有的内容。有些时候如果我们可以知道最终的尺寸，那么我们固定尺寸会更好。&lt;/p&gt;

&lt;h5 id=&quot;section-4&quot;&gt;6. 进一步美化&lt;/h5&gt;

&lt;p&gt;我们可以给这个extension加上Media Attachments。一旦我们加入Media Attachments，我们可以在content extension里面使用这些内容。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
// Notification Content Extension Attachments
class NotificationViewController: UIViewController, UNNotificationContentExtension {
    @IBOutlet var eventImage: UIImageView!
    func didReceive(_ notification: UNNotification) {
        let content = notification.request.content
        if let attachment = content.attachments.first {
            if attachment.url.startAccessingSecurityScopedResource() {
                eventImage.image = UIImage(contentsOfFile: attachment.url.path!)
                attachment.url.stopAccessingSecurityScopedResource()
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;我们可以提取content的attachments。前文提到过，attachment是由系统管理的，系统会把它们单独的管理，这意味着它们存储在我们sandbox之外。所以这里我们要使用attachment之前，我们需要告诉iOS系统，我们需要使用它，并且在使用完毕之后告诉系统我们使用完毕了。对应上述代码就是startAccessingSecurityScopedResource()和stopAccessingSecurityScopedResource()的操作。当我们获取到了attachment的使用权之后，我们就可以使用那个文件获取我们想要的信息了。&lt;/p&gt;

&lt;p&gt;上述例子中，我们从attachment中获取到图片，并展示到UIImageView中。于是notification就变成下面这个样子了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-4640a3c616c41b8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;customize-actions&quot;&gt;四.Customize Actions&lt;/h4&gt;

&lt;p&gt;说道这里，我们不得不说一下iOS8开始引入的action的工作原理：
默认系统的Action的处理是，当用户点击的按钮，就把action传递给app，与此同时，推送通知会立即消失。这种做法很方便。&lt;/p&gt;

&lt;p&gt;但是还有一种情况，当用户点击了按钮，希望接受一些日历上的邀请，我们需要把这个操作即时的展示在我们自定义的UI上，这是我们就只能用Notification content extension来处理这些用户点击事件了。这个时候，用户点击完按钮，我们把这个action直接传递给extension，而不是传递给app。当actions传递给extension时，它可以延迟推送通知的消失时间。在这段延迟的时间之内，我们就可以处理用户点击按钮的事件了，并且更新UI，一切都处理完成之后，我们再去让推送通知消失掉。&lt;/p&gt;

&lt;p&gt;这里我们可以运用UNNotificationContentExtension协议的第二个方法，这方法是Optional&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
// Intercepting notification action response
class NotificationViewController: UIViewController, UNNotificationContentExtension {
    func didReceive(_ response: UNNotificationResponse, completionHandler done: (UNNotificationContentExtensionResponseOption) -&amp;gt; Void) {
        server.postEventResponse(response.actionIdentifier) {
            if response.actionIdentifier == &quot;accept&quot; {
                eventResponse.text = &quot;Going!&quot;
                eventResponse.textColor = UIColor.green()
            } else if response.actionIdentifier == &quot;decline&quot; {
                eventResponse.text = &quot;Not going :(&quot;
                eventResponse.textColor = UIColor.red()
            }
            done(.dismiss)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;不用这个方法的时候就可以不声明出来。但是一旦声明了，那么你就需要在这个方法里面处理推送通知里面所有的actions。这就意味着你不能只处理一个action，而不管其他的action。&lt;/p&gt;

&lt;p&gt;在上述代码中，当用户点击了按钮，这个时候我们同步一下服务器信息，当接收到了服务器应答之后，然后我们更新UI。用户点击了“accept”之后，表示接受了这次聚会邀请，于是我们把text的颜色变成绿色。当用户点击了“decline”，表示谢绝，于是我们把text的颜色变成红色。当用户点击之后，更新完界面，我们就让推送通知消失掉。&lt;/p&gt;

&lt;p&gt;这里值得一提的是，如果你还想把这个action传递给app，那么最后的参数应该是这样。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;done(.dismissAndForwardAction)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;参数设置成这样之后，用户的action就会再传递给app。&lt;/p&gt;

&lt;p&gt;如果此时用户还想输入写文字来评论这条推送，我们该如何做？&lt;/p&gt;

&lt;p&gt;这个输入文字的需求是来自于iOS 9 。这个的使用方法和9是相同的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
// Text Input Action
private func makeEventExtensionCategory() -&amp;gt; UNNotificationCategory {
    let commentAction = UNTextInputNotificationAction(
        identifier: &quot;comment&quot;,
        title: &quot;Comment&quot;,
        options: [],
        textInputButtonTitle: &quot;Send&quot;,
        textInputPlaceholder: &quot;Type here...&quot;)
    return UNNotificationCategory(identifier: &quot;event-invite&quot;, actions: [ acceptAction, declineAction, commentAction ],
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;我们可以创建一个UNTextInputNotificationAction，并把它设置到plist里面的Category中。当推送通知到来之后，用户点击了按钮，textfield就会显示出来。同样的处理action代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
// Text input action response
class NotificationViewController: UIViewController, UNNotificationContentExtension {
    func didReceive(_ response: UNNotificationResponse,
                      completionHandler done: (UNNotificationContentExtensionResponseOption) -&amp;gt; Void) {
        if let textResponse = response as? UNTextInputNotificationResponse {
            server.send(textResponse.userText) {
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个时候当用户点击了评论按钮，就会弹出textfield。&lt;/p&gt;

&lt;p&gt;这里还有一个问题，就是用户点完评论按钮之后，之前的接受和谢绝的按钮就消失了。这个时候用户可能有这个需求，想又评论，又接受或者谢绝。那么我们就需要在下面键盘上加入这两个按钮。如下图这样子。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-68965591c8c9c0c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里并没有新的API，还是用原来的API。我们可以使用已经存在的UIKit的API去定制输入的input accessory view。它可以让我们开发者加入自定义的按钮。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
// Custom input accessory view
class NotificationViewController: UIViewController, UNNotificationContentExtension {
    override func canBecomeFirstResponder() -&amp;gt; Bool {
        return true
    }
    override var inputAccessoryView: UIView { get {
        return inputView
        }
    }
    func didReceive(_ response: UNNotificationResponse,
                      completionHandler done: (UNNotificationContentExtensionResponseOption) -&amp;gt; Void) {
        if response.actionIdentifier == &quot;comment&quot; {
            becomeFirstResponder()
            textField.becomeFirstResponder()
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;解析一下上述的代码。首先我们需要让ViewController BecomeFirstResponder。这里做了2件事情，一是告诉responder chain，我成为了第一响应者，二是告诉iOS系统，我不想使用系统标准的text field。接着就可以创建自定义化的inputAccessoryView。如上图中显示的，带自定义的两个按钮。然后，当extension接受到了用户点击按钮后产生的action，这时自定义的textfield就会变成第一响应者，并且伴随着键盘的弹起。&lt;/p&gt;

&lt;p&gt;注意，这里需要2个becomeFirstResponder，第一个becomeFirstResponder是使viewController变成第一响应者，这样textfield就会出现。第二个becomeFirstResponder是使我们自定义的textfield变成第一响应者，这样键盘才会弹起。&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;以上就是iOS X中notification的所有新特性，通过上文，我们学到的以下的知识，总结一下：&lt;br /&gt;
1. 什么是attachment&lt;br /&gt;
2. 如何在service extension中使用attachment&lt;br /&gt;
3. 如何定义content extension的用户UI界面&lt;br /&gt;
4. 如何响应用户操作action&lt;/p&gt;

&lt;p&gt;最后，请大家多多指教。&lt;/p&gt;
</description>
        <pubDate>Sun, 26 Jun 2016 21:21:02+0800</pubDate>
        <link>http://vno.onevcat.com/2016/06/WWDC2016-Session%E7%AC%94%E8%AE%B0-iOS-10-%E6%8E%A8%E9%80%81Notification%E6%96%B0%E7%89%B9%E6%80%A7/</link>
        <guid isPermaLink="true">http://vno.onevcat.com/2016/06/WWDC2016-Session%E7%AC%94%E8%AE%B0-iOS-10-%E6%8E%A8%E9%80%81Notification%E6%96%B0%E7%89%B9%E6%80%A7/</guid>
        
        <category>iOS</category>
        
        
        <category>Blog</category>
        
      </item>
    
  </channel>
</rss>
