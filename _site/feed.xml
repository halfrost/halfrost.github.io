<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Halfrost&#39;s Field | 冰霜之地</title>
    <description>嗨，我是于德志 (@halfrost)，一名来自中国的 iOS 开发者，已退役 acmer 。现居上海。吾笃信：德不孤，必有志，技不疏，必有朋。</description>
    <link>http://vno.onevcat.com/</link>
    <atom:link href="http://vno.onevcat.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 14 Aug 2016 19:33:24 +0800</pubDate>
    <lastBuildDate>Sun, 14 Aug 2016 19:33:24 +0800</lastBuildDate>
    <generator>Jekyll v3.1.6</generator>
    
      <item>
        <title>手把手教你给一个iOS app配置多个环境变量</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-fa88cb2e6feceae7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;前言&lt;/h4&gt;
&lt;p&gt;谈到多环境，相信现在大多公司都至少有2-3个app环境了，比如Test环境，UAT(User Acceptance Test)用户验收测试环境，Release环境等等。当需要开发打多个包的时候，一般常见做法就是直接代码里面修改环境变量，改完之后Archive一下就打包了。当然这种做法很正确，只不过不是很优雅很高效。如果搭建好了Jenkins(&lt;a href=&quot;http://www.jianshu.com/p/41ecb06ae95f&quot;&gt;搭建教程&lt;/a&gt;)，我们利用它来优雅的打包。如果利用Jenkins来打包，我们就需要来给app来配置一下多个环境变量了。之后Jenkins分别再不同环境下自动集成即可。接下来，我们来谈谈常见的2种做法。&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;目录&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;1.利用Build Configuration来配置多环境&lt;/li&gt;
  &lt;li&gt;2.利用&lt;a href=&quot;https://developer.apple.com/library/ios/recipes/xcode_help-project_editor/Articles/BasingBuildConfigurationsonConfigurationFiles.html&quot;&gt;xcconfig&lt;/a&gt;文件来配置多环境&lt;/li&gt;
  &lt;li&gt;3.利用Targets来配置多环境&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;build-configuration&quot;&gt;一.利用Build Configuration来配置多环境&lt;/h4&gt;
&lt;p&gt;前言里面我们先谈到了需求，由于需要配置多个环境，并且多个环境都需要安装到手机上，那么可以配置Build Configuration来完成这个任务。如果Build Configuration还不熟悉的，可以先温习一下&lt;a href=&quot;https://developer.apple.com/library/ios/recipes/xcode_help-project_editor/Articles/BasingBuildConfigurationsonConfigurationFiles.html&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;

&lt;h5 id=&quot;build-configuration-1&quot;&gt;1. 新建Build Configuration&lt;/h5&gt;
&lt;p&gt;先点击Project里面找到Configuration，然后选择添加，这里新加一个Configuration。系统默认是2个，一个Debug，一个Release。这里我们需要选择是复制一个Debug还是Release。Release和Debug的区别是，Release是不能调试程序，因为默认是屏蔽了可调试的一些参数，具体可以看BuildSetting里面的区别，而且Release编译时有做编译优化，会比用Debug打包出来的体积更小一点。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-bc2cd086f31d3263.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里我们选择一个Duplicate “Debug” Configuration，因为我们新的环境需要debug，添加完了之后就会多了一套Configuration了，这一套其实是包含了一些编译参数的配置集合。如果此时项目里面有cocopods的话，打开Configuration Set就会发现是如下的样子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-af56fd34c9b1bfc8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在我们自己的项目里面用了Pod，打开配置是会看到如下信息
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-770ea4347a9a0928.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意：刚刚新建完Build Configuration之后，这时如果有pod，请立即执行一下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
pod install  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;pod安装完成之后会自动生成xcconfig文件，如果你手动新建这个xcconfig，然后把原来的debug和release对应的pod xcconfig文件内容复制进来，这样做是无效的，需要pod自己去生成xcconfig文件才能被识别到。&lt;/p&gt;

&lt;p&gt;新建完Build Configuration，这个时候需要新建pod里面对应的Build Configuration，要不然一会编译会报错。如果没用pod，可以忽略一下这一段。&lt;/p&gt;

&lt;p&gt;如下图新建一个对应之前Porject里面新建的Build Configuration
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-0ecc3c2cb61b83d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;scheme&quot;&gt;2. 新建Scheme&lt;/h5&gt;

&lt;p&gt;接下来我们要为新的Configuration新建一个编译Scheme。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-3e882c6c04155c21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;新建完成之后，我们就可以编辑刚刚新建的Scheme，这里可以把Run模式和Archive都改成新建Scheme。如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-0ec7df2dfbea089e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意：如果是使用了Git这些协同工具的同学这里还需要把刚刚新建的Scheme共享出去，否则其他人看不到这个Scheme。选择“Manage Schemes”&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-5f6f36cacb4404f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;user-defined-build-settings&quot;&gt;3. 新建User-defined Build Settings&lt;/h5&gt;

&lt;p&gt;再次回到Project的Build Settings里面来，Add User-Defined Setting。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-b212148be039475c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们这里新加入2个参数，CustomAppBundleld是为了之后打包可以分开打成多个包，这里需要3个不同的Id，建议是直接在原来的Bundleld加上Scheme的名字即可。&lt;/p&gt;

&lt;p&gt;CustomProductName是为了app安装到手机上之后，手机上显示的名字，这里可以按照对应的环境给予描述，比如测试服，UAT，等等。如下图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-e53a11b9c0317976.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里值得提到的一点是，下面Pods的Build_DIR这些目录其实是Pods自己生成好的，之前执行过&lt;strong&gt;Pod install&lt;/strong&gt; 之后，这里默认都是配置好的，不需要再改动了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-b881321289e8b498.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;infoplist--imagesxcassets&quot;&gt;4. 修改info.plist文件 和 Images.xcassets&lt;/h5&gt;

&lt;p&gt;先来修改一下info.plist文件。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-030b30264df74e43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由于我们新添加了2个CustomAppBundleld 和 CustomProductName，这里我们需要把info.plist里面的Bundle display name修改成我们自定义的这个字典。编译过程中，编译器会根据我们设置好的Scheme去自己选择Debug，Release，TestRelease分别对应的ProductName。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-2936ad12b68610d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们还需要在Images.xcassets里面新添加2个New iOS App Icon，名字最好和scheme的名字相同，这样好区分。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-f886a8b706d306e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;新建完AppIcon之后，再在Build Setting里面找到&lt;strong&gt;Asset Catalog Compiler&lt;/strong&gt;里面，然后把这几种模式下的App Icon set
 Name分别设置上对应的图标。如上图。&lt;/p&gt;

&lt;p&gt;既然我们已经新建了这几个scheme，那接下来怎么把他们都打包成app呢？？这里有一份官方的文档&lt;a href=&quot;https://developer.apple.com/library/ios/technotes/tn2215/_index.html&quot;&gt;Troubleshooting Application Archiving in Xcode&lt;/a&gt;这里面详细记录了我们平时点击了Archive之后是怎么打包的。&lt;/p&gt;

&lt;p&gt;这里分享一下我分好这些环境的心得。一切切记，每个环境都要设置好Debug 和 Release！千万别认为线上的版本只设置Release就好，哪天需要调试线上版本，没有设置Debug就无从下手了。也千万别认为测试环境的版本只要设置Debug就好，万一哪天要发布一个测试环境需要发Release包，那又无从下手了。我的建议就是每个环境都配置Debug 和 Release，即使以后不用，也提前设置好，以防万一。合理的设置应该如下图这样。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  
| -------------------------- |------------------|
|           Scheme           |   Configurations |  
| -------------------------- |------------------| 
|      XXXXProjectTest       |      Debug       | 
|                            |------------------|
|                            |      Release     | 
| -------------------------- |------------------|
|      XXXXProjectAppStore   |      Debug       | 
|                            |------------------|
|                            |      Release     | 
| -------------------------- |------------------|
|      XXXXProjectUAT        |      Debug       | 
|                            |------------------|
|                            |      Release     | 
| -------------------------- |------------------|

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;注意这里一定要把Scheme的名字和编译方式区分开，选择了一个Scheme，只是相当于选择了一个环境，并不是代表这Debug还是Release。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-059d8650a96b18fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我建议Scheme只配置环境，而进来的Run和Archive来配置Debug和Release，我建议每个Scheme都按照上图来，Run对应的Debug，Archive对应的Release。&lt;/p&gt;

&lt;p&gt;配置好上述之后，就可以选择不同环境运行app了。可以在手机上生成不同的环境的app，可以同时安装。如下图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-a646aa4090d14d41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;section-2&quot;&gt;5. 配置和获取环境变量&lt;/h5&gt;

&lt;p&gt;接下来讲几种动态配置环境变量的方法&lt;/p&gt;

&lt;h6 id=&quot;gccgccpreprocessordefinitions&quot;&gt;1. 使用GCC预编译头参数GCC_PREPROCESSOR_DEFINITIONS&lt;/h6&gt;

&lt;p&gt;我们进入到Build Settings里面，可以找到Apple LLVM Preprocessing，这里我们可以找到&lt;strong&gt;Preprocessor Macros&lt;/strong&gt;在这里，我们是可以加一些环境变量的宏定义来标识符。Preprocessor Macros可以根据不同的环境预先制定不同定义的宏。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-427d4a19e32c41f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;
如上图，圈出来的地方其实就是一个标识符。&lt;/p&gt;

&lt;p&gt;有了这些我们预先设置的标识符之后，我们就可以在代码里面写入如下的代码了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
#ifdef DEVELOP
#define searchURL @&quot;http://www.baidu.com&quot;
#define sociaURL  @&quot;weibo.com&quot;
#elif UAT
#define searchURL @&quot;http://www.bing.com&quot;
#define sociaURL  @&quot;twitter.com&quot;
#else
#define searchURL @&quot;http://www.google.com&quot;
#define sociaURL  @&quot;facebook.com&quot;
#endif

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h6 id=&quot;plist&quot;&gt;2. 使用plist文件动态配置环境变量&lt;/h6&gt;

&lt;p&gt;我们先来新建3个名字一样的plist作为3个环境的配置文件。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-ea7dd9eeead81ce0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里名字一样的好处是写代码方便，因为就只需要去读取“Configuration.plist”就可以了，如果名字不一样，还要分别去把对应环境的plist名字拼接出来才能读取。&lt;/p&gt;

&lt;p&gt;众所周知，在一个文件夹里面新建2个相同名字的文件，Mac 系统都会提示我们名字相同，不允许我们新建。那我们怎么新建3个相同名字的文件呢？这其实很简单，分别放在3个不同文件夹下面即可。如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-34d9755680c0828e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我就是这样放置的，大家可以根据自己习惯去放置文件。&lt;/p&gt;

&lt;p&gt;接下来我们要做的是在编译的时候，运行app前，动态的copy Configuration.plist到app里面，这里需要设置一个copy脚本。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-11b5eb2740734f28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;进入到我们的Target里面，找到&lt;strong&gt;Build Phases&lt;/strong&gt;，我们新建一个&lt;strong&gt;New Copy Files Phase&lt;/strong&gt;，并且重命名为&lt;strong&gt;Copy Configuration Files&lt;/strong&gt;。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
echo &quot;CONFIGURATION -&amp;gt; ${CONFIGURATION}&quot;
RESOURCE_PATH=${SRCROOT}/${PRODUCT_NAME}/config/${CONFIGURATION}

BUILD_APP_DIR=${BUILT_PRODUCTS_DIR}/${PRODUCT_NAME}.app

echo &quot;Copying all files under ${RESOURCE_PATH} to ${BUILD_APP_DIR}&quot;
cp -v &quot;${RESOURCE_PATH}/&quot;* &quot;${BUILD_APP_DIR}/&quot;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这一段脚本就能保证我们的Configuration.plist 文件可以在编译的时候，选择其中一个打包进我们的app。&lt;/p&gt;

&lt;p&gt;再写代码每次读取这个plist里面的信息就可以做到动态化了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
- (NSString *) readValueFromConfigurationFile {
    NSBundle *bundle = [NSBundle mainBundle];
    NSString *path = [bundle pathForResource:@&quot;Configuration&quot; ofType:@&quot;plist&quot;];
    NSDictionary *config = [NSDictionary dictionaryWithContentsOfFile:path];
    return config[@&quot;serverURL&quot;];
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里我假设plist文件里面预设置了一个serverURL的字符串，用这种方式就可以读取出来了。当然在plist里面也可以设置数组，字典，相应的把返回值和Key值改一下就可以了。&lt;/p&gt;

&lt;h6 id=&quot;section-3&quot;&gt;3. 使用单例来处理环境切换&lt;/h6&gt;

&lt;p&gt;当然使用一个单例也可以做到环境切换。新建一个单例，然后可以在设置菜单里面加入一个列表，里面列出所有的环境，然后用户选择以后，单例就初始化用户所选的环境。和上面几种方式不同的是，这种方式就是在一个app里面切换多种环境。看大家的需求，任取所需。&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;二.利用文件来配置多环境&lt;/h4&gt;
&lt;p&gt;说道&lt;a href=&quot;https://developer.apple.com/library/ios/recipes/xcode_help-project_editor/Articles/BasingBuildConfigurationsonConfigurationFiles.html&quot;&gt;xcconfig&lt;/a&gt;，这个官方文档上面也提到的不是很详细，在网上寻找了一下，倒是找到了另外一份详细非官方文档。&lt;a href=&quot;http://pewpewthespells.com/blog/xcconfig_guide.html#CondVarSDK&quot;&gt;The Unofficial Guide to xcconfig files&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;提到xcconfig，就要先说说几个概念。&lt;/p&gt;

&lt;h5 id=&quot;section-5&quot;&gt;1. 区分几个概念&lt;/h5&gt;
&lt;p&gt;先来区分一下Xcode Workspace、Xcode Scheme、Xcode Project、Xcode Target、Build Settings 这5者的关系。这5者的关系在苹果官方文档上其实都已经说明的很清楚了。详情见文档&lt;a href=&quot;https://developer.apple.com/library/ios/featuredarticles/XcodeConcepts/Concept-Targets.html&quot;&gt;Xcode Concepts&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;我来简单来解读一下文档。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Xcode Workspace&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A workspace is an Xcode document that groups projects and other documents so you can work on them together. A workspace can contain any number of Xcode projects, plus any other files you want to include. In addition to organizing all the files in each Xcode project, a workspace provides implicit and explicit relationships among the included projects and their targets.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;workspace这个概念大家应该都很清楚了。它可以包含多个Project和其他文档文件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Xcode Project&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;An Xcode project is a repository for all the files, resources, and information required to build one or more software products. A project contains all the elements used to build your products and maintains the relationships between those elements. It contains one or more targets, which specify how to build products. A project defines default build settings for all the targets in the project (each target can also specify its own build settings, which override the project build settings).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;project就是一个个的仓库，里面会包含属于这个项目的所有文件，资源，以及生成一个或者多个软件产品的信息。每一个project会包含一个或者多个 targets，而每一个 target 告诉我们如何生产 products。project 会为所有 targets 定义了默认的 build settings，每一个 target 也能自定义自己的 build settings，且 target 的 build settings 会重写 project 的 build settings。&lt;/p&gt;

&lt;p&gt;最后这句话比较重要，下面设置xcconfig的时候就会用到这一点。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-3175b62b1a46caad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Xcode Project 文件会包含以下信息，对资源文件的引用(源码.h和.m文件，frame，资源文件plist，bundle文件等，图片文件image.xcassets还有Interface Builder(nib)，storyboard文件)、文件结构导航中用来组织源文件的组、Project-level build configurations(Debug\Release)、Targets、可执行环境，该环境用于调试或者测试程序。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Xcode Target&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A target specifies a product to build and contains the instructions for building the product from a set of files in a project or workspace. A target defines a single product; it organizes the inputs into the build system—the source files and instructions for processing those source files—required to build that product. Projects can contain one or more targets, each of which produces one product.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;target 会有且唯一生成一个 product, 它将构建该 product 所需的文件和处理这些文件所需的指令集整合进 build system 中。Projects 会包含一个或者多个 targets,每一个 target 将会产出一个 product。&lt;/p&gt;

&lt;p&gt;这里值得说明的是，每个target 中的 build setting 参数继承自 project 的 build settings, 一旦你在 target 中修改任意 settings 来重写 project settings，那么最终生效的 settings 参数以在 target 中设置的为准. Project 可以包含多个 target, 但是在同一时刻，只会有一个 target 生效，可用 Xcode 的 scheme 来指定是哪一个 target 生效。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Build Settings&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A build setting is a variable that contains information about how a particular aspect of a product’s build process should be performed. For example, the information in a build setting can specify which options Xcode passes to the compiler.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;build setting 中包含了 product 生成过程中所需的参数信息。project的build settings会对于整个project 中的所有targets生效，而target的build settings是重写了Project的build settings，重写的配置以target为准。&lt;/p&gt;

&lt;p&gt;一个 build configaration 指定了一套 build settings 用于生成某一 target 的 product，例如Debug和Release就属于build configaration。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Xcode Scheme&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;An Xcode scheme defines a collection of targets to build, a configuration to use when building, and a collection of tests to execute.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一个Scheme就包含了一套targets(这些targets之间可能有依赖关系)，一个configuration，一套待执行的tests。&lt;/p&gt;

&lt;p&gt;这5者的关系，举个可能不恰当的例子，
Xcode Workspace就如同工厂，Xcode Project如同车间，每个车间可以独立于工厂来生产产品(project可独立于workspace存在)，但是各个车间组合起来就需要工厂来组织(如果用了cocopods，就需要用workspace)。Xcode Target是一条条的流水线，一条流水线上面只生产一种产品。Build Settings是生产产品的秘方，如果是生产汽水，Build Settings就是其中各个原料的配方。Xcode Scheme是生产方案，包含了流水线生产，秘方，还包含生产完成之后的质检(test)。&lt;/p&gt;

&lt;h5 id=&quot;xcconfig&quot;&gt;2. 来创建一个xcconfig文件&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-bbb676bc468f1522.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后创建好了这个文件，我们在project里面设置一下。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-4d0d012da710a3f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在这些地方把配置文件换成我们刚刚新建的文件。&lt;/p&gt;

&lt;p&gt;接下来就要编写我们的xcconfig文件了。这个文件里面可以写的东西挺多的。细心的同学就会发现，其实我们一直使用的cocopods就是用这个文件来配置编译参数的。我们随便看一个简单的cocopods的xcconfig文件，就是下图这样子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
GCC_PREPROCESSOR_DEFINITIONS = $(inherited) COCOAPODS=1
HEADER_SEARCH_PATHS = $(inherited) &quot;${PODS_ROOT}/Headers/Public&quot; &quot;${PODS_ROOT}/Headers/Public/Forms&quot;
OTHER_CFLAGS = $(inherited) -isystem &quot;${PODS_ROOT}/Headers/Public&quot; -isystem &quot;${PODS_ROOT}/Headers/Public/Forms&quot;
OTHER_LDFLAGS = $(inherited) -ObjC -l&quot;Forms&quot;
PODS_ROOT = ${SRCROOT}/Pods
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们由于需要配置网络环境，那可以这样写&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//网络请求baseurl
REQUESTBASE_URL = @&quot;http:\\/\\/10.20.100.1&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当然也可以写成cocopods那样&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GCC_PREPROCESSOR_DEFINITIONS = $(inherited) WEBSERVICE_URL=&#39;$(REQUESTBASE_URL)&#39; MESSAGE_SYSTEM_URL=&#39;$(MESSAGE_SYSTEM_URL)&#39;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里利用了一个GCC_PREPROCESSOR_DEFINITIONS编译参数。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Space-separated list of option specifications. Specifies preprocessor macros in the form foo (for a simple #define) or foo=1 (for a value definition). This list is passed to the compiler through the gcc -D option when compiling precompiled headers and implementation files.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;GCC_PREPROCESSOR_DEFINITIONS 是 GCC 预编译头参数，通常我们可以在 Project 文件下的 Build Settings 对预编译宏定义进行默认赋值。&lt;/p&gt;

&lt;p&gt;它就是在Build Settings里面的 Apple LLVM 7.X - Preprocessing - Preprocessor Macros 这里。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-94666192eecdeb75.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Preprocessor Macros 其实是按照 Configuration 选项进行默认配置的, 它是可以根据不同的环境预先制定不同定义的宏，或者为不同环境下的相同变量定义不同的值。&lt;/p&gt;

&lt;p&gt;xcconfig 我们可以写入不同的 Configuration 选项配置不同的文件。每一个 xcconfig 可以配置 Build Settings 里的属性值, 其实实质就是通过 xcconfig 去修改 GCC_PREPROCESSOR_DEFINITIONS 的值，这样我们就可以做到动态配置环境的需求了。&lt;/p&gt;

&lt;p&gt;最后还需要提的一点是，这个配置文件的level的问题。现在本地有这么多配置，到底哪一个最终生效呢？打开Build 里面的level，我们来看一个例子。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-33b4ba6054123d00.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们目前可以看到有5个配置，他们是有优先级的。优先级是从左往右，依次降低的。Resolved = target-level &amp;gt; project-level &amp;gt; 自定义配置文件 &amp;gt; iOS 默认配置。左边第一列永远显示的是当前生效的最终配置结果。&lt;/p&gt;

&lt;p&gt;知道了这个优先级之后，我们可以更加灵活的配置我们的app了。&lt;/p&gt;

&lt;p&gt;最后关于xcconfig配置，基本使用就这些了。但是这里面的学问不仅仅这些。&lt;/p&gt;

&lt;p&gt;还能利用xcconfig动态配置Build Settings里面的很多参数。这其实类似于cocopods的做法。但是有一个大神的做法很优雅。值得大家感兴趣的人去学习学习。iOS大神&lt;a href=&quot;https://github.com/jspahrsummers&quot;&gt;Justin Spahr-Summers&lt;/a&gt;的开源库&lt;a href=&quot;https://github.com/jspahrsummers/xcconfigs&quot;&gt;xcconfigs&lt;/a&gt;提供了一个类权威的模板, 这是一个很好的学习使用xcconfig的库，强烈推荐。&lt;/p&gt;

&lt;p&gt;最后这里有一个Demo，配置了Cocopods，配置了xcconfig文件，还有Build Configuration的，大家可以看看，请多多指教，&lt;a href=&quot;https://github.com/halfrost/MultiEnvironmentsSettingDemo&quot;&gt;Demo&lt;/a&gt;。&lt;/p&gt;

&lt;h4 id=&quot;targets&quot;&gt;三.利用Targets来配置多环境&lt;/h4&gt;

&lt;p&gt;配置一个多环境其实一个Scheme和xcconfig已经完全够用了，为什么还要有这个第三点呢？虽说仅仅为了配置一个多环境这点“小事”，但是利用多个Targets也能实现需求，只不过有点“兴师动众”了。&lt;/p&gt;

&lt;p&gt;关于构建Targets这个技术，我也是在2年前的公司实践过。当时的需求是做一个OEM的产品。自己公司有主要产品，也帮其他公司做OEM。一说到OEM，大家应该就知道Targets用到这里的妙用了。利用Targets可以瞬间大批量产生大量的app。&lt;/p&gt;

&lt;p&gt;2013年巧哥也发过关于Targets的文章，&lt;a href=&quot;http://blog.devtang.com/2013/10/17/the-tech-detail-of-ape-client-1/&quot;&gt;猿题库iOS客户端的技术细节（一）：使用多target来构建大量相似App&lt;/a&gt;，我原来公司在2014年也实现了这种功能。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-40ecd04a0ed9b2f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;仅仅只用一套代码，就可以生产出7个app。7个app的证书都是不同的，配置也都不同，但是代码只需要维护一套代码，就可以完成维护7个app的目标。&lt;/p&gt;

&lt;p&gt;下面我们来看看怎么新建Targets，有2种方法。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-df956ff180fbef19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一种方法是完全新建一个Targets，另外一种方法是复制原有的Targets。&lt;/p&gt;

&lt;p&gt;其实第一种方法建立出Targets，之后看你需求是怎么样的。如果也想是做OEM这种，可以把新建出来的project删掉，本地还是维护一套代码，然后在新建的Targets 的Build Phases里面去把本地现有代码加上，参数自己可以随意配置。这样也是一套代码维护多个app。&lt;/p&gt;

&lt;p&gt;第二种方法就是复制一个原有的Targets，这种做法只用自己去改参数就可以了。&lt;/p&gt;

&lt;p&gt;再来说说Targets的参数。&lt;/p&gt;

&lt;p&gt;由于我们新建了Targets，相当于新建了一个app了。所以里面的所有的文件全部都可以更改。包括info.plist，源码引用，Build Settings……所有参数都可以改，这样就不仅仅局限于修改Scheme和xcconfig，所以之前说仅仅配置一个多环境用Targets有点兴师动众，但是它确实能完成目的。根据第二章里面我们也提到了，Targets相当于流水线，仅次于Project的地位，可以想象，有了Targets，我们没有什么不能修改的。&lt;/p&gt;

&lt;p&gt;PS.最后关于Targets还有一点想说的，如果大家有多个app，并且这几个app之间有超过80%的代码都是完全一样的，或者说仅仅只是个别界面显示不同，逻辑都完全相同，建议大家用Targets来做，这样只需要维护一套代码就可以了。维护多套相同的代码，实在太没有效率了。一个bug需要在多套代码上面来回改动，费时费力。&lt;/p&gt;

&lt;p&gt;这时候可能有人会问了，如果维护一套代码，以后这些app如果需求有不同怎么办？？比如要进入不同界面，跳转不同界面，页面也显示不同怎么办？？这个问题其实很简单。在Targets里面的&lt;strong&gt;Compile Sources&lt;/strong&gt;里面是可以给每个不同的Targets添加不同的编译代码的。只需要在每个不同的Targets里面加入不同界面的代码进行编译就可以了，在跳转的那个界面加上宏，来控制不同的app跳转到相应界面。这样本地还是维护的一套代码，只不过每个Targets编译的代码就是这套代码的子集了。这样维护起来还是很方便。也实现了不同app不同界面，不同需求了。&lt;/p&gt;

&lt;h4 id=&quot;section-6&quot;&gt;最后&lt;/h4&gt;
&lt;p&gt;其实这篇文章的需求源自于上篇Jenkins自动化持续集成，有一个需求是能打不同环境的包。之前没有Jenkins的时候就改改URL运行一遍就好，虽说做法不够优雅，但是也不麻烦。现在想持续集成，只好把环境都分好，参数配置正确，这样Jenkins可以一次性多个环境的包一起打。真正做到多环境的持续集成。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-83b1d03a7495cfe1.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后就可以打出不同环境的包了。请大家多多指教。&lt;/p&gt;
</description>
        <pubDate>Thu, 11 Aug 2016 09:01:00 +0800</pubDate>
        <link>http://vno.onevcat.com/2016/08/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E7%BB%99%E4%B8%80%E4%B8%AAiOS-app%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AA%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</link>
        <guid isPermaLink="true">http://vno.onevcat.com/2016/08/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E7%BB%99%E4%B8%80%E4%B8%AAiOS-app%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AA%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</guid>
        
        <category>iOS</category>
        
        
        <category>Blog</category>
        
      </item>
    
      <item>
        <title>手把手教你利用Jenkins持续集成iOS项目</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-6a6d55579dcbe2d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;前言&lt;/h4&gt;
&lt;p&gt;众所周知，现在App的竞争已经到了用户体验为王，质量为上的白热化阶段。用户们都是很挑剔的。如果一个公司的推广团队好不容易砸了重金推广了一个APP，好不容易有了一些用户，由于一次线上的bug导致一批的用户在使用中纷纷出现闪退bug，轻则，很可能前期推广砸的钱都白费了，重则，口碑不好，未来也提升不起用户量来了。静下心来分析一下问题的原因，无外乎就是质量没有过关就上线了。除去主观的一些因素，很大部分的客观因素我觉得可以被我们防范的。根据大神们提出的一套开发规范建议，CI + FDD，就可以帮助我们极大程度的解决客观因素。本文接下来主要讨论 &lt;a href=&quot;http://martinfowler.com/articles/continuousIntegration.html&quot;&gt;Continuous Integration&lt;/a&gt; 持续集成（简称CI）&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;目录&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;1.为什么我们需要持续集成&lt;/li&gt;
  &lt;li&gt;2.持续化集成工具——Jenkins&lt;/li&gt;
  &lt;li&gt;3.iOS自动化打包命令——xcodebuild + xcrun 和 fastlane - gym 命令&lt;/li&gt;
  &lt;li&gt;4.打包完成自动化上传 fir / 蒲公英 第三方平台&lt;/li&gt;
  &lt;li&gt;5.完整的持续集成流程&lt;/li&gt;
  &lt;li&gt;6.Jenkins + Docker&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-2&quot;&gt;一. 为什么我们需要持续集成&lt;/h4&gt;
&lt;p&gt;谈到为什么需要的问题，我们就需要从什么是来说起。那什么是持续集成呢。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;持续集成是一种软件开发实践：许多团队频繁地集成他们的工作，每位成员通常进行日常集成，进而每天会有多种集成。每个集成会由自动的构建（包括测试）来尽可能快地检测错误。许多团队发现这种方法可以显著的减少集成问题并且可以使团队开发更加快捷。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;CI是一种开发实践。实践应该包含3个基本模块，一个可以自动构建的过程，自动编译代码，可以自动分发，部署和测试。一个代码仓库，SVN或者Git。最后一个是一个持续集成的服务器。通过持续集成，可以让我们通过自动化等手段高频率地去获取产品反馈并响应反馈的过程。&lt;/p&gt;

&lt;p&gt;那么持续集成能给我们带来些什么好处呢？这里推荐一篇&lt;a href=&quot;http://apiumtech.com/blog/top-benefits-of-continuous-integration-2/&quot;&gt;文章&lt;/a&gt;，文章中把&lt;a href=&quot;http://apiumtech.com/blog/top-benefits-of-continuous-integration-2/&quot;&gt;Continuous integration&lt;/a&gt; (CI) and &lt;a href=&quot;http://apiumtech.com/blog/20-benefits-of-test-driven-development/&quot;&gt;test-driven development&lt;/a&gt; (TDD)分成了12个步骤。然而带来的好处成倍增加，有24点好处。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-420f52f842539d5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我来说说用了CI以后带来的一些深有体会的优点。&lt;/p&gt;

&lt;h5 id=&quot;section-3&quot;&gt;1. 缩减开发周期，快速迭代版本&lt;/h5&gt;
&lt;p&gt;每个版本开始都会估算好开发周期，但是总会因为各种事情而延期。这其中包括了一些客观因素。由于产品线增多，迭代速度越来越快，给测试带来的压力也越来越大。如果测试都在开发完全开发完成之后再来测试，那就会影响很长一段时间。这时候由于集成晚就会严重拖慢项目节奏。如果能尽早的持续集成，尽快进入上图的12步骤的迭代环中，就可以尽早的暴露出问题，提早解决，尽量在规定时间内完成任务。&lt;/p&gt;

&lt;h5 id=&quot;section-4&quot;&gt;2. 自动化流水线操作带来的高效&lt;/h5&gt;
&lt;p&gt;其实打包对于开发人员来说是一件很耗时，而且没有很大技术含量的工作。如果开发人员一多，相互改的代码冲突的几率就越大，加上没有产线管理机制，代码仓库的代码质量很难保证。团队里面会花一些时间来解决冲突，解决完了冲突还需要自己手动打包。这个时候如果证书又不对，又要耽误好长时间。这些时间其实可以用持续集成来节约起来的。一天两天看着不多，但是按照年的单位来计算，可以节约很多时间！&lt;/p&gt;

&lt;h5 id=&quot;section-5&quot;&gt;3. 随时可部署&lt;/h5&gt;
&lt;p&gt;有了持续集成以后，我们可以以天为单位来打包，这种高频率的集成带来的最大的优点就是可以随时部署上线。这样就不会导致快要上线，到处是漏洞，到处是bug，手忙脚乱弄完以后还不能部署，严重影响上线时间。&lt;/p&gt;

&lt;h5 id=&quot;section-6&quot;&gt;4. 极大程度避免低级错误&lt;/h5&gt;
&lt;p&gt;我们可以犯错误，但是犯低级错误就很不应该。这里指的低级错误包括以下几点：编译错误，安装问题，接口问题，性能问题。
以天为单位的持续集成，可以很快发现编译问题，自动打包直接无法通过。打完包以后，测试扫码无法安装，这种问题也会立即被暴露出来。接口问题和性能问题就有自动化测试脚本来发现。这些低级问题由持续集成来暴露展现出来，提醒我们避免低级错误。&lt;/p&gt;

&lt;h4 id=&quot;jenkins&quot;&gt;二. 持续化集成工具——Jenkins&lt;/h4&gt;

&lt;p&gt;Jenkins 是一个开源项目，提供了一种易于使用的持续集成系统，使开发者从繁杂的集成中解脱出来，专注于更为重要的业务逻辑实现上。同时 Jenkins 能实施监控集成中存在的错误，提供详细的日志文件和提醒功能，还能用图表的形式形象地展示项目构建的趋势和稳定性。&lt;/p&gt;

&lt;p&gt;根据官方定义，Jenkins有以下的用途：
1. 构建项目
2. 跑测试用例检测bug
3. 静态代码检测
4. 部署&lt;/p&gt;

&lt;p&gt;关于这4点，实际使用中还是比较方便的：
1.构建项目自动化打包可以省去开发人员好多时间，重要的是，Jenkins为我们维护了一套高质量可用的代码，而且保证了一个纯净的环境。我们经常会出现由于本地配置出错而导致打包失败的情况。现在Jenkins就是一个公平的评判者，它无法正确的编译出ipa，那就是有编译错误或者配置问题。开发人员没必要去争论本地是可以运行的，拉取了谁谁谁的代码以后就不能运行了。共同维护Jenkins的正常编译，因为Jenkins的编译环境比我们本地简单的多，它是最纯净无污染的编译环境。开发者就只用专注于编码。这是给开发者带来的便利。&lt;/p&gt;

&lt;p&gt;2.这个可以用来自动化测试。在本地生成大批的测试用例。每天利用服务器不断的跑这些用例。每天每个接口都跑一遍。看上去没必要，但是实际上今天运行正常的系统，很可能由于今天的代码改动，明天就出现问题了。有了Jenkins可以以天为单位的进行回归测试，代码只要有改动，Jenkins就把所有的回归测试的用例全部都跑一遍。在项目工期紧张的情况下，很多情况测试都不是很重视回归测试，毕竟很可能测一遍之后是徒劳的“无用功”。然而由于回归测试不及时，就导致到最后发版的时候系统不可用了，这时候回头查找原因是比较耗时的，查看提交记录，看到上百条提交记录，排查起来也是头疼的事情。以天为单位的回归测试能立即发现问题。测试人员每天可以专注按单元测试，一周手动一次回归测试。这是给测试者带来的便利。&lt;/p&gt;

&lt;p&gt;3.这个是静态代码分析，可以检测出很多代码的问题，比如潜在的内存泄露的问题。由于Jenkins所在环境的纯净，还是可以发现一些我们本地复杂环境无法发现的问题，进一步的提高代码质量。这是给质检带来的便利。&lt;/p&gt;

&lt;p&gt;4.随时部署。Jenkins在打包完成之后可以设定之后的操作，这个时候往往就是提交app到跑测试用例的系统，或者部署到内测平台生成二维码。部署中不能安装等一些低级问题随之立即暴露。测试人员也只需要扫一下二维码即可安装，很方便。这也算是给测试带来的便利。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-9c822836315163c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;以下的例子以2016-07-24 22:35的Weekly Release 2.15的版本为例。&lt;/p&gt;

&lt;p&gt;我们来开始安装Jenkins。从官网https://jenkins.io/ 上下载最新的pkg安装包。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-6a2c3d6d42f35d31.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-75539c56443392df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-126a68ae31c21e6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-1a24ed942db2a9d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-179ec0017a364cc5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-982058c2d4701b31.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;也可以下载jenkins.war, 然后运行Java -jar jenkins.war，进行安装。&lt;/p&gt;

&lt;p&gt;安装完成之后，Safari可能会自动打开，如果没有自动打开，打开浏览器，输入http://localhost:8080&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-086f6fe08841b673.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个时候可能会报一个错误。如果出现了这面的问题。出现这个问题的原因就是Java环境有问题，重新Java环境即可。&lt;/p&gt;

&lt;p&gt;这个时候如果你重启电脑会发现Jenkins给你新增了一个用户，名字就叫Jenkins，不过这个时候你不知道密码。你可能会去试密码，肯定是是不对的，因为初始密码很复杂。这个时候正确做法是打开http://localhost:8080 会出现下图的重设初始密码的界面。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-c8468fd91737f725.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;按照提示，找到/Users/Shared/Jenkins/Home/ 这个目录下，这个目录虽然是共享目录，但是有权限的，非Jenkins用户/secrets/目录是没有读写权限的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-1d3da60f2fb25127.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-ad7089207c1a3dcd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;打开initialAdminPassword文件，复制出密码，就可以填到网页上去重置密码了。如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-0bb3a8b2025ab014.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-cd9979b853d14ac6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-56431c2d22013dcd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-578857333787630a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-a5636c896f987a50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-f4e6e0284534291b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-7ac78a54760114dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一路安装过来，输入用户名，密码，邮件这些，就算安装完成了。&lt;/p&gt;

&lt;p&gt;还是继续登录localhost:8080  ，选择“系统管理”——“管理插件”，我们要先安装一些辅助插件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;安装GitLab插件&lt;/strong&gt;
因为我们用的是GitLab来管理源代码，Jenkins本身并没有自带GitLab插件，所以我们需要依次选择 &lt;strong&gt;系统管理&lt;/strong&gt;-&amp;gt;&lt;strong&gt;管理插件&lt;/strong&gt;，在“&lt;strong&gt;可选插件&lt;/strong&gt;”中选中“&lt;strong&gt;GitLab Plugin&lt;/strong&gt;”和“&lt;strong&gt;Gitlab Hook Plugin&lt;/strong&gt;”这两项，然后安装。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;安装Xcode插件&lt;/strong&gt;
同安装GitLab插件的步骤一样，我们依次选择&lt;strong&gt;系统管理&lt;/strong&gt;-&amp;gt;&lt;strong&gt;管理插件&lt;/strong&gt;，在“&lt;strong&gt;可选插件&lt;/strong&gt;”中选中“&lt;strong&gt;Xcode integration&lt;/strong&gt;”安装。&lt;/p&gt;

&lt;p&gt;安装完了这个，我们就可以配置一个构建项目了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-06d0118a5e04dadf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-b52d3d102c21f004.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击新建好的项目，进来配置一下&lt;strong&gt;General&lt;/strong&gt;参数。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-cc08dd2e01f3e230.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里可以设置包的保留天数还有天数。&lt;/p&gt;

&lt;p&gt;接着设置&lt;strong&gt;源码管理&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;由于现在我用到的是GitLab，先配置SSH Key，在Jenkins的证书管理中添加SSH。在Jenkins管理页面，选择“&lt;strong&gt;Credentials&lt;/strong&gt;”，然后选择“&lt;strong&gt;Global credentials (unrestricted)&lt;/strong&gt;”，点击“&lt;strong&gt;Add Credentials&lt;/strong&gt;”，如下图所示，我们填写自己的SSH信息，然后点击“&lt;strong&gt;Save&lt;/strong&gt;”，这样就把SSH添加到Jenkins的全局域中去了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-6d1b6f56e4dac318.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果正常的配置正确的话，是不会出现下图中的那段红色的警告。如果有下图的提示，就说明Jenkins还没有连通GitLab或者SVN，那就请再检查SSH Key是否配置正确。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-268313680eb7a9ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;构建触发器设置&lt;/strong&gt;这里是设置自动化测试的地方。这里涉及的内容很多，暂时我也没有深入研究，这里暂时先不设置。有自动化测试需求的可以好好研究研究这里的设置。&lt;/p&gt;

&lt;p&gt;不过这里有两个配置还是需要是配置的&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Poll SCM&lt;/strong&gt;  (poll source code management)  轮询源码管理
需要设置源码的路径才能起到轮询的效果。一般设置为类似结果： 0/5 * * * * 每5分钟轮询一次
&lt;strong&gt;Build periodically&lt;/strong&gt; (定时build) 
一般设置为类似： 00 20 * * *   每天 20点执行定时build 。当然两者的设置都是一样可以通用的。&lt;/p&gt;

&lt;p&gt;格式是这样的&lt;/p&gt;

&lt;p&gt;分钟(0-59) 小时(0-23) 日期(1-31) 月(1-12) 周几(0-7,0和7都是周日) &lt;a href=&quot;http://www.scmgalaxy.com/scm/setting-up-the-cron-jobs-in-jenkins-using-build-periodically-scheduling-the-jenins-job.html&quot;&gt;更加详细的设置看这里&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-af09deb5eb53c6f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;构建环境设置&lt;/strong&gt;
iOS打包需要签名文件和证书，所以这部分我们勾选“&lt;strong&gt;Keychains and Code Signing Identities&lt;/strong&gt;”和“&lt;strong&gt;Mobile Provisioning Profiles&lt;/strong&gt;”。
这里我们又需要用到Jenkins的插件，在系统管理页面，选择“&lt;strong&gt;Keychains and Provisioning Profiles Management&lt;/strong&gt;”。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-63ed7bd1daee82fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;进入&lt;strong&gt;Keychains and Provisioning Profiles Management&lt;/strong&gt;页面，点击“&lt;strong&gt;浏览&lt;/strong&gt;”按钮，分别上传自己的keychain和证书。上传成功后，我们再为keychain指明签名文件的名称。点击“&lt;strong&gt;Add Code Signing Identity&lt;/strong&gt;”，最后添加成功后如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-7fcfb1bcd4543907.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;
注意：我第一次导入证书和Provisioning Profiles文件，就遇到了一点小“坑”，我当时以为是需要证书，但是这里需要的Keychain，并不是cer证书文件。这个Keychain其实在/Users/管理员用户名/Library/keychains/login.keychain,当把这个Keychain设置好了之后，Jenkins会把这个Keychain拷贝到/Users/Shared/Jenkins/Library/keychains这里，(Library是隐藏文件)。Provisioning Profiles文件也直接拷贝到/Users/Shared/Jenkins/Library/MobileDevice文件目录下。&lt;/p&gt;

&lt;p&gt;这样Adhoc证书和签名文件就在Jenkins中配置好了，接下来我们只需要在item设置中指定相关文件即可。
回到我们新建的item，找到&lt;strong&gt;构建环境&lt;/strong&gt;，按下图选好自己的相关证书和签名文件。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-849e17d402c0b8c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接下来在进行&lt;strong&gt;构建&lt;/strong&gt;的设置
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-4ae0a5ae5d914ae8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们这里选择执行一段打包脚本。脚本在下一章节详细的讲解。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;构建后操作&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-0e5e09ad80e0c42b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里我们选择&lt;strong&gt;Execute a set of scripts&lt;/strong&gt;，这里也是一个脚本，这个脚本用来上传自动打包好的ipa文件。脚本在第四章节有详细的讲解。&lt;/p&gt;

&lt;p&gt;至此，我们的Jenkins设置就全部完成了。点击&lt;strong&gt;构建&lt;/strong&gt;，就会开始构建项目了。&lt;/p&gt;

&lt;p&gt;构建一次，各个颜色代表的意义如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-7f2d51581dd7d16a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;天气的晴雨表代表了项目的质量，这也是Jenkins的一个特色。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-4bbbd2b19dea15eb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果构建失败了，可以去查看&lt;strong&gt;Console Output&lt;/strong&gt;可以查看log日志。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-ccd34e26b402960e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;iosxcodebuild--xcrun--fastlane---gym-&quot;&gt;三. iOS自动化打包命令——xcodebuild + xcrun 和 fastlane - gym 命令&lt;/h4&gt;

&lt;p&gt;在日常开发中，打包是最后上线不可缺少的环节，如果需要把工程打包成 ipa 文件，通常的做法就是在 Xcode 里点击 「Product -&amp;gt; Archive」，当整个工程 archive 后，然后在自动弹出的 「Organizer」 中进行选择，根据需要导出 ad hoc，enterprise 类型的 ipa 包。虽然Xcode已经可以很完美的做到打包的事情，但是还是需要我们手动点击5，6下。加上我们现在需要持续集成，用打包命令自动化执行就顺其自然的需要了。&lt;/p&gt;

&lt;h5 id=&quot;xcodebuild--xcrun&quot;&gt;1. xcodebuild + xcrun命令&lt;/h5&gt;

&lt;p&gt;Xcode为我们开发者提供了一套构建打包的命令，就是xcodebuild
和xcrun命令。xcodebuild把我们指定的项目打包成.app文件，xcrun将指定的.app文件转换为对应的.ipa文件。&lt;/p&gt;

&lt;p&gt;具体的文档如下， &lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/xcodebuild.1.html&quot;&gt;xcodebuild官方文档&lt;/a&gt;、&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/xcrun.1.html&quot;&gt;xcrun官方文档&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NAME
xcodebuild – build Xcode projects and workspaces

SYNOPSIS
1. xcodebuild [-project name.xcodeproj] [[-target targetname] … | -alltargets] [-configuration configurationname] [-sdk [sdkfullpath | sdkname]] [action …] [buildsetting=value …] [-userdefault=value …]

2. xcodebuild [-project name.xcodeproj] -scheme schemename [[-destination destinationspecifier] …] [-destination-timeout value] [-configuration configurationname] [-sdk [sdkfullpath | sdkname]] [action …] [buildsetting=value …] [-userdefault=value …]

3. xcodebuild -workspace name.xcworkspace -scheme schemename [[-destination destinationspecifier] …] [-destination-timeout value] [-configuration configurationname] [-sdk [sdkfullpath | sdkname]] [action …] [buildsetting=value …] [-userdefault=value …]

4. xcodebuild -version [-sdk [sdkfullpath | sdkname]] [infoitem]

5. xcodebuild -showsdks

6. xcodebuild -showBuildSettings [-project name.xcodeproj | [-workspace name.xcworkspace -scheme schemename]]

7. xcodebuild -list [-project name.xcodeproj | -workspace name.xcworkspace]

8. xcodebuild -exportArchive -archivePath xcarchivepath -exportPath destinationpath -exportOptionsPlist path

9. xcodebuild -exportLocalizations -project name.xcodeproj -localizationPath path [[-exportLanguage language] …]

10. xcodebuild -importLocalizations -project name.xcodeproj -localizationPath path
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面10个命令最主要的还是前3个。&lt;/p&gt;

&lt;p&gt;接下来来说明一下参数：
-project -workspace：这两个对应的就是项目的名字。如果有多个工程，这里又没有指定，则默认为第一个工程。
-target：打包对应的targets，如果没有指定这默认第一个。
-configuration：如果没有修改这个配置，默认就是Debug和Release这两个版本，没有指定默认为Release版本。
-buildsetting=value …：使用此命令去修改工程的配置。
-scheme：指定打包的scheme。&lt;/p&gt;

&lt;p&gt;上面这些是最最基本的命令。&lt;/p&gt;

&lt;p&gt;上面10个命令的第一个和第二个里面的参数，其中 -target
 和 -configuration 参数可以使用 xcodebuild -list
获得，-sdk 参数可由 xcodebuild -showsdks
 获得，[buildsetting=value …] 用来覆盖工程中已有的配置。可覆盖的参数参考官方文档 &lt;a href=&quot;https://developer.apple.com/documentation/DeveloperTools/Reference/XcodeBuildSettingRef/&quot;&gt;Xcode Build Setting Reference&lt;/a&gt;。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;build
Build the target in the build root (SYMROOT). This is the default action, and is used if no action is given.

analyze
Build and analyze a target or scheme from the build root (SYMROOT). This requires specifying a scheme.

archive
Archive a scheme from the build root (SYMROOT). This requires specifying a scheme.

test
Test a scheme from the build root (SYMROOT). This requires specifying a scheme and optionally a destination.

installsrc
Copy the source of the project to the source root (SRCROOT).

install
Build the target and install it into the target’s installation directory in the distribution root (DSTROOT).

clean
Remove build products and intermediate files from the build root (SYMROOT).

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面第3个命令就是专门用来打带有Cocopods的项目，因为这个时候项目工程文件不再是xcodeproj了，而是变成了xcworkspace了。&lt;/p&gt;

&lt;p&gt;再来说说xcrun命令。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Usage:
PackageApplication [-s signature] application [-o output_directory] [-verbose] [-plugin plugin] || -man || -help

Options:

[-s signature]: certificate name to resign application before packaging
[-o output_directory]: specify output filename
[-plugin plugin]: specify an optional plugin
-help: brief help message
-man: full documentation
-v[erbose]: provide details during operation

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;参数不多，使用方法也很简单，xcrun -sdk iphoneos -v PackageApplication  + 上述一些参数。&lt;/p&gt;

&lt;p&gt;参数都了解之后，我们就来看看该如何用了。下面这个是使用了xcodebuild + xcrun命令写的自动化打包脚本&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 工程名
APP_NAME=&quot;YourProjectName&quot;
# 证书
CODE_SIGN_DISTRIBUTION=&quot;iPhone Distribution: Shanghai ******* Co., Ltd.&quot;
# info.plist路径
project_infoplist_path=&quot;./${APP_NAME}/Info.plist&quot;

#取版本号
bundleShortVersion=$(/usr/libexec/PlistBuddy -c &quot;print CFBundleShortVersionString&quot; &quot;${project_infoplist_path}&quot;)

#取build值
bundleVersion=$(/usr/libexec/PlistBuddy -c &quot;print CFBundleVersion&quot; &quot;${project_infoplist_path}&quot;)

DATE=&quot;$(date +%Y%m%d)&quot;
IPANAME=&quot;${APP_NAME}_V${bundleShortVersion}_${DATE}.ipa&quot;

#要上传的ipa文件路径
IPA_PATH=&quot;$HOME/${IPANAME}&quot;
echo ${IPA_PATH}
echo &quot;${IPA_PATH}&quot;&amp;gt;&amp;gt; text.txt

//下面2行是没有Cocopods的用法
echo &quot;=================clean=================&quot;
xcodebuild -target &quot;${APP_NAME}&quot;  -configuration &#39;Release&#39; clean

echo &quot;+++++++++++++++++build+++++++++++++++++&quot;
xcodebuild -target &quot;${APP_NAME}&quot; -sdk iphoneos -configuration &#39;Release&#39; CODE_SIGN_IDENTITY=&quot;${CODE_SIGN_DISTRIBUTION}&quot; SYMROOT=&#39;$(PWD)&#39;

//下面2行是集成有Cocopods的用法
echo &quot;=================clean=================&quot;
xcodebuild -workspace &quot;${APP_NAME}.xcworkspace&quot; -scheme &quot;${APP_NAME}&quot;  -configuration &#39;Release&#39; clean

echo &quot;+++++++++++++++++build+++++++++++++++++&quot;
xcodebuild -workspace &quot;${APP_NAME}.xcworkspace&quot; -scheme &quot;${APP_NAME}&quot; -sdk iphoneos -configuration &#39;Release&#39; CODE_SIGN_IDENTITY=&quot;${CODE_SIGN_DISTRIBUTION}&quot; SYMROOT=&#39;$(PWD)&#39;

xcrun -sdk iphoneos PackageApplication &quot;./Release-iphoneos/${APP_NAME}.app&quot; -o ~/&quot;${IPANAME}&quot;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;gym-&quot;&gt;2. gym 命令&lt;/h5&gt;
&lt;p&gt;说到gym，就要先说一下fastlane。
fastlane是一套自动化打包的工具集，用 Ruby 写的，用于 iOS 和 Android 的自动化打包和发布等工作。gym是其中的打包命令。&lt;/p&gt;

&lt;p&gt;fastlane 的官网看&lt;a href=&quot;https://fastlane.tools/&quot;&gt;这里&lt;/a&gt;, fastlane 的 github 看&lt;a href=&quot;https://github.com/fastlane/fastlane&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;要想使用gym，先要安装fastlane。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo gem install fastlane --verbose
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;fastlane包含了我们日常编码之后要上线时候进行操作的所有命令。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;deliver：上传屏幕截图、二进制程序数据和应用程序到AppStore
snapshot：自动截取你的程序在每个设备上的图片
frameit：应用截屏外添加设备框架
pem：可以自动化地生成和更新应用推送通知描述文件
sigh：生成下载开发商店的配置文件
produce：利用命令行在iTunes Connect创建一个新的iOS app
cert：自动创建iOS证书
pilot：最好的在终端管理测试和建立的文件
boarding：很容易的方式邀请beta测试
gym：建立新的发布的版本，打包
match：使用git同步你成员间的开发者证书和文件配置
scan：在iOS和Mac app上执行测试用例
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;整个发布过程可以用fastlane描述成下面这样&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;lane :appstore do
  increment_build_number
  cocoapods
  xctool
  snapshot
  sigh
  deliver
  frameit
  sh &quot;./customScript.sh&quot;

  slack
end

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Ps：这里可能大家还会听过一个命令叫 &lt;a href=&quot;https://github.com/facebook/xctool&quot;&gt;xctool&lt;/a&gt;
xctool是官方xcodebuild命令的一个增强实现，输出的内容比xcodebuild直观可读得多。通过brew即可安装。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;brew install xctool
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;使用gym自动化打包，&lt;a href=&quot;https://github.com/xilin/ios-build-script/blob/master/build_using_gym.sh&quot;&gt;脚本&lt;/a&gt;如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#计时

SECONDS=0

#假设脚本放置在与项目相同的路径下

project_path=$(pwd)

#取当前时间字符串添加到文件结尾

now=$(date +&quot;%Y_%m_%d_%H_%M_%S&quot;)

#指定项目的scheme名称

scheme=&quot;DemoScheme&quot;

#指定要打包的配置名

configuration=&quot;Adhoc&quot;

#指定打包所使用的输出方式，目前支持app-store, package, ad-hoc, enterprise, development, 和developer-id，即xcodebuild的method参数

export_method=&#39;ad-hoc&#39;

#指定项目地址

workspace_path=&quot;$project_path/Demo.xcworkspace&quot;

#指定输出路径

output_path=&quot;/Users/your_username/Documents/&quot;

#指定输出归档文件地址

archive_path=&quot;$output_path/Demo_${now}.xcarchive&quot;

#指定输出ipa地址

ipa_path=&quot;$output_path/Demo_${now}.ipa&quot;

#指定输出ipa名称

ipa_name=&quot;Demo_${now}.ipa&quot;

#获取执行命令时的commit message

commit_msg=&quot;$1&quot;

#输出设定的变量值

echo &quot;===workspace path: ${workspace_path}===&quot;

echo &quot;===archive path: ${archive_path}===&quot;

echo &quot;===ipa path: ${ipa_path}===&quot;

echo &quot;===export method: ${export_method}===&quot;

echo &quot;===commit msg: $1===&quot;

#先清空前一次build

gym --workspace ${workspace_path} --scheme ${scheme} --clean --configuration ${configuration} --archive_path ${archive_path} --export_method ${export_method} --output_directory ${output_path} --output_name ${ipa_name}

#输出总用时

echo &quot;===Finished. Total time: ${SECONDS}s===&quot;


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;fir---&quot;&gt;四. 打包完成自动化上传 fir / 蒲公英 第三方平台&lt;/h4&gt;

&lt;p&gt;要上传到 fir / 蒲公英 第三方平台，都需要注册一个账号，获得token，之后才能进行脚本化操作。&lt;/p&gt;

&lt;h5 id=&quot;fir&quot;&gt;1. 自动化上传fir&lt;/h5&gt;
&lt;p&gt;安装fir-clifir的命令行工具
需要先装好ruby再执行&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gem install fir-cli
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#上传到fir
fir publish ${ipa_path} -T fir_token -c &quot;${commit_msg}&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;section-7&quot;&gt;2.自动化上传蒲公英&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#蒲公英上的User Key
uKey=&quot;7381f97070*****c01fae439fb8b24e&quot;
#蒲公英上的API Key
apiKey=&quot;0b27b5c145*****718508f2ad0409ef4&quot;
#要上传的ipa文件路径
IPA_PATH=$(cat text.txt)

rm -rf text.txt

#执行上传至蒲公英的命令
echo &quot;++++++++++++++upload+++++++++++++&quot;
curl -F &quot;file=@${IPA_PATH}&quot; -F &quot;uKey=${uKey}&quot; -F &quot;_api_key=${apiKey}&quot; http://www.pgyer.com/apiv1/app/upload
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-8&quot;&gt;五. 完整的持续集成流程&lt;/h4&gt;

&lt;p&gt;经过上面的持续化集成，现在我们就拥有了如下完整持续集成的流程&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-60e101c4e6cc14fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;jenkins--docker&quot;&gt;六. Jenkins + Docker&lt;/h4&gt;

&lt;p&gt;关于Jenkins的部署，其实是分以下两种：
单节点（Master）部署
这种部署适用于大多数项目，其构建任务较轻，数量较少，单个节点就足以满足日常开发所需。
多节点(Master-Slave)部署
通常规模较大，代码提交频繁（意味着构建频繁），自动化测试压力较大的项目都会采取这种部署结构。在这种部署结构下，Master通常只充当管理者的角色，负责任务的调度，slave节点的管理，任务状态的收集等工作，而具体的构建任务则会分配给slave节点。一个Master节点理论上可以管理的slave节点数是没有上限的，但通常随着数量的增加，其性能以及稳定性就会有不同程度的下降，具体的影响则因Master硬件性能的高低而不同。&lt;/p&gt;

&lt;p&gt;但是多节点部署又会有一些缺陷，当测试用例变得海量以后，会造成一些问题，于是有人设计出了下面这种部署结构，Jenkins + Docker&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-71ccde99201bf290.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由于笔者现在的项目还处于单节点（Master）部署，关于多节点(Master-Slave)部署也没有实践经验，改进版本的Docker更是没有接触过，但是如果有这种海量测试用例，高压力的大量复杂的回归测试的需求的，那推荐大家看这篇&lt;a href=&quot;http://www.zjbonline.com/2016/03/05/Jenkins-Docker%E6%90%AD%E5%BB%BA%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83/&quot;&gt;文章&lt;/a&gt;。&lt;/p&gt;

&lt;h4 id=&quot;section-9&quot;&gt;最后&lt;/h4&gt;

&lt;p&gt;以上就是我关于Jenkins持续集成的一次实践经验。分享给大家，如果里面有什么错误，欢迎大家多多指教。&lt;/p&gt;
</description>
        <pubDate>Sun, 31 Jul 2016 15:04:00 +0800</pubDate>
        <link>http://vno.onevcat.com/2016/07/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%88%A9%E7%94%A8Jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90iOS%E9%A1%B9%E7%9B%AE/</link>
        <guid isPermaLink="true">http://vno.onevcat.com/2016/07/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%88%A9%E7%94%A8Jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90iOS%E9%A1%B9%E7%9B%AE/</guid>
        
        <category>iOS</category>
        
        
        <category>Blog</category>
        
      </item>
    
      <item>
        <title>关于IB_DESIGNABLE / IBInspectable的那些需要注意的事</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-0c431c95e1f76510.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;前言&lt;/h4&gt;

&lt;p&gt;IB_DESIGNABLE / IBInspectable 这两个关键字是在WWDC 2014年”What’s New in Interface Builder”这个Session里面，用Swift讲过一个例子。也是随着Xcode 6 新加入的关键字。&lt;/p&gt;

&lt;p&gt;这两个关键字是用在我们自定义View上的，&lt;strong&gt;目前暂时只能用在UIView的子类中&lt;/strong&gt;所以系统自带的原生的那些控件使用这个关键字都没有效果。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Live RenderingYou can use two different attributes—@IBDesignable and @IBInspectable—to enable live, interactive custom view design in Interface Builder. When you create a custom view that inherits from the UIView class or the NSView class, you can add the @IBDesignable attribute just before the class declaration. After you add the custom view to Interface Builder (by setting the custom class of the view in the inspector pane), Interface Builder renders your view in the canvas.You can also add the @IBInspectable attribute to properties with types compatible with user defined runtime attributes. After you add your custom view to Interface Builder, you can edit these properties in the inspector.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其大意就是说，“所见即所得”的思想，我们可以将自定义的代码实时渲染到Interface Builder中。而它们之间的桥梁就是通过两个指令来完成，即@IBDesignable和@IBInspectable。我们通过@IBDesignable告诉Interface Builder这个类可以实时渲染到界面中，无论我们drawRect里面多么复杂，自定义有多复杂，Xib / Storyboard都可以把它编译出来，并且渲染展示出来。但是这个类必须是UIView或者NSView的子类。通过@IBInspectable可以定义动态属性，即可在Attributes inspector面板中可视化修改属性值。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; @IBInspectable var integer: Int = 0
 @IBInspectable var float: CGFloat = 0
 @IBInspectable var double: Double = 0
 @IBInspectable var point: CGPoint = CGPointZero
 @IBInspectable var size: CGSize = CGSizeZero
 @IBInspectable var customFrame: CGRect = CGRectZero
 @IBInspectable var color: UIColor = UIColor.clearColor()
 @IBInspectable var string: String = &quot;&quot;
 @IBInspectable var bool: Bool = false
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-19b37e597b722379.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这两个关键字不是今天的重点，看个Demo就会使用了。
&lt;a href=&quot;https://github.com/halfrost/CircleSlider&quot;&gt;Demo地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如果想看Session的话，可以看这两个WWDC 2014的链接&lt;br /&gt;
&lt;a href=&quot;http://devstreaming.apple.com/videos/wwdc/2014/401xxfkzfrjyb93/401/401_whats_new_in_xcode_6.pdf?dl=1&quot;&gt;whats_new_in_xcode_6&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://devstreaming.apple.com/videos/wwdc/2014/411xx0xo98zzoor/411/411_whats_new_in_interface_builder.pdf?dl=1&quot;&gt;whats_new_in_interface_builder&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://developer.apple.com/library/ios/recipes/xcode_help-IB_objects_media/Chapters/CreatingaLiveViewofaCustomObject.html#//apple_ref/doc/uid/TP40014224-CH41-SW1&quot;&gt;苹果官方文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;今天来分享一下我使用这两个关键字的时候遇到的一些问题和解决过程。&lt;/p&gt;

&lt;h4 id=&quot;the-agent-raised-a-nsinternalinconsistencyexception-exception&quot;&gt;1.The agent raised a “NSInternalInconsistencyException” exception&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 
file://BottomCommentView-master/BottomCommentView/Base.lproj/Main.storyboard: error: 
IB Designables: Failed to update auto layout status: The agent raised a &quot;NSInternalInconsistencyException&quot; exception: Could not load NIB in bundle: &#39;NSBundle &amp;lt;/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/Library/Xcode/Overlays&amp;gt; (loaded)&#39; with name &#39;BottomCommentView&#39;

file://BottomCommentView/Base.lproj/Main.storyboard: error:
 IB Designables: Failed to render instance of BottomCommentView: The agent threw an exception.   
 

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们会看到面板上Designables这里显示的是一个Crashed，Xib / Storyboard 居然也会Crashed！整个app是跑起来了，但是报了2个错，不能忍！这两个错其实是编译时候Xib报的错误，并不是运行时的错误。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-548c7e2d005a5da0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当我们看到Debug的时候，肯定第一想到的就是点Debug。但是很不幸的是，在这种情况下，点击Debug，每次都会告诉你“Finishing debugging instance of XXXX for interface Builder”，即使你在你自定义的View里面打了断点，也无济于事。&lt;/p&gt;

&lt;p&gt;回到问题上来，我们来仔细看看崩溃信息。信息上说Could not load NIB in bundle，并且还给了我们一个类似地址一样的东西’NSBundle &amp;lt;/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/Library/Xcode/Overlays&amp;gt; (loaded)’，我们可以定位到时Xib在从bundle中读取出来出错了。&lt;/p&gt;

&lt;p&gt;通过在网上查找资料，问题其实是这样的。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;When loading the nib, we’re relying on the fact that passing bundle: nil defaults to your app’s mainBundle at run time.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;每次我们取mainBundle的时候，都是用的默认的方法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let nib = UINib(nibName: String(StripyView), bundle: nil)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里在Xib / Storyboard 编译的时候，我们需要告诉iOS系统，我们要指定哪一个bundle类去读取。把上面的代码改成下面这样就可以了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let bundle = NSBundle(forClass: self.dynamicType)
let nib = UINib(nibName: String(StripyView), bundle: bundle)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;或者这样&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#if TARGET_INTERFACE_BUILDER
        NSBundle *bundle = [NSBundle bundleForClass:[self class]];
        [bundle loadNibNamed:@&quot;BottomCommentView&quot; owner:self options:nil];
#else
        [[NSBundle mainBundle] loadNibNamed:@&quot;BottomCommentView&quot; owner:self options:nil];
        
#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Ps:如果你自定义的View不显示在Xib / Storyboard上，但是程序一运行就又能显示出View来，原因也有可能是这个原因，虽然Xib / Storyboard没有报错，因为app没有运行起来，Xib / Storyboard并不知道上下文，所以没有把我们自定义的View加载出来。&lt;/p&gt;

&lt;h4 id=&quot;xib&quot;&gt;2.代码或者Xib依旧不显示自定义控件的样子&lt;/h4&gt;

&lt;p&gt;如果你按照上面的第一个问题里面加上了bundle的代码之后还是不显示，那可能是你代码加的地方不对。&lt;/p&gt;

&lt;p&gt;如果是代码手动创建控件的话，会调用initWithFrame方法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
- (instancetype)initWithFrame:(CGRect)frame
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果是通过Xib / Storyboard 拖拽显示控件的话，会调用initWithCoder方法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
- (instancetype)initWithCoder:(NSCoder *)aDecoder
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;需要在对应的这两个方法里面去加上bundle的方法。如果为了保险起见，那这两个init方法里面都加上问题一里面的代码吧。&lt;/p&gt;

&lt;h4 id=&quot;failed-to-update-auto-layout-status-the-agent-crashed--failed-to-render-instance-of-xxxxxxx-the-agent-crashed&quot;&gt;3.Failed to update auto layout status: The agent crashed / Failed to render instance of XXXXXXX: The agent crashed&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;file://BottomCommentView/Base.lproj/Main.storyboard: error: 
IB Designables: Failed to update auto layout status: The agent crashed

file://BottomCommentView/Base.lproj/Main.storyboard: error: 
IB Designables: Failed to render instance of BottomCommentView: The agent crashed

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果是遇到了这个问题，是比较严重的，这个问题不像问题一，问题一整个app是可以运行的，错误来源于Xib / Storyboard编译时候的错误，但是并不影响这个app的运行。&lt;/p&gt;

&lt;p&gt;但是这个问题会直接导致整个app闪退，直接Crashed掉！没办法，我们只能打断点debug一下。&lt;/p&gt;

&lt;p&gt;如果你在Designables 那里把Debug打开，然后断点打到initWithCoder 和 initWithFrame那里，会发现程序总是运行到这一行&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
self = [super initWithCoder:aDecoder];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;或者这一行&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
self = [super initWithFrame:frame];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;就崩溃了。其实从下面的栈信息也可以很快看出发生了什么：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-ee0d98669a4889f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-ca3fcc8e1ef9a9e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以很明显的看到，是initWithCoder这个方法陷入了死循环。由于这个死循环导致了程序Crashed了。&lt;/p&gt;

&lt;p&gt;可是这里为什么会死循环呢？其实根本原因在于，我们自定义的类的class写成自己了。&lt;/p&gt;

&lt;p&gt;来看看到底发生了什么。现在在Xode 7中，我们默认创建一个View，是不给我们默认生成一个XIB文件，ViewController会有下面那个选项，可以选择勾上。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-747a4d232003df04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在我们创建完这个类的时候，我们还要再创建一个Xib和这个类进行关联。&lt;/p&gt;

&lt;p&gt;再对比一下我们创建TableviewCell的过程&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-736c5bf9967f48af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一般我们会勾选上那个“Also create XIB file”，创建完成之后，我们就会在Custom Class里面把我们这个cell的类名填上。&lt;/p&gt;

&lt;p&gt;如果我们现在自定义View的时候也是相同做法，创建完Xib文件之后，File‘s owner关联好了之后。然后在Custom Class里面填上了我们自定义的类之后，这个时候就错了！&lt;/p&gt;

&lt;p&gt;为什么我们平时相同的做法，到这里就错误了呢？&lt;/p&gt;

&lt;p&gt;我们来考虑一下我们自定义View加载的过程。我们这个自定义View肯定是放在了一个ViewController上面，代码创建出来或者直接拖拽到Xib / Storyboard 上。用代码或者SB上面拖一个View，这个时候我们需要指定这个类是什么，这个毋庸置疑，是绝对没有问题的。SB上面拖的View的class肯定要选择我们自定义的这个View。&lt;/p&gt;

&lt;p&gt;但是在加载我们这个View的时候，会走initWithCoder / initWithFrame 方法，在这里方法里面又会去调用super的这个方法，现在我们把这个class写成了自己，依照我们上面调试的log，可以看到，initWithCoder以后，会按照以下的路线去调用.&lt;/p&gt;

&lt;p&gt;[NSBundle loadNibName] —— [UINib instantiateWithOwner:options] ——[UINibDecoder decodeObjectForKey:]——UINibDecoderDecodeObjectForValue——[UIRuntimeConnection initWithCoder]——[UINibDecoder decodeObjectForKey:]——UINibDecoderDecodeObjectForValue——[UIClassSwapper initWithCoder:]——[BottomCommentView initWithCoder:]&lt;/p&gt;

&lt;p&gt;从NSBundle加载开始，解析完之后会调用到ClassSwapper 的initWithCoder，由于我们class写了自己，这里就陷入死循环了。程序崩溃！这里就跟set方法里面调用点语法赋值一样，无限的递归调用了。&lt;/p&gt;

&lt;p&gt;经过上面的分析之后，我们就知道了问题就出在我们在initWithCoder里面又调用了loadNibName，loadNibName又会去最终调UIClassSwapper initWithCoder。难道是我们custom class不对么？对比一下我们自定义tableViewCell的class就是本身，怎么就没有这个问题呢。&lt;/p&gt;

&lt;p&gt;我们来仔细看看tableViewCell我们是怎么加载的，我们的Xib的class还是自己，但是registerWithNibName的方法调用在tableView中，这样就不会无限递归了。&lt;/p&gt;

&lt;p&gt;这里当然我们也可以仿照这个方法做，那我们需要把loadNibName写到另外一个类中去。class还是写自己本身，用那个类来加载我们这个View，这样就可以不崩溃，不会无限递归了。但是问题又来了，我们无法在Xib/Storyboard上实时预览到我们的View了。&lt;/p&gt;

&lt;p&gt;这里需要提一下IB_DESIGNABLE的工作原理。当我们用了IB_DESIGNABLE关键字以后，Xib/StoryBoard会在不运行整个程序的情况下，把这个View代码编译跑一遍，由于没有程序上下文，所有的编译就只在这个view的代码中进行。&lt;/p&gt;

&lt;p&gt;我们在ViewController里面拖拽了一个View，并且更改它的class为我们自定义的class，那么接下来所有view的绘制都会交给我们这个自定义view的class，由这个class来管理。这里就分两种情况了。第一种情况就是我文章一开头给的Demo的例子，用DrawRect代码绘制出这个View的样子。这里不会出现任何问题。第二种情况就是我们还想用一个Xib来显示View，这种情况就是Xib/StoryBoard里面再次加载Xib的情况了。由于现在我们自定义的class有了接管整个view的绘制权利，那么我们就应该在initWithCoder中loadNibName，把整个View在初始化的时候load出来。根据上面的分析，我们找到崩溃的原因是无限递归，这里又必须要调用initWithCoder，我们的唯一办法就是把class改成父类的class，即UIView，这时候一切就好了，Xib/Storyboard不报错，也能及时显示出view的样子来了。&lt;/p&gt;

&lt;p&gt;总结一下：
&amp;gt; when using loadNibNamed:owner:options:, the File’s Owner should be NSObject, the main view should be your class type, and all outlets should be hooked up to the view, not the File’s Owner.&lt;/p&gt;

&lt;p&gt;Ps.这里说的仅仅是loadNibNamed而不是initWithNibName。顺带提一下他们俩的不同点。initWithNibName要加载的Xib的类为我们定义的ViewController。loadNibNamed要加载的Xib的类为NSOjbect。他们的加载方式也不同，initWithNibName方法：是延迟加载，这个View上的控件是 nil 的，只有到需要显示时，才会不是 nil。loadNibNamed是立即加载，调用这个方法加载的xib对象中的各个元素都已经存在。&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;当我第一次知道IB_DESIGNABLE / IBInspectable之后，感觉到特别的神奇，连我们自定义化的View也可以及时可见了。不过经过一段研究以后就发现。IB_DESIGNABLE / IBInspectable还是有一些缺陷的。IB_DESIGNABLE暂时只能在UIView的子类中用，常用的UIButton加圆角这些暂时也没法预览。IBInspectable实质是在Runtime Attributes设置了值，这也使得IBInspectable只能使用常用类型。NSDate这种类型没法设置成IBInspectable。&lt;/p&gt;

&lt;p&gt;以上就是我和大家分享的IB_DESIGNABLE / IBInspectable使用过程中遇到的一些“坑”。&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;更新：&lt;/h4&gt;
&lt;p&gt;下面这一段要感谢@&lt;strong&gt;Andy矢倉&lt;/strong&gt; 微博上面指点我，其实系统的子类可以这么做：抽了几个常用的控件的公共类，顺便用External剥离常用属性，更复杂的移步这个库&lt;a href=&quot;https://github.com/JakeLin/IBAnimatable&quot;&gt;IBAnimatable&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;@&lt;strong&gt;Andy矢倉&lt;/strong&gt;还提醒说，用这个特性最好是iOS8 + Swift，OC或者iOS7都会出现Failed to update而且无解，再次感谢@&lt;strong&gt;Andy矢倉&lt;/strong&gt;大神的指点！！！下图是他对系统控件的可视化改造！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-932768201a4dae84.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 22 Jul 2016 21:13:00 +0800</pubDate>
        <link>http://vno.onevcat.com/2016/07/%E5%85%B3%E4%BA%8EIB_DESIGNABLE-IBInspectable%E7%9A%84%E9%82%A3%E4%BA%9B%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E4%BA%8B/</link>
        <guid isPermaLink="true">http://vno.onevcat.com/2016/07/%E5%85%B3%E4%BA%8EIB_DESIGNABLE-IBInspectable%E7%9A%84%E9%82%A3%E4%BA%9B%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E4%BA%8B/</guid>
        
        <category>iOS</category>
        
        
        <category>Blog</category>
        
      </item>
    
      <item>
        <title>WWDC2016 Session笔记 - Xcode 8 Auto Layout新特性</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-520084e0dda3ed1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;目录&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;1.Incrementally Adopting Auto Layout&lt;/li&gt;
  &lt;li&gt;2.Design and Runtime Constraints&lt;/li&gt;
  &lt;li&gt;3.NSGridView&lt;/li&gt;
  &lt;li&gt;4.Layout Feedback Loop Debugging&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;incrementally-adopting-auto-layout&quot;&gt;一.Incrementally Adopting Auto Layout&lt;/h4&gt;
&lt;p&gt;Incrementally Adopting Auto Layout是什么意思呢？在我们IB里面布局我们的View的时候，我们并不需要一次性就添加好所有的constraints。我们可以一步步的增加constraints，简化我们的步骤，而且能让我们的设置起来更加灵活。&lt;/p&gt;

&lt;p&gt;再谈新特性之前，先介绍一下这个特性对应的背景来源。&lt;/p&gt;

&lt;p&gt;有这样一种场景，试想，我们把一个view放在父view上，这个时候并没有设置constraints，当我们运行完程序，就会出现下图的样子。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-637527eb1a0ca498.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看上去一切都还正常。但是一旦当我们把设备旋转90°以后，就会出现下图的样子。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-d716316a84356bf1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个时候可以发现，这个View的长，宽，以及top和left的边距都没有发生变化。这时我们并没有设置constraints，这是怎么做到的呢？&lt;/p&gt;

&lt;p&gt;在程序的编译期，Auto Layout的引擎会自动隐式的给View加上一些constraints约束，以保证View的大小不会发生变化。这个例子中，View被加上了top，left，width，height这4个约束。&lt;/p&gt;

&lt;p&gt;如果我们需要更加动态的resize的行为，就需要我们在IB里面自定义约束了。现在问题就来了，有没有更好的方式来做这件事情？最好是能有一种不用约束的方法，也能达到简单的resize的效果。&lt;/p&gt;

&lt;p&gt;现在这个问题有了解决办法。在Xcode8中，我们可以给View指定autoresizing masks，而不用去设置constraints。这就意味着我们可以不用约束，我们也能做到简单的resize的效果。&lt;/p&gt;

&lt;p&gt;在Autolayout时代之前，可能会有人认出这种UI方式。这是一种Springs &amp;amp; Struts的UI。我们可以设定边缘约束(注：这里的约束并不是指的是Autolayout里面的constraints，是autoresizing masks里面的规则)，无论View的长宽如何变化，这些View都会跟随着设置了约束的view一起变化。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-d66036d42faa95e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上述的例子中，Xcode 8 中在没有加如何constraint就可以做到旋转屏幕之后，View的边距并没有发生变化。这是怎么做到的呢？事实上，Xcode 8的做法是先取出autoresizing masks，然后把它转换成对应的constraints，这个转换的时机发生在Runtime期间。生成对应的constraints是发生在运行时，而不是编译时的原因是可以给我们开发者更加便利的方式为View添加更加细致的约束。&lt;/p&gt;

&lt;p&gt;在View上，我们可以设置translatesAutoresizingMaskIntoConstraints属性。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;translatesAutoresizingMaskIntoConstraints == true  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;假设如果View已经在Interface Builder里面加过constraints，“Show the Size inspector”面板依旧会和以前一样。点击View，查看给它加的所有的constraints，这个时候Autoresizing masks就被忽略了，而且translatesAutoresizingMask的属性也会变成false。如下图，我们这个时候在“Show the Size inspector”面板上面就已经看不到AutoresizingMask的设置面板了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-8fa2f4a12705805d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-a572a36604c85ffd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;
上图就是在Autolayout时代之前，我们一直使用的是autoresizing masks，但是Autolayout时代来临之后，一旦勾选上了这个Autolayout，之前的AutoresizingMask也就失效了。&lt;/p&gt;

&lt;p&gt;回到我们最原始的问题上来，Xcode 8 现在针对View可以支持增量的适用Autolayout。这就意味着我们可以从AutoresizingMask开始，先做简单的resize的工作，然后如果有更加复杂的需求，我们再加上适当的约束constraints来进行适配。简而概之，Xcode 8 Autolayout ≈ AutoresizingMask + Autolayout 。&lt;/p&gt;

&lt;p&gt;接下来用一个demo的例子来说明一下Xcode 8 Autolayout新特性。&lt;br /&gt;
在说例子之前我们先来说一下Xcode 8在storyboard上新增了哪些功能。如下图，我们可以看到，在最下方新增加了一栏，可以切换不同的屏幕大小，可以看出，iPhone现在已经分化成6种屏幕大小需要我们适配了，从大到小，依次是：iPad pro 12.9, iPad 9.7 , iPhone 6s Plus/iPhone 6 Plus , iPhone 6s/iPhone 6, iPhone SE/iPhone5s/iPhone5, iPhone4s/iPhone4。下面还可以选择横竖屏，和不用屏幕百分比的适应性。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-ccd7ee3afb97128c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;回到例子，我们现在对页面上这些view来做简单的AutoresizingMask。右边的那个预览界面是可以看到我们加上这些Mask之后的效果。&lt;/p&gt;

&lt;p&gt;先是粉色的父View，我们给它加上如下的AutoresizingMask。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-541263982f9d5004.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;给”雨天”的imageView加上如下AutoresizingMask
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-a72576207ebe4447.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;给”阴天”的imageView加上如下的AutoresizingMask&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-c17df0eec79dd816.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后给我们的中间的Label加上AutoresizingMask&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-d8df43f7952321be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个时候我们旋转一下屏幕，一切正常，View的排版都如我们所愿。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-4df96205a8480096.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个时候我们再选择一下，3：2分屏，这个时候就出现了不对的情况了。Label的Width被挤压了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-55bf242088854780.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;原因是因为Autoresizing masks并不会向Autolayout一样，会考虑View的content，所以这里被挤压了。&lt;/p&gt;

&lt;p&gt;想fix这个Label，我们可以很容易的添加一个constraints来修复。不过这里我们来谈谈另外一种做法。&lt;/p&gt;

&lt;p&gt;进入到Attributes Inspector面板，找到Autoshrink属性，把“fixed font size”切换成“minimum font size”&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-79b7038d7df03eb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个时候就fix上述的问题了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-d140165f6ca54036.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此时就算是回到landscape，分屏的情况下，已经可以显示正常。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-02e1709fd25a60e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接着我们再来处理一下中间的温度的Label。这个时候我们有比较复杂的需求。这个时候我们就需要用到constraint了。&lt;/p&gt;

&lt;p&gt;这个时候我们按时control键，然后拖到父View上，释放，会弹出菜单。我们再按住shift，这样我们可以一次性选择多个constraints。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-793f4205c747a333.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-95aab84ae9baace3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们一次性选择“Center Horizontally in Container” 和 “Center Vertically in Container”。注意这个时候右边还是AutoresizingMask的面板，因为这个时候Label还没有任何的constraint。当我们点击“Add Constraints”的时候，就给Label加上了约束，右边的面板也变成了constraints面板了。&lt;/p&gt;

&lt;p&gt;我们再给这个Label继续加2个constraints。“Horizontal Spacing”和“Baseline”。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-48e850a152987d86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;同样的，从Label拖拽到“太阳”的那个imageView上，再添加“Horizontal Spacing”和“Baseline”约束。&lt;/p&gt;

&lt;p&gt;这个时候我们更新一下frame。如下图所示，选择“Update Frames”，这个时候所有的frame就都完成了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-23546d448e5c177d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-04a9232b13c71d6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个时候我们更新一下中间温度的Label的字体大小，这时候计算变大，由于我们的constraints都是正确的，两边的View也会随着Label字体变大而变大。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-3da0a819491ff184.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Xocde 8在这个时候就变得更加智能了，会立即自动更新frame。&lt;/p&gt;

&lt;p&gt;我们在继续给晴天的上海加上一个背景图。添加一个imageView，然后大小铺满整个父View，把mode 选择成“Aspect Fill”&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-7639cec83cd526d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接下面一般的做法就是在这个imageView上面添加constraints，来使这个View和父View大小一样。但是这种简单的resize的行为在Xocde 8里面就不需要再添加Constraint了，这里我们改用Autoresizing masks来实现。给imageView添加一下这些mask。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-badadb886e9ff91e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们把imageView放到背景去。这时，我们所有的界面就布局完成了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-4917418adeac2aec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;测试一下横屏的效果
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-9c3f8c4a5c4db2b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;甚至分屏的一样可以完成任务！
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-29ed778b3ce5e7aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/halfrost/Xcode8AutolayoutDemo&quot;&gt;Demo的Github地址&lt;/a&gt;，这个demo没啥难的，就是看看效果。&lt;/p&gt;

&lt;p&gt;这就是Xcode 8 的Incrementally Adopting Auto Layout，Autoresizing masks + Auto Layout Constraint 一起协同工作！&lt;/p&gt;

&lt;h4 id=&quot;design-and-runtime-constraints&quot;&gt;二.Design and Runtime Constraints&lt;/h4&gt;

&lt;p&gt;在我们开发过程中有这样一种情况，View的constraints会依据你所加载的数据来添加的。所以在app运行之前，我们是无法知道所有的constraints的。&lt;/p&gt;

&lt;p&gt;这里有3种方法可以对应以上的情况。&lt;/p&gt;

&lt;h5 id=&quot;placeholder-constraints&quot;&gt;1.Placeholder Constraints&lt;/h5&gt;

&lt;p&gt;假设现在我们需要把一张图片放在View的垂直和水平的中间，并且距离左边的边缘有一个leading margin。并且还需要保持其长宽的比例。而这种图片的最终样子，我们并不知道。只有到运行时，我们才能知道这样图片的样子。&lt;/p&gt;

&lt;p&gt;为了能在Interface Builder看到我们的图片，我们要先预估一下图片的长宽比例。假设我们估计为4：3。这时候就给图片加上constraints，并且勾上“place order constraint”，这个约束会在build time的时候被移除。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-ed8c011d75371e39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当我们在运行时拿到图片之后，这个是时候我们再给它加上适当的约束和长宽比例即可。&lt;/p&gt;

&lt;h5 id=&quot;intrinsic-content-size&quot;&gt;2.Intrinsic Content Size&lt;/h5&gt;

&lt;p&gt;还是类似上面那种场景，我们有时候会自定义一些UIView或者NSView，这些View里面的content是动态的。Interface Builder并不会运行我们的代码，所以不到app运行的时候我们并不知道里面的大小。我们可以给它设置一个内在的content的大小。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-5f22d602933155e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Setting a design time intrinsic content size only affects a view while editing in Interface Builder.The view will not have this intrinsic content size at runtime.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;注意一下上面的说明intrinsic content size仅仅相当于是在布局的时候一个placeholder，在运行时这个size就没有了。所以如果开发过程中真的需要用到这个内在的content的大小，那么我们需要overriding的content size&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;override var intrinsicContentSize: CGSize  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;turn-off-ambiguity-per-view&quot;&gt;3.Turn Off Ambiguity Per View&lt;/h5&gt;

&lt;p&gt;这个是Xcode 8的一个新特性。当上述2种方法都无法解决我们的需求的时候。这个时候就需要用到这种方法了。Xcode 8给了我们可以在constraints产生歧义的时候，可以动态调整警告级别的能力。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-4f433ddf72781326.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在这个场景中，我们仅仅只知道我们需要把这个imageView放在水平位置的中央，但是imageView的大小和它的水平位置我们并不知道。如果我们仅仅只加上了这一个约束的话，Interface Builder就会报红，因为IB这时候根据我们给的constraints，并不能唯一确定当前的view的位置。&lt;/p&gt;

&lt;p&gt;如果我们在之后的运行时，拿到图片的完整信息之后，我们自己知道该如何去加constraints，我们知道该如何去排版保证imageView能唯一确定位置的时候，这时我们可以关掉IB的红色警告。找到“Ambiguous”，这里是警告的级别，我们这里选择“Never Verify”，这时就没有红色的警告和错误提醒了。但是选择这一项的前提是，我们能保证之后运行时我们可以加上足够的constraints保证view的位置信息完整。&lt;/p&gt;

&lt;p&gt;以上3种方法就是我们在运行时给view增加constraints的解决办法。&lt;/p&gt;

&lt;h4 id=&quot;nsgridview&quot;&gt;三.NSGridView&lt;/h4&gt;

&lt;p&gt;这是macOS给我们带来的一个新的layout容器。&lt;/p&gt;

&lt;p&gt;有时候我们为了维护constraints的正确性是件比较麻烦的事情，比如即使我们就是一组简单的checkboxes，维护constraints也不容易。这个时候我们会选择用stack view来让我们开发更容易一些。&lt;/p&gt;

&lt;p&gt;下图是macOS的app常见到的一组checkboxes。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-9cc9080a7861603d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这时候我们选用NS/UIStackView来实现，因为它有以下的优点，它可以排列一组items，重要的是它可以处理好content size并且可以控制好每个item之间的spacing。&lt;/p&gt;

&lt;p&gt;但是stack view依旧有一些场景无法很顺手的处理。例如下图的场景。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-e7c6eb85adbd76db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这时依旧可以用stack view来实现，但是它不能帮我们根据content完成行和列的对齐。&lt;/p&gt;

&lt;p&gt;这就是为什么要引入新的NSGridView的原因。&lt;/p&gt;

&lt;p&gt;使用NSGridView，我们可以很容易的做到content在X轴和Y轴上的对齐。仅仅只需要我们把content放进预先定义好的网格中即可，NSGridView会帮我们管理好接下来对齐的一切事情。&lt;/p&gt;

&lt;p&gt;我们来看看下面的例子。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-a7194363c60b4d99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;NSGridView有2个子类，NSGridRow 和 NSGridColumn，它们俩会自动的管理好content的大小。当然我们可以在需要的时候指定size的大小，padding和spacing的大小。我们也可以动态的隐藏一些rows行和colunms列。&lt;/p&gt;

&lt;p&gt;NSGridCell的工作就是管理每个cell里面content view的layout。如果某个cell的内容超出cell的边界，cell会合并起来，就像普通的电子表格app的做法一样。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-0240de67714b42b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们来构建一个简单的界面。设计图如下：
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-ef33742918f3879a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们并不需要去关心网格的sizing，我们只用关心每一行每一列究竟有多少个content需要被显示出来。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let empty = NSGridCell.emptyContentView  
let gridView = NSGridView(views: [
 [brailleTranslationLabel, brailleTranslationPopup], 
 [empty, showContractedCheckbox], 
 [empty, showEightDotCheckbox], 
 [statusCellsLabel, showGeneralDisplayCB],
 [empty, textStyleCB], 
 [showAlertCB] 
])
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;用上述代码运行出来的界面是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-a561bbdcb0ff07c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;虽然我们调用构造函数没错，但是出来的界面和设计的明显有一些差距。最明显的问题就是UI被拉开了，有很多空白的地方。&lt;/p&gt;

&lt;p&gt;产生问题的原因就在于，网格被约束到了window的边缘。我们的意图应该是window来匹配我们的网格大小，但是现在出现的问题变成了，网格被拉伸了，去匹配window的大小了。&lt;/p&gt;

&lt;p&gt;我们解决这个问题的办法就是去改变 grid view内容的hugging的优先级。尽管页面上的constraints已经具有了高优先级，但是我们现在仍可以继续提高优先级，来让constraints推动content，使其远离window的边缘。我们提高一些优先级：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gridView.setContentHuggingPriority(600, for: .horizontal)
gridView.setContentHuggingPriority(600, for: .vertical)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-a1dd15524cd1dcf0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们会发现，window里面的content更加聚合了，中间的大段空白消失了。&lt;/p&gt;

&lt;p&gt;我们再来解决一下window中间的空白，左边的label和右边的content距离太远。根据设计，我们应该让label居右排列。这件事很容易，只要我们调整一下cell的位置信息即可完成。排列的位置信息会影响到cell，行，列，网格视图。&lt;/p&gt;

&lt;p&gt;如果没有指定cell的placement这个属性值，那么行列就会根据gridview的placement属性值来确定。这个规则可以使我们在一处设定好placement，瞬间可以改变大量的cell的布局。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//first column needs to be right-justified:
gridView.column(at: 0).xPlacement = .trailing
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;我们找到gridView的第一列，改变它的xPlacement属性值，这样一列的cell都会变成居右排列。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-1225a9d45ea39661.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;居右之后，我们又会出现新的问题，baseline不对齐了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-74949bdfced19d16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;行的对齐和列的对齐原理一样的，同理，我们只需要设置一处，将会影响整个网格视图。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// all cells use firstBaseline alignment
gridView.rowAlignment = .firstBaseline
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-a61900a27d2bd610.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;设置完成之后，整个网格视图就对齐了。&lt;/p&gt;

&lt;p&gt;接下来我们再来改变一下pop-up button的边距。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-3201fb8701df1ed6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let row = gridView.cell(for: brailleTranslationPopup)!.row!
row.topPadding = 5
row.bottomPadding = 5
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里取第一行的做法也可以和之前取第一列的做法一样，直接取下标0的row即可。这里换一种更好的做法来做。在gridView里面找到包含pop-up button的cell，根据cell找到对应的row行。这种方式比直接去下标index的好处在于，日后如果有人在index 0的位置又增加了一行，那么代码就出错了，而我们这里的代码一直都不会出错，因为保证是取出了包含pop-up button的cell。所以代码里面尽量不要写死固定的index，这样以后维护起来比较困难。&lt;/p&gt;

&lt;p&gt;同理，我们也给“status cells”也一起加上Padding&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ridView.cell(for:statusCellsLabel)!.row!.topPadding = 6
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里需要对比一下padding 和 spacing的区别。&lt;/p&gt;

&lt;p&gt;padding是针对每个行或者每个列之间的间距，我们可以增加padding来改变两两之间的间距。
spacing是针对整个gridview来说的，改变了它，将会影响整个网格视图的布局。&lt;/p&gt;

&lt;p&gt;再来看看我们的设计图：
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-ef33742918f3879a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果没有padding那么就是下图的样子：
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-a44097139cef38b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果没有spacing那么就会出现下图的样子：
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-559a56f9aa2f175e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果spacing和padding都没有的话，那就都挤在一起了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-13509a34450af8b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后我们来处理一下最下面那一行包含checkbox的cell&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-73c75d29bd25b172.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里就需要用到之前提到了，合并2个cell了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Special treatment for centered checkbox:
let cell = gridView.cell(for: showAlertCB)!
cell.row!.topPadding = 4
cell.row!.mergeCells(in: NSMakeRange(0, 2))
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里我们直接指出了，合并前2个cell。&lt;/p&gt;

&lt;p&gt;执行完代码之后，就会是这个样子。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-b181efe7718f5ae4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后一行的cell就会横跨2个cell的位置。虽然占了2个cell的位置，但是它依旧还继承着第一列的居右的排列规则。&lt;/p&gt;

&lt;p&gt;现在我们的需求是既不希望它居右，也不希望它居左。
checkbox其实是支持排列在2个列之间的，但是由于这相邻的2个列的宽度并不相等，所以gridview不知道该怎么排列了。这时就需要我们手动来改变布局了。&lt;/p&gt;

&lt;p&gt;这里可能有人会想，直接把&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cell.xPlacement = .none
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;把cell的xPlacement直接变成none，这样做会一下子打乱整个gridview的constraints布局，我们不能这样做。我们需要再继续给cell加上额外的constraints来维护整个gridview的constraints的平衡。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cell.xPlacement = .none
let centering = showAlertCB.centerXAnchor.constraint(equalTo: textStyleCB.leadingAnchor)
cell.customPlacementConstraints = [centering]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;我们只需要在给出checkbox在x轴方面的锚点即可。这时候checkbox就会排列成我们想要的样子了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-6d6d0fdb84291a2d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;至此，我们就完成了需求。总结一下，NSGridView是一个新的控件，能很好的帮助我们进行网格似布局。它能很快很方便的把我们需要展示的content排列整齐。之后我们仅仅只需要调整一下padding和spacing这些信息即可。&lt;/p&gt;

&lt;h4 id=&quot;layout-feedback-loop-debugging&quot;&gt;四.Layout Feedback Loop Debugging&lt;/h4&gt;

&lt;p&gt;有时候我们设置好了constraint之后，没有报任何错误，但是有些情况当我们运行起来的时候就有一堆constraint冲突在debug窗口里面，严重的还会使app直接崩溃。崩溃的情况就是遇到了layout feedback loop。&lt;/p&gt;

&lt;p&gt;遇到这种情况，往往是发生在“过渡期”，开始或者结束的时候。如果说你点击了一个button，button相应了你的点击，但是之后button不弹起，一直保持着被按下的状态。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-c7f7e77d4a5642a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后会观察到CPU使用率爆表，内存倍增，然后app就崩溃了，与此同时返回了一大堆的layout的栈回溯信息。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-614c97ca5d350293.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;发生这个情况的原因是某个view的layout被一直执行，一直执行，陷入了死循环中。Runloop就不会停下，CPU的使用率会一直处于峰值。所有的消息都会被收集到自动释放的对象中去，消息一直发送，就会一直收集。所以内存也会倍增。&lt;/p&gt;

&lt;p&gt;导致这个原因之一，是setNeedsLayout这个方法。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-775542406d024aca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当其中一个view调用完setNeedsLayout之后，会传递到父视图继续调用setNeedsLayout，父视图的setNeedsLayout可能又会调用到其他视图的layout信息。如果我们能在这相互之后调用找到调用者，也就是那个view调用了这个方法，那我们就可以分析清楚这些setNeedsLayout从哪里来，到哪里去，就能找到死循环的地方了。&lt;/p&gt;

&lt;p&gt;这些信息确实很难收集，这也是为何苹果要为我们专门开发这样一个工具，方便我们来调试，查找问题的原因。&lt;/p&gt;

&lt;p&gt;开启这个工具的开关在“Arguments”选项里面。如下图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-a46ee65eca84ff69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-UIViewLayoutFeedbackLoopDebuggingThreshold 100 // 50...1000
-NSViewLayoutFeedbackLoopDebuggingThreshold 100 // 50...1000
// Logs to com.apple.UIKit:LayoutLoop or com.apple.AppKit:LayoutLoop
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;UIView是在iOS里面使用的，NSView是在macOS里面使用的。一旦我们开启了这个开关，那么layout feedback loop debugger就会开始记录每一个调用了setNeedsLayout的信息。&lt;/p&gt;

&lt;p&gt;这里我给它设置了阀值是100。&lt;/p&gt;

&lt;p&gt;如果发现在一个Runloop中，layout在一个view上面调用的次数超过了阀值，这里设置的是100，也就是说次数超过100，这个死循环还会在跑一小段，因为这个时候要给debugger一个记录信息的时间。当记录完成之后，就会立即抛出异常。并且信息会显示在logs中。log会被记录在com.apple.UIKit:LayoutLoop(iOS)/com.apple.AppKit:LayoutLoop(macOS)中&lt;/p&gt;

&lt;p&gt;我们也可以打全局的异常断点exception break point。
在调试窗口也可以用LLDB命令po出一些调试信息。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-a83832771675c027.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接下来看2个实用的例子。&lt;/p&gt;

&lt;h5 id=&quot;upstream-geometry-change&quot;&gt;1.Upstream Geometry Change&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-68dca9ff105c7c61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里有这么多个view，层级如上图。&lt;/p&gt;

&lt;p&gt;现在右子串上面10个子view在一次的层级变化中，被移除了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-4014b85c072a588b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;那么最上层圈起来的3个view都会被影响。&lt;del&gt;于是这3个view的bounds就发生了变化。于是就会隐式的调用setNeedsLayout，来获取新的bounds的信息。&lt;/del&gt;&lt;strong&gt;(这里经过@kuailejim @冬瓜争做全栈瓜 和大神们实验，setNeedsLayout是需要我们开发者手动调用的，系统并不会在bounds改变的时候隐式调用setNeedsLayout方法)&lt;/strong&gt;。当前view的bounds改变，但是如果父view没有layout完成，那么父view也会继续收到setNeedsLayout消息。这个消息就会一直被往上传递，直到传到最顶层的view，顶层的view layout完成之后，将会重置下面关联的view的bounds，调用layoutSubview()方法。这时候，死循环就产生了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-8a4946f8c09e222c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;
&lt;del&gt;这3个view就是上面3个view，下面的view需要setNeedsLayout，需要获取最新的bounds信息，中间蓝色的view也同样需要setNeedsLayout，于是又会让上层的view调用setNeedsLayout()方法，这个时候死循环就产生了。上下各有2个环，共同的view就是中间蓝色的view。环内的view都在相互的请求setNeedsLayout()，并且在自己layout完成以后又会去重置关联的view的bounds。这就形成了triggers layout。&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;大家对这里产生2个环产生了极大的好奇，热烈讨论这里会产生环的情况。目前可以想到会产生环的场景是这样子的:在上面的3颗子树，当某种场景下，突然删掉了右边的子树，假设用户的屏幕现在是全屏，由于一下子突然删掉了一堆view，那么原来那里就会变成空白，这个时候开发者想要把其他的view平铺到屏幕上。这个时候就需要改变上面父view的bounds，最下面的view会代码里面手动调用上面蓝色的view，setNeedsLayout()方法，并且把蓝色view的bounds设置成全屏，由于蓝色view的bounds改变，这个时候开发者代码里面又手动调用了蓝色view的父view，去执行setNeedsLayout()方法。top view代码里面又写了bounds = origRect，这时候就触发了蓝色view的layout，更新bounds。这样就产生了循环。同理下面也会形成循环。这样就产生了2个死循环了。&lt;strong&gt;这些总结需要感谢@kuailejim @冬瓜争做全栈瓜 给出的指点。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-71863fde64ba8227.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里是我们用工具收集到的log，第一行就是top-level view，接下来的就是递归的过程。往下看，我们会看见一些数字，这些数字就是view接到layout的次数，并且这些数字是有序的。一次死循环中这些数字就是循环时候的顺序。当然一个循环中，每个view可以是起点也可以是终点。这里我们默认把top view设置成起点。这样就可以向我们展示出死循环中一共牵扯进来了多少个view。&lt;/p&gt;

&lt;p&gt;从log上看，上面有3个view，下面有10个view，加起来也不等于23，这是为什么呢？我们继续往下看log，来看看“Views receiving layout in order”这里面记录了些什么吧。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-333285494519f9d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里我们可以很明显的看到，view接收到layout的顺序，一共正好23个。也可以看出，在一起循环中，一个view接收到layout的次数不止一次。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-1a2647a8c347ad9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如上图所标示的，有2段在循环，有10个view接收到layout之后，再是2个view，紧接着又是10个view，再是1个view。&lt;/p&gt;

&lt;p&gt;回到最初我们使用这个工具的用途上来，最初我们使用这个工具是用来查看 top-level view 接收到setNeedsLayout消息到底从哪里来。继续往下查找，找到调用的栈信息那里。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-b10dc1deecd2a7e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;
从上往下看，前几行肯定都是UIViewLayoutFeedbackLoopDebugging的信息。往下看，看到第6行，可以看到DropShadowView接受到了信息，准备setBounds。回看之前的层级信息，我们会发现DropShadowView是TransitionView的子view。&lt;/p&gt;

&lt;p&gt;引起DropShadowView触发setBounds的唯一途径是，它的父view，TransitionView触发了setNeedsLayout()方法。因为这个时候TransitionView还没有layout。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-415e97e9fcf8b94f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;
回到“geometry change records”,这个时候我们可以看到选中的这3行信息在一遍遍的循环。看第2行和第3行，我们可以看到是来自于TransitionView的layout。这时是合理的。再看第一行，会发现这个时候有一个TransitionView的子view调用了viewLayoutSubviews。&lt;/p&gt;

&lt;p&gt;这个时候我们就定位到了bug的根源了，只要想方设法在layout的时候，不要改变superview的bounds即可以去掉这个死循环。&lt;/p&gt;

&lt;h5 id=&quot;ambiguous-layout-from-constraints&quot;&gt;2.Ambiguous Layout From Constraints&lt;/h5&gt;

&lt;p&gt;在我们设置constraints约束的时候，常常会产生一些歧义的constraints。歧义的constraints通常不可怕，我们只需要稍稍做些调整，然后update all frame即可。&lt;/p&gt;

&lt;p&gt;但是有如下的场景会导出形成环：&lt;/p&gt;

&lt;p&gt;当你的view在旋转之后，constraints也随之变化，然后有些view在旋转之后的constraint就会相互冲突。因次有些constraint就形成了环。&lt;/p&gt;

&lt;p&gt;这个问题在没有这个debugger工具的时候，思考起来很烧脑，没有任何头绪，这也是为什么log把top-level view放在第一行的原因，给我们暗示，从这里开始找bug的原因。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-bd525917ccd858da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;
在log，我们会看到好多的“Ambiguous Layout”。注意：tAMIC是Translates Auto Resizing Mask into Constraints的缩写。&lt;/p&gt;

&lt;p&gt;我们来看看详细的log。看log之前，我们应该知道，constraint虽然冲突很多，但是可能引起冲突的constraint只有一个，也就是说当我们更正了其中一个constraint，很可能所有的冲突都解决了。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-2cc7f461bc91b5e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;
如上图log所示，在minX这里我们设置了2个带有冲突性的constraint，一个是-60，一个是-120。我们可以一个个的检查约束，但是这个列表很长，检查起来也比较麻烦。&lt;/p&gt;

&lt;p&gt;那我们画图来分析一下这个问题。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-be202345d46bf519.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如图，label有leading和trailing padding，label是container的子view，container是action的子父，action是representation的子view。container和action view之间有一个居中的centering constraint。action view在representation view上有一个autoresizing mask constraints。&lt;/p&gt;

&lt;p&gt;然后每个representation view之间是alignment对齐的。自此看来，这些view并没有足够的constraints能让这些view都能确定位置信息。比如在X轴上，这一串view是可以存在在任何的位置，所以产生了歧义的constraint。&lt;/p&gt;

&lt;p&gt;解决上面的歧义的&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-UIViewLayoutFeedbackLoopDebuggingThreshold 100 // 50...1000
-NSViewLayoutFeedbackLoopDebuggingThreshold 100 // 50...1000
 //Logs to com.apple.UIKit:LayoutLoop or com.apple.AppKit:LayoutLoop
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;用debugger就可以解决上述的问题。&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;这个Xcode 8 给我们的Autolayout融合了之前Autoresizing masks的用法，使两个合并在一起使用，这样不同场景我们可以有更多的选择，可以更加灵活的处理布局的问题。还允许我们能手动调节constraints警告优先级别。&lt;/p&gt;

&lt;p&gt;针对macOS的布局问题，又给我们带来了新的控件NSGridView&lt;/p&gt;

&lt;p&gt;最后给我们带来的新的调试Layout Feedback Loop Debugging的工具，能让我们平时调试起来比较头疼的问题，有了工具可以有据可循，迅速定位问题，查找问题。&lt;/p&gt;

&lt;p&gt;最后，请大家多多指教。&lt;/p&gt;
</description>
        <pubDate>Sun, 17 Jul 2016 19:36:00 +0800</pubDate>
        <link>http://vno.onevcat.com/2016/07/WWDC2016-Session%E7%AC%94%E8%AE%B0-Xcode-8-Auto-Layout%E6%96%B0%E7%89%B9%E6%80%A7/</link>
        <guid isPermaLink="true">http://vno.onevcat.com/2016/07/WWDC2016-Session%E7%AC%94%E8%AE%B0-Xcode-8-Auto-Layout%E6%96%B0%E7%89%B9%E6%80%A7/</guid>
        
        <category>iOS</category>
        
        
        <category>Blog</category>
        
      </item>
    
      <item>
        <title>函数响应式编程(FRP)从入门到&quot;放弃&quot;——基础概念篇</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-903db38916fcf0cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;前言&lt;/h4&gt;
&lt;p&gt;研究ReactiveCocoa一段时间了，是时候总结一下学到的一些知识了。&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;一.函数响应式编程&lt;/h4&gt;
&lt;p&gt;说道函数响应式编程，就不得不提到函数式编程，它们俩到底有什么关系呢？今天我们就详细的解析一下他们的关系。&lt;/p&gt;

&lt;p&gt;现在有下面4个概念，需要我们理清一下它们之间的关系：
面向对象编程 Object Oriented Programming
响应式编程  Reactive Programming
函数式编程 Functional Programming
函数响应式编程 Functional Reactive Programming&lt;/p&gt;

&lt;p&gt;我们先来说说什么是函数式编程Functional Programming，我们先来看看&lt;a href=&quot;https://en.wikipedia.org/wiki/Functional_programming&quot;&gt;wikipedia&lt;/a&gt;上的相关定义：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Functional Programming is a programming paradigm &lt;br /&gt;
1. treats computation as the evaluation of  mathematical functions.
2. avoids changing-state and mutable data&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;总结一下函数式编程具有以下几个特点：
1. 函数是”第一等公民”&lt;br /&gt;
2. 闭包和高阶函数
3. 不改变状态(由此延伸出”引用透明”的概念) 
4. 递归
5. 只用”表达式”，不用”语句”，没有副作用&lt;/p&gt;

&lt;p&gt;接下来我们依次说明一下这些特点。
##### 一.  函数是”第一等公民” &lt;br /&gt;
所谓”第一等公民”（first class），指的是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。&lt;/p&gt;

&lt;p&gt;一等函数的理念可以追溯到 Church 的 lambda 演算 (Church 1941; Barendregt 1984)。此后，包括 Haskell，OCaml，Standard ML，Scala 和 F# 在内的大量 (函数式) 编程语言都不同程度地借鉴了这个概念。&lt;/p&gt;

&lt;p&gt;Ps：世界上最纯粹的函数式编程语言非Haskell莫属。&lt;/p&gt;

&lt;h5 id=&quot;section-2&quot;&gt;二.闭包和高阶函数&lt;/h5&gt;
&lt;p&gt;闭包是起函数的作用并可以像对象一样操作的对象。与此类似，函数式编程语言支持高阶函数。高阶函数可以用另一个函数（间接地，用一个表达式） 作为其输入参数，在大多数情况下，它甚至返回一个函数作为其输出参数。这两种结构结合在一起使得可以用优雅的方式进行模块化编程，这是使用函数式编程的最大好处。&lt;/p&gt;

&lt;h5 id=&quot;section-3&quot;&gt;三. 不改变状态(由此延伸出”引用透明”的概念)&lt;/h5&gt;

&lt;p&gt;不改变状态：
函数式编程只是返回新的值，不修改系统变量。因此，不修改变量，也是它的一个重要特点。在其他类型的语言中，变量往往用来保存”状态”（state）。不修改变量，意味着状态不能保存在变量中。函数式编程使用参数保存状态，最好的例子就是递归。&lt;/p&gt;

&lt;p&gt;避免使用程序状态和可变对象，是降低程序复杂度的有效方式之一，而这也正是函数式编程的精髓。函数式编程强调执行的结果，而非执行的过程。我们先构建一系列简单却具有一定功能的小函数，然后再将这些函数进行组装以实现完整的逻辑和复杂的运算，这是函数式编程的基本思想。&lt;/p&gt;

&lt;p&gt;引用透明： 
如果提供同样的输入，那么函数总是返回同样的结果。就是说，表达式的值不依赖于可以改变值的全局状态。这使您可以从形式上推断程序行为，因为表达式的意义只取决于其子表达式而不是计算顺序或者其他表达式的副作用。&lt;/p&gt;

&lt;p&gt;这里有出现了一个问题：&lt;/p&gt;

&lt;p&gt;面试题:** 纯函数式的闭包是否满足函数式编程里面不改变函数状态的特性？**&lt;/p&gt;

&lt;p&gt;根据&lt;a href=&quot;http://en.wikipedia.org/wiki/Pure_function&quot;&gt;纯函数&lt;/a&gt;的定义
&amp;gt; 在计算机编程中，假如满足下面这两个句子的约束，一个函数可能被描述为一个纯函数：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;给出同样的参数值，该函数总是求出同样的结果。该函数结果值不依赖任何隐藏信息或程序执行处理可能改变的状态或在程序的两个不同的执行，也不能依赖来自I/O装置的任何外部的输入（通常是这样的–看下面的描述）。&lt;/li&gt;
    &lt;li&gt;结果的求值不会促使任何可语义上可观察的副作用或输出，例如易变对象的变化或输出到I/O装置。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;函数的返回值是不需要依赖所有（或任何）参数值，必须不依赖参数值以外的东西。函数可能返回多重结果值，并且对于被认为是纯函数的函数，这些条件必须应用到所有返回值。假如一个参数通过引用调用，任何内部参数变化将改变函数外部的输入参数值，它将使函数变为非纯函数。&lt;/p&gt;

&lt;p&gt;回到我们讨论的这个问题上来:&lt;/p&gt;

&lt;p&gt;闭包虽然可以把闭包外部的变量捕获到闭包内部，但是闭包还是满足不改变状态的特性的。假设f(x)的返回值是g(x)，而g(x)是会依靠f(x)的参数返回的,g(x)相当于拥有f(x)的闭包。这个时候就会有一种错误的感觉，g(x)捕捉了f(x)入参的变量，从而产生了不同的闭包。从而得出g(x)不是纯函数式的，因为它改变了状态。如果我们站在更高的层面去看待这个问题，函数在函数式编程里面是一等值，和结构体，整型，布尔类型没有区别。回到上述的问题中来，由于我们传入了不同参数，但是闭包里面的整体算法是没有变化的。更加详细的例子，f(x)返回一个计算x平方的函数g(x)，g(x)虽然每次都会由f(x)传入的x值变化而变化，但是g(x)整体算法就是计算x的平方，这个计算方法是没有变化的，不根据外部状态改变而改变的。那么这个g(x)的block是满足函数式编程的不改变函数状态的特性的。所以它也是引用透明的。&lt;/p&gt;

&lt;p&gt;额外需要说明的一点，__block这个关键字其实是破坏了函数式编程的。&lt;/p&gt;

&lt;p&gt;面试题:&lt;strong&gt;如何理解引用透明？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果一个函数只会受到入参的变化，那么这个函数每次的调用都会是相同的
一个函数f(x),里面调用了g(x),g(x)里面又调用了h(x),h(x)最终计算出了结果，作为f(x)的返回值返回了。如果所有的状态都没有改变，f(x)下一次再调用相同的参数的时候，应该会得到完全一样的结果,那这个时候其实不用再调用g(x)和h(x)了，也可以得到完全一样的结果。当一个函数，不依赖“外部”变量和状态，只依赖入参的变化而影响函数最终返回值，也就是说入参相同，得到的返回值结果一定相同，如果函数具有这种性质，就可以说这个函数是引用透明的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef int(^intFx)(int a);

intFx transparent(intFx origin) {
    NSMutableDictionary *results = [NSMutableDictionary dictionary];
    return ^int(int p) {
        if (results[@(p)]) {
            return [results[@(p)] intValue];
        }
        results[@(p)] = @(origin(p));
        return [results[@(p)] intValue];
    };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;在上述例子中可以看到，如果result里面有我们需要的值了，我们就不会再去调用回调的闭包，这样transparent的函数每次传入相同的值，肯定会返回相同的结果。&lt;/p&gt;

&lt;p&gt;一个纯函数在执行的过程中，只跟入参有关，在函数体中并不会引用外部全局变量，或者说是一个类方法里面的其他成员变量。另外，纯函数除了返回值之外，也不会去改变外部的变量值。满足上面这两点的纯函数，就可以说它是引用透明的。也有说法叫这种特性为&lt;strong&gt;幂等性&lt;/strong&gt;&lt;/p&gt;

&lt;h5 id=&quot;section-4&quot;&gt;四.递归&lt;/h5&gt;
&lt;p&gt;函数式编程是用递归做为控制流程的机制。&lt;/p&gt;

&lt;h5 id=&quot;section-5&quot;&gt;五.只用”表达式”，不用”语句”，没有副作用&lt;/h5&gt;

&lt;p&gt;“表达式”（expression）是一个单纯的运算过程，总是有返回值；”语句”（statement）是执行某种操作，没有返回值。函数式编程要求，只使用表达式，不使用语句。也就是说，每一步都是单纯的运算，而且都有返回值。
原因是函数式编程的开发动机，一开始就是为了处理运算（computation），不考虑系统的读写（I/O）。”语句”属于读写操作，所以就被排斥在外。 
函数式编程强调没有”副作用”，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。&lt;/p&gt;

&lt;p&gt;举个例子来说明一下函数式编程和指令式编程的区别：
```&lt;/p&gt;

&lt;p&gt;// 指令式编程
int factorial1(int x) {
    int result = 1;
    for (int i = 1; i &amp;lt;= x; i ++) {
        result *= i;
    }
    return result;
}&lt;/p&gt;

&lt;p&gt;// 函数式编程
int factorial2(int x) {
    if (x == 1) return 1;
    return x * factorial2(x - 1);
}&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;上面这个例子就是计算阶乘的例子。我们先来看看指令式编程。指令式编程，像机器一条条命令一样思考问题。指令式的思想就类似于汇编，一条条指令告诉计算机该怎么去处理这个问题。所以在指令式编程里面就有很多的**状态量**和**语句**。而在函数式编程里面，思想是利用数学方法来思考问题。阶乘在数学定义里面就是f(n) = n _*_ f(n - 1) (n &amp;gt; 1),f(n) = 1(n = 1)。在函数式编程里面是基本上没有**状态量**，只有**表达式**，也没有赋值语句。利用了递归解决了问题。

再来看看指令式编程和响应式编程的区别
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;void test() {
    int a = 5;
    int b = 8;
    int c = a + b;
    a = 10;
    NSLog(@”%d”,c);
}
```&lt;br /&gt;
在指令式编程里面，计算是一种瞬间的操作。而响应式编程，计算是相互相应的，相互之间都存在关系，某些变化了，相互之间的关系会使相应的值随之变化。响应式编程有2个典型的例子：Excel，当单元格变化了，相互之间的单元格也会立即变化。Autolayout，当父View变化了，根据相互之间的关系Constraint，子View的frame也会随之变化。&lt;/p&gt;

&lt;p&gt;在面向对象语言中也是可以实现响应式编程的，具体做法应该是，把关系抽象出来，然后把变化抽象出来，用关系把变化事件传递下去。Cocoa框架下RAC的实现就是如此。&lt;/p&gt;

&lt;p&gt;最后再来说说函数响应式编程。
首先函数响应式编程肯定是满足函数式编程的上述特性的。函数响应式编程是面向离散事件流的，在一个时间轴上会产生一些离散事件，这些事件会依次向下传递。&lt;/p&gt;

&lt;p&gt;RAC就是Cocoa框架下的函数响应式编程的实现。它提供了基于时间变化的数据流的组合和变化。&lt;/p&gt;

&lt;p&gt;接着再来说说之前说的4种编程范式，总结出来，如果按照类似继承图谱来看的话，应该如下图：
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-92e858ac89ee627f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;首先在声明式编程里面有2大家族，那就是函数式编程和数据流编程，数据流编程下面就是响应式编程，而函数响应式编程是”继承”于函数式编程和响应式编程的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-b7b30d442802c2d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;面向对象编程就属于指令式编程的范畴。从上面2张图来看，我们可以很明显看出这4者是什么关系了。&lt;/p&gt;

&lt;p&gt;面试题:&lt;strong&gt;函数式编程是面向对象编程的升级产品&lt;/strong&gt;&lt;br /&gt;
由上面的说明来看，这个说法肯定是错误的，关系根据上面2图来看就很明显了。&lt;/p&gt;

&lt;p&gt;面试题:&lt;strong&gt;函数式语言主张不变量的原因是什么？&lt;/strong&gt;  &lt;br /&gt;
1. 函数保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不修改外部变量的值。由于这一主张，我们不需要考虑线程”死锁”问题，线程之间一定是安全的，因为它不修改变量，所以根本不存在”锁”线程的问题。&lt;br /&gt;
2. 进一步，函数式语言更加趋向于数学公式的推导，在数学公式里面其实是完全不存在变量这一概念的，此时如果又不存在变量了，那整个程序的执行顺序其实就不必要了，这样可以使我们更加容易的进行并发编程，更加有效率的利用多核cpu的计算处理能力。&lt;/p&gt;

&lt;h4 id=&quot;section-6&quot;&gt;二.链式调用&lt;/h4&gt;
&lt;p&gt;定义：f(x)，表示的是一种态射，从x的定义域到f(x)值域的态射。如果定义域和值域是完全相同的话，这种映射也成为单元态射。那么满足单元态射的函数，就可以进行链式调用。&lt;/p&gt;

&lt;p&gt;以RAC为例，把RACSignal链式传递下去，subscribeNext就会返回一个RACSignal，定义域和值域都是RACSignal，那么就满足了单元态射的要求，就可以链式调用下去。&lt;/p&gt;

&lt;p&gt;面试题:&lt;strong&gt;组成链式调用的必要条件就是在方法里面返回对象自己&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个说法是错误，举个例子：RAC每次做信号变换的时候，都产生了一个新的信号，所以返回自己就并不是必要条件。其实如果返回自己的同类或者和自己类似的类型，里面也包含可以继续链式调用的方法，也是可以组成链式调用的。&lt;/p&gt;

&lt;h4 id=&quot;rac&quot;&gt;三.关于RAC的其他一些概念&lt;/h4&gt;
&lt;p&gt;面试题:&lt;strong&gt;ReactiveCocoa是Facebook出的一个FRP开源库&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;错误，是写Github客户端时候的附属品，附带开发出的一个开源框架。&lt;/p&gt;

&lt;p&gt;面试题:**ReactiveCocoa是基于KVO的一个开源库 **&lt;/p&gt;

&lt;p&gt;错误。KVO是RAC非常次要的部分，甚至可以说没有KVO，RAC依旧可以存在。&lt;/p&gt;

&lt;p&gt;面试题:**ReactiveCocoa是一个纯函数式编程的库 **&lt;/p&gt;

&lt;p&gt;错误，由于Cocoa框架并不是函数式，RAC又是在Cocoa框架下，所以就不是纯函数式。在命令式编程的语言范畴里面实现纯函数编程，需要折中的方法，我们可以封装命令式编程，使其向上层可以形成纯函数式的，但是下层肯定就是命令式编程实现的。&lt;/p&gt;

&lt;p&gt;最后我们再来区分一个概念:&lt;/p&gt;

&lt;p&gt;面试题:&lt;strong&gt;RAC中Pull-driver和Push-driver的区别？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Pull-driver是指的是任何时刻，我们如果需要数据了，都可以从pull-driver里面拿走数据，因为数据先存储了。整个取数据的时间控制在调用者手上。典型的例子就是for-in循环，这就是一个pull-driver的操作。不管你循环几次，每次循环如何操作，数组或者字典里面的数据都一直存在在那里，“躺”在那里。
Push-driver是相反的，在任何时刻，当有数据或者事件产生，都会push给你，如果你此时没有处理，该事件或者数据就丢失了。整个取数据的时间并不控制在调用者的手里。&lt;/p&gt;

&lt;p&gt;Pull-driver可以类比看书，知识和文字不管你看不看，一直都在书里。
Push-driver可以类比看电视，节目不管你看不看，都一直播放，你错过了就是错过了。&lt;/p&gt;

&lt;p&gt;在RAC里面，Sequence就是一个pull-driver，Signal就是一个push-driver。&lt;/p&gt;

&lt;h4 id=&quot;section-7&quot;&gt;未完待续……&lt;/h4&gt;

&lt;p&gt;我会不定期把关于RAC相关难理解易混淆的概念都整理进来……欢迎大家指点。&lt;/p&gt;
</description>
        <pubDate>Mon, 11 Jul 2016 15:36:00 +0800</pubDate>
        <link>http://vno.onevcat.com/2016/07/%E5%87%BD%E6%95%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B(FRP)%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0-%E6%94%BE%E5%BC%83-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E7%AF%87/</link>
        <guid isPermaLink="true">http://vno.onevcat.com/2016/07/%E5%87%BD%E6%95%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B(FRP)%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0-%E6%94%BE%E5%BC%83-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E7%AF%87/</guid>
        
        <category>iOS</category>
        
        
        <category>Blog</category>
        
      </item>
    
      <item>
        <title>WWDC2016 Session笔记 - iOS 10 UICollectionView新特性</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-520084e0dda3ed1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;前言&lt;/h4&gt;
&lt;p&gt;关于 iOS 10  UICollectionView的新特性，主要还是体现在如下3个方面&lt;br /&gt;
1. 顺滑的滑动体验
现在基本上人人都离不开手机，手机的app也每天都有人在用。一个app的好坏由它的用户体验决定。在可以滑动的视图里面，必须要更加丝滑柔顺才能获得用户的青睐。这些UICollectionView的新特性可以让你们的app比原来更加顺滑，而且这些特性只需要你加入少量的代码即可达到目的。&lt;br /&gt;
2. 针对self-sizing的改进
self-sizing的API在iOS8的时候被引进，iOS10中加入更多特性使cell更加容易去适配。&lt;br /&gt;
3. Interactive reordering重排
这个功能在iOS9的时候介绍过了，苹果在iOS 10的API里面大大增强了这一功能。&lt;/p&gt;

&lt;p&gt;####目录
- 1.UICollectionViewCell顺滑的滑动体验
- 2.UICollectionViewCell的Pre-Fetching预加载
- 3.UITableViewCell的Pre-Fetching预加载
- 4.针对self-sizing的改进
- 5.Interactive Reordering
- 6.UIRefreshControl&lt;/p&gt;

&lt;h4 id=&quot;uicollectionviewcell&quot;&gt;一. UICollectionViewCell顺滑的滑动体验&lt;/h4&gt;
&lt;p&gt;众所周知，iOS设备已良好的用户体验赢得了广大的用户群。iOS系统在用户点击屏幕会立即做出响应。而且很大一部分的操作是来自于用户的滑动操作。所以滑动的顺滑是使用户沉浸在app中享受的必要条件。接下来我们就谈谈iOS 10 中增加了那些新特性。&lt;/p&gt;

&lt;p&gt;我们先来看一下之前 UICollectionView 的体验，假设我们每个cell都是简单的蓝色，实际开发app中，cell会比这复杂很多。 我们先生成100个cell。当用户滑动不是很快的时候，还感觉不出来卡顿，当用户大幅度滑动，整个UICollectionView的卡顿就很明显了。如果整个cell的DataSource又是从网络加载的，那就更加卡顿了。效果如下图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-2357f133fd5961cf.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果这种app上架，用户使用过后，很可能就直接给1星评价了。但是为什么会造成这种问题呢？我们来分析一下，我们模拟一下系统如何处理重用机制的，效果如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-f3aebac8fa099ff6.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在上图中，我们可以看出，当cell准备加载进屏幕的时候，整个cell都已经加载完成，等待在屏幕外面了。而且更重要的是，在屏幕外面等待加载的cell是整整一行！这一行的cell都已经加载完数据。这是UICollectionView在用户大幅度滑动时卡顿的根本原因。用专业的术语来说，掉帧。&lt;/p&gt;

&lt;p&gt;接下来我们就来详细的说说掉帧的问题。&lt;/p&gt;

&lt;p&gt;当今的用户是很挑剔的，用户需要一个很顺滑的体验，只要有一点卡顿，很可能一言不合就卸载app了。要想用户感觉不到卡顿，那么我们的app必须帧率达到60帧/秒。用数学换算一下就是每帧16毫秒就必须刷新一次。&lt;/p&gt;

&lt;p&gt;我们用图标来分析一下掉帧的问题。下面会出现2种不同的帧。&lt;/p&gt;

&lt;p&gt;第一种情况，下图是当用户轻微的上下小幅度滑动。这个时候每个cell的加载压力都不大，iOS针对这种情况，已经做了很好的优化了，所以用户感觉不到任何卡顿。这种情况是不会掉帧，用户也希望能使用如此顺滑的app。&lt;br /&gt;
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-61e63f9cf0819c8b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;第二种情况，当用户大幅度滑动，每个cell加载的压力很大，也许需要网络请求，也许需要读取数据库，而且每次都加载一行cell出来，这样每个cell的加载时间都增加了，加载一行的总时间也就大大增加了，如下图所示。这样，不仅仅当前帧在加载cell，总的时间还会挤压到下一帧的时间里面去。这种情况下，用户就感觉到了卡顿了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-c1c21562f28f212a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们换种方式在说明一下2种情况下掉帧的情况。我们用下图的标准来衡量一下上面2种情况。下图分为2部分，上面红色的区域，就是表示掉帧的区域，因为高于16ms。红色和绿色区域的分界线就在16ms处。y轴我们表示的是CPU在主线程中花费的时间。x轴表示的是在用户滑动中发生的刷新事件。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-5b3c7220a9742932.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;针对上述掉帧的情况，绘制出实验数据，如下图。值得我们关注的是，曲线是很曲折的，非常的不平滑。当用户大幅度滑动的时候，峰值超过了16ms，当用户慢速滑动的时候，帧率又能保持在比较顺滑的区域。处于绿色区域内的cell加载压力都是很小的。这就是时而掉帧时而顺滑的场景。这种场景下，用户体验是很糟糕的。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-742100ebb16ca993.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;那怎么解决这么问题的呢？我们来看下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-66aee8c339f703c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;
上图中的曲线我们看着就很平缓了，而且这种情况也不会出现掉帧的情况了，每个滑动中的时间都能达到60帧了。这是怎样做到的呢？因为把每个cell的加载事件都平分了，每个cell不会再出现很忙和很闲的两个极端。这样我们就取消了之前的波峰和波谷。从而让该曲线达到近乎水平的直线。&lt;/p&gt;

&lt;p&gt;如何让每个cell都分摊加载任务的压力？这就要谈到新的cell的生命周期了。&lt;/p&gt;

&lt;p&gt;先来看看老的 UICollectionViewCell的声明周期。当用户滑动屏幕，屏幕外有一个cell准备加载显示进来。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-1e6f8e72fba43498.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个时候我们把这个cell从reuse队列里面拿出来，然后调用prepareForReuse方法。这个方法就给了cell时间，用来重置cell，重置状态，刷新cell，加载新的数据。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-c26df5728427d953.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;再滑动，我们就会调用cellForItemAtIndexPath方法了。这个方法里面就是我们开发者自定义的填充cell的方式了。这里会填充data model，然后赋值给cell，再把cell返回给iOS系统。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-91a745c8edf6f8e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;
当cell马上要进入屏幕的时候，就会调用willDisplayCell的方法。这个方法给了我们app最后一次机会，为cell进入屏幕做最后的准备工作。执行完willDisplayCell之后，cell就进入屏幕了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-1339cb009c3810bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;
当cell完全离开屏幕之后，就会调用didEndDisplayingCell方法。以上就是在iOS10之前的整个UICollectionViewCell的生命周期。&lt;/p&gt;

&lt;p&gt;接下来我们就来看看iOS 10的UICollectionViewCell生命周期是怎么样的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-67440aea27bca091.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里还是和iOS9一样的，当用户滑动UICollectionView的时候，需要一个cell，我们就从reuse队列里面拿出一个cell，并调用prepareForReuse方法。注意调用这个方法的时间，当cell还没有进入屏幕的时候，就已经提前调用这个方法了。注意对比和iOS 9的区别，iOS 9 是在cell上边缘马上进入屏幕的时候才调用方法，而这里，cell整个生命周期都被提前了，提前到cell还在设备外面的时候。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-a17f0da0f0c23533.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里还是和之前一样，在cellForItemAtIndexPath中创建cell，填充数据，刷新状态等等操作。注意，这里生命周期也比iOS 9提前了。&lt;/p&gt;

&lt;p&gt;用户继续滑动，这个时候就有不同了！&lt;/p&gt;

&lt;p&gt;这个时候我们并不去调用willDisplayCell方法了！这里遵循的原则是，何时去显示，何时再去调用willDisplayCell。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-84563cde3084c866.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;
当cell要马上就需要显示的时候，我们再调用willDisplayCell方法。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-0f7c0d6a0c5ad1fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;
当整个cell要从UICollectionView的可见区域消失的时候，这个时候会调用didEndDisplayingCell方法。接下来发生的事情和iOS9一样，cell会进入重用队列中。&lt;/p&gt;

&lt;p&gt;如果用户想要显示某个cell，在iOS 9 当中，cell只能从重用队列里面取出，再次走一遍生命周期。并调用cellForItemAtIndexPath去创建或者生成一个cell。&lt;/p&gt;

&lt;p&gt;在iOS 10 当中，系统会把cell保持一段时间。在iOS中，如果用户把cell滑出屏幕后，如果突然又想回来，这个时候cell并不需要再走一段的生命周期了。只需要直接调用willDisplayCell就可以了。cell就又会重新出现在屏幕中。这就是iOS 10 的整个UICollectionView的生命周期。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-38285868d022c65d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-e76c5772fe94b6de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-d98623c78588707f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-aec86f77678e3d84.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-0d966174af80472f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上面说的iOS 10里面的场景同样适用于多列的情况。 这时我们每次只加载一个cell，而不是每次加载一行的cell。当第一个cell准备好之后再叫第二个cell准备。当2个cell都准备好了之后，接着我们再调用willDisplayCell给每个cell，发送完这个消息之后，cell就会出现在屏幕上了。&lt;/p&gt;

&lt;p&gt;这虽然看起来是一个很小的改动，但是这小小的改动就提升了很多的用户体验！&lt;/p&gt;

&lt;p&gt;让我们来看看上述的改动对滑动的影响&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-c832a32902927e60.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;滑动比iOS 9流程很多，这里可以看到整个过程都很平缓，不卡顿。&lt;/p&gt;

&lt;p&gt;还是和iOS 9一样，我们来模拟一下系统是如何加载cell的情况。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-561985a86edbd74a.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们可以很明显的看到，iOS 系统是一个个的加载cell的，一个cell加载完之后再去加载下一个cell。这里和iOS 9 的有很大的不同，iOS 9是加载整整一行的cell。&lt;/p&gt;

&lt;p&gt;这是因为我们用了新的 UICollectionViewCell的生命周期。整个app完全没有加一行代码。现在iOS 10是丝滑的滑动体验实在是太棒了！！&lt;/p&gt;

&lt;h4 id=&quot;uicollectionviewcellpre-fetching&quot;&gt;二. UICollectionViewCell的Pre-Fetching预加载&lt;/h4&gt;

&lt;p&gt;当我们编译iOS 10的app的时候，这个Pre-Fetching默认是enable的。当然，如果有一些原因导致你必须用到iOS 10之前老的生命周期，你只需要给collectionView加入新的isPrefetchingEnabled属性即可。如果你不想用到Pre-Fetching，那么把这个属性变成false即可。
&lt;code class=&quot;highlighter-rouge&quot;&gt;
collectionView.isPrefetchingEnabled = false
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;为了最佳实践一下这个新特性。我们先改变一下我们加载cell的方式。我们把很重的读取数据的操作，所有内容的创建都放到cellForItemAtIndexPath方法里面去完成。保证我们在willDisplayCell 和 didEndDisplayCell这两个方法里面基本不做其他事情。最后，需要注意的是cellForItemAtIndexPath生成的某些cell，可能永远都不会被展示在屏幕上，有这样一种情况，当cell将要展示在屏幕上的时候，用户突然滑动离开了这个界面。&lt;/p&gt;

&lt;p&gt;如果这个时候当你用iOS 10编译出你的app，那么非常顺滑的用户体验就会自动的优化出来。&lt;/p&gt;

&lt;p&gt;UICollectionView的流畅的滑动解决了，那么在UICollectionViewCell在加载的时候所花费的时间，怎么解决呢？？&lt;/p&gt;

&lt;p&gt;UICollectionViewCell加载的时间取决于DataModel。DataModel很可能回去加载图片，来自于网络或者来自于本地的数据库。这些操作大多数都是异步的操作。为了使data加载更快，iOS 10引入了新的API来解决这个问题。&lt;/p&gt;

&lt;p&gt;UICollectionView有2个“小伙伴”，那就是data source和delegate。在iOS 10中，将会迎来第3个“小伙伴”。这个“小伙伴”叫prefetchDataSource。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protocol UICollectionViewDataSourcePrefetching {
    func collectionView(_ collectionView: UICollectionView,
                        prefetchItemsAt indexPaths: [NSIndexPath])
    optional func collectionView(_ collectionView: UICollectionView,
                                 cancelPrefetchingForItemsAt indexPaths: [NSIndexPath])
}
class UICollectionView : UIScrollView {
    weak var prefetchDataSource: UICollectionViewDataSourcePrefetching?
    var isPrefetchingEnabled: Bool
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个协议里面只有一个必须要实现的方法——ColletionView prefetchItemsAt indexPaths。这个方法会在prefetchDataSource里面被调用，用来给你异步的预加载数据的。indexPaths数组是有序的，就是接下来item接收数据的顺序，让我们model异步处理数据更加方便。&lt;/p&gt;

&lt;p&gt;在这个协议里面还有第二个方法CollectionView cancelPrefetcingForItemsAt indexPaths，不过这个方法是optional的。我们可以利用这个方法来处理在滑动中取消或者降低提前加载数据的优先级。&lt;/p&gt;

&lt;p&gt;值得说明的是，新增加的这个“小伙伴”prefetchDataSource并不能代替原来的读取数据的方法，这个预加载仅仅只是辅助加载数据，并不能
删除原来我们读取数据的方法。&lt;/p&gt;

&lt;p&gt;至此，我们来看看从文章开始到现在，UICollectionView的性能提升了多少。我们还是用掉帧的方法来看看UICollectionView的性能。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-5b6b9e2c3350a172.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图是iOS 9 UICollectionView的性能，很明显的看见，波峰波谷很明显，并且还掉了8帧，有明显的卡顿现象。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-0f8356b077664bae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图是iOS 10 UICollectionView的性能，我们可以很明显的看到，经过iOS 10的优化，整个曲线很明显平缓了一些，没有极端的波峰掉帧现象。但是依旧存在少量的波峰快到16ms分界线了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-24bf2be2c051eb80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图是iOS 10 + Pre-Fetching API 之后的性能，已经优化的效果很明显了！整条曲线基本都水平了。近乎完美。但是还是能发现有个别波峰特别高。波峰特别高的地方就是那个cell加载压力大，时间花的比较长导致的。接下来我们继续优化！&lt;/p&gt;

&lt;p&gt;先来总结一下使用Pre-Fetching API需要注意的地方。
1. 在我们使用Pre-Fetching API的时候，我们一定要保证整个预加载的过程都放在后台线程中进行。合理使用GCD 和 NSOperationQueue处理好多线程。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;请切记，Pre-Fetching API是一种自适应的技术。何为自适应技术呢？当我们滑动速度很慢的时候，在这种“安静”的时期，Pre-Fetching API会默默的在后台帮我们预加载数据，但是一旦当我们快速滑动，我们需要频繁的刷新，我们不会去执行Pre-Fetching API。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;最后，用cancelPrefetchingAPI去迎合用户的滑动动作的变换，比如说用户在快速滑动突然发现了有趣的感兴趣的事情，这个时候停下来滑动了，甚至快速反向滑动了，或者点击了事件，进去看详情了，这些时刻我们都应该开启cancelPrefetchingAPI。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;综上所述，Pre-Fetching API对于提高UICollectionView的性能提升是很有帮助的，而且并不需要加入太多的代码。加入少量的代码就可以获得巨大的性能提升！&lt;/p&gt;

&lt;h4 id=&quot;uitableviewcellpre-fetching&quot;&gt;三. UITableViewCell的Pre-Fetching预加载&lt;/h4&gt;

&lt;p&gt;在iOS 10中，UITableViewCell也跟着UICollectionView一起得到了性能的提升，一样拥有了Pre-Fetching API。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protocol UITableViewDataSourcePrefetching {
    func tableView(_ tableView: UITableView, prefetchRowsAt indexPaths: [NSIndexPath])
    optional func tableView(_ tableView: UITableView, cancelPrefetchingForRowsAt indexPaths:
                            [NSIndexPath])
}
class UITableView : UIScrollView {
    weak var prefetchDataSource: UITableViewDataSourcePrefetching?
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里和上面 UICollectionView一样，会调用TableView prefetchRowsAt indexPaths方法。indexPaths还是一个有序数字，顺序就是列表上可见的顺序。第二个可选的API还是TableView cancelPrefetchingForRowsAt indexPaths，和之前提到的一样，也是用来取消预加载的。性能的提升和UICollectionView一样的，对UITableView的性能提升很大！&lt;/p&gt;

&lt;h4 id=&quot;self-sizing&quot;&gt;四. 针对self-sizing的改进&lt;/h4&gt;

&lt;p&gt;self-sizing API 第一次被引入是在iOS 8，然而现在在iOS 10中得到了一些改进。&lt;/p&gt;

&lt;p&gt;在UICollectionView 中有一个固定的类，叫UICollectionViewFlowLayout，iOS已经在这个类中完全支持了self-sizing。为了能开启这一特性，需要我们开发者为一些不能为0的CGSize的cell设置一下estimated item size。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
layout.estimatedItemSize = CGSize(width:50,height:50)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这会告诉UICollectionView我们想要开启动态计算内容的布局。&lt;/p&gt;

&lt;p&gt;至今，我们能有3种方法来动态的布局。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;第一种方法是使用autolayout
当我们合理的加上了constrain，当cell加载的时候，就会根据内容动态的加载布局。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第二种方法，如果你不想使用autolayout的方法，想更加手动的控制它，那么我们就需要重写sizeThatFits()方法。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第三种方法，终极的方法是重写preferredLayoutAttributesFittingAttributes()方法。在这个方法里面不仅仅可以提供size的信息，更可以得到alpha和transform的信息。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;所以想指定cell的大小，就可以用上面3个方法之一。&lt;/p&gt;

&lt;p&gt;但是实际操作中，我们可以发现，有时候设置一个合适的estimated item size，对于我们来说是很困难的事情。如果flow layout可以用数学的方法动态的计算布局，而不是根据我们给的size去布局，那会是件很酷的事情。&lt;/p&gt;

&lt;p&gt;iOS 10中就引入了新的API来解决上述的问题。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;layout.estimatedItemSize = UICollectionViewFlowLayoutAutomaticSize
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;对于开发者，我们需要做的事情，仅仅就是设置好flow layout ，然后给estimatedItemSize设定一个新的常数, 最后UICollectionViewFlowLayout 就会自动计算高度了。&lt;/p&gt;

&lt;p&gt;系统会自动计算好所有的布局，包括已经定下来的size的cell，并且还会动态的给出接下来cell的大小的预测。&lt;/p&gt;

&lt;p&gt;接下来看2个例子就可以很明显看出iOS 10针对self-sizing的改进了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-8c9bad76b1cf453c.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图可以看到，iOS 9 的布局是针对单个cell计算的，当改变了单个的cell，其他的cell依旧没有变化，还是需要重新计算。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-38a291c2d0daacc0.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里例子就可以很明显的看出差别了。当我们改变了第一个cell的size以后，系统会自动计算出所有的cell的size，并且每一行，每一个section的size都会被动态的计算出来，并且刷新界面！&lt;/p&gt;

&lt;p&gt;以上就是iOS 10针对self-sizing的改进。&lt;/p&gt;

&lt;h4 id=&quot;interactive-reordering&quot;&gt;五. Interactive Reordering&lt;/h4&gt;

&lt;p&gt;谈到重新排列，这是我们就需要类比一下UITableView了，UICollectionView的重新排列就如同UITableView 把cell上下移动，只不过UITableView的重排是针对垂直方向的。&lt;/p&gt;

&lt;p&gt;在iOS 9中，引入了UICollectionView的Interactive Reordering，在今年的iOS 10中，又加入了一些新的API。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-fedd66fb206d0beb.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在上图中，我们可以看到，我们即使任意拖动cell，整个界面也会重新排列，并且我们改变了cell的大小，整个 UICollectionView 也会重新动态的布局。&lt;/p&gt;

&lt;p&gt;我们先来看看iOS 9里面的API&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
class UICollectionView : UIScrollView {
    func beginInteractiveMovementForItem(at indexPath: NSIndexPath) -&amp;gt; Bool
    func updateInteractiveMovementTargetPosition(_ targetPosition: CGPoint)
    func endInteractiveMovement()
    func cancelInteractiveMovement()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;要想开启interactive movement，我们就需要调用beginInteractiveMovementForItem()方法，其中indexPath代表了我们将要移动走的cell。接着每次手势的刷新，我们都需要刷新cell的位置，去响应我们手指的移动操作。这时我们就需要调用updateInteractiveMovementTargetPosition()方法。我们通过手势来传递坐标的变化。当我们移动结束之后，就会调用endInteractiveMovement()方法。 UICollectionView 就会放下cell，处理完整个layout，此时你也可以重新刷新model或者处理数据model。如果中间突然手势取消了，那么这个时候就应该调用cancelInteractiveMovement()方法。如果我们重新把cell移动一圈之后又放回原位，其实就是取消了移动，那这个时候就应该在cancelInteractiveMovement()方法里面不用去刷新data source。&lt;/p&gt;

&lt;p&gt;在iOS 10中，如果你使用UICollectionViewController，那么这个重排对于你来说会更加的简单。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
class UICollectionViewController : UIViewController {
    var installsStandardGestureForInteractiveMovement: Bool
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;你只需要把installsStandardGestureForInteractiveMovement这个属性设置为True即可。CollectionViewController会自动为你加入手势，并且自动为你调用上面的方法。&lt;/p&gt;

&lt;p&gt;以上就是去年iOS 9为我们增加的API。&lt;/p&gt;

&lt;p&gt;今年的iOS 10新加入的API是在iOS 9的基础上增加了翻页的功能。&lt;br /&gt;
UICollectionView继承自UIScrollView，所以只需要你做的是把isPagingEnabled属性设置为True，即可开启分页的功能。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
collectionView.isPagingEnabled = true
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;开启分页之前：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-843decaf48445ce9.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;开启分页之后就长这样子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-7d2a6304b914cc59.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每次移动一次就会以页为单位的翻页。&lt;/p&gt;

&lt;h4 id=&quot;uirefreshcontrol&quot;&gt;六.UIRefreshControl&lt;/h4&gt;

&lt;p&gt;UIRefreshControl现在可以直接在CollectionView里面使用，同样的，也可以直接在UITableView里面使用，并且可以脱离UITableViewController。因为现在RefreshControl成为了ScrollView的一个属性了。&lt;/p&gt;

&lt;p&gt;UIRefreshControl的使用方法很简单，就三步：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
let refreshControl = UIRefreshControl()
refreshControl.addTarget(self, action: #selector(refreshControlDidFire(_:)),
                         for: .valueChanged)
collectionView.refreshControl = refreshControl
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;先创建一个refreshControl，再关联一个action事件，最后把这个新的refreshControl赋给想要的控件的对应的属性即可。&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;总结&lt;/h4&gt;

&lt;p&gt;通过以上，我们谈到了以下的知识：&lt;br /&gt;
1. UICollectionView cell pre-fetching预加载机制&lt;br /&gt;
2. UICollectionView and UITableView prefetchDataSource 新增的API &lt;br /&gt;
3. 针对self-sizing cells 的改进&lt;br /&gt;
4. Interactive reordering&lt;/p&gt;

&lt;p&gt;最后，谈谈我看了iOS 10 UICollectionView的优化的看法吧，原来有些地方用到AsyncDisplayKit优化UICollectionView速度的，现在可以考虑不用第三方库优化了，系统自带的方法可以解决一般性的卡顿的问题了。我感觉iOS 10的UICollectionView才像是一个完整版的，之前的系统优化的都不够。我还是很看好iOS 10的UICollectionView。&lt;/p&gt;

&lt;p&gt;请大家多多指教。&lt;/p&gt;
</description>
        <pubDate>Mon, 04 Jul 2016 01:02:00 +0800</pubDate>
        <link>http://vno.onevcat.com/2016/07/WWDC2016-Session%E7%AC%94%E8%AE%B0-iOS-10-UICollectionView%E6%96%B0%E7%89%B9%E6%80%A7/</link>
        <guid isPermaLink="true">http://vno.onevcat.com/2016/07/WWDC2016-Session%E7%AC%94%E8%AE%B0-iOS-10-UICollectionView%E6%96%B0%E7%89%B9%E6%80%A7/</guid>
        
        <category>iOS</category>
        
        
        <category>Blog</category>
        
      </item>
    
      <item>
        <title>WWDC2016 Session笔记 - iOS 10  推送Notification新特性</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-520084e0dda3ed1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;前言&lt;/h4&gt;
&lt;p&gt;在今年6月14号苹果WWDC开发者大会上，苹果带来了新的iOS系统——iOS 10。苹果为iOS 10带来了十大项更新。苹果高级副总裁Craig Federighi称此次对iOS的更新是“苹果史上最大的iOS更新”。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-4416fe3f0633a60e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;新的屏幕通知查看方式：苹果为iOS 10带来了全新的通知查看功能，即抬起iPhone的屏幕，用户就能看到目前的通知和更新情况。&lt;/li&gt;
  &lt;li&gt;苹果将Siri开放给第三方开发者: 现在用户可以让Siri实现更多的功能，例如让Siri向自己的联系人发送微信信息等。目前Siri可以直接支持的应用有微信、WhatsApp以及Uber、滴滴、Skype等。&lt;/li&gt;
  &lt;li&gt;Siri将会更加智能：Siri将拥有更多对语境的意识。基于用户的地点、日历、联系人、联系地址等，Siri会做出智能建议。Siri将越来越成为一个人工智能机器人，具备深度学习功能。&lt;/li&gt;
  &lt;li&gt;照片应用更新：基于深度学习技术，iOS 10对照片应用有比较大的更新。iOS 10对照片的搜索能力进一步增强，可以检测到新的人物和景色。未来的iPhone能够将相关的照片组织在一起，比如某次旅行的照片、某个周末的照片，并且能够进行自动编辑。iOS 10照片还新增了一个“记忆”标签。&lt;/li&gt;
  &lt;li&gt;苹果地图：有点类似Siri和照片的更新，苹果地图也增加了很多预测功能，例如苹果地图能够将提供附近的餐厅建议。苹果地图的界面也得到了重新设计，更加的简洁，并增加了交通实时信息。新的苹果地图还将整合在苹果CarPlay中，将为用户提供turn-by-turn导航功能。和Siri一样，地图也将开放给开发者。&lt;/li&gt;
  &lt;li&gt;苹果音乐：苹果音乐的界面得到了更新，界面会更加简洁、支持多任务，增加最近播放列表。苹果音乐现在已经有1500万付费用户。&lt;/li&gt;
  &lt;li&gt;HomeKit：iOS 10新增智能家庭应用，支持一键场景模式，HomeKit可以与Siri相连接。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-dd5070c430b37cc7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;苹果电话：苹果更新了电话功能，来电时可以区别出骚扰电话。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-20115aefabb1c770.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;iMesseage：在iMessage方面，用户可以直接在文本框内发送视频、链接，分享实时照片。另外，苹果还增添了表情预测功能，打出的文字若和表情相符，将会直接推荐相关表情。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以下是我关于关于iOS 10中变化比较大的推送通知的学习笔记。&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;目录&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;1.Notification User Interface&lt;/li&gt;
  &lt;li&gt;2.Media Attachments&lt;/li&gt;
  &lt;li&gt;3.Customize user interface&lt;/li&gt;
  &lt;li&gt;4.Customize Actions&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;notification-user-interface&quot;&gt;一. Notification User Interface&lt;/h4&gt;
&lt;p&gt;让我们先来看看用户推送在iOS X中的样子，如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-3439e7712872c625.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图这是在锁屏界面下的推送。支持抬起手机唤醒功能。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-a74bf10dc32c739b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;
上图是Banner，可以看到这个推送更加的易读，并且包含更多的内容。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-d9dbd2a57d18d8ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图是通知中心。从上面三种图可以看到，它们都长一个样。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-55e35bda6f792759.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在iOS 8 中，我们可以给推送增加用户操作，这样使推送更加具有交互性，并且允许用户去处理用户推送更加的迅速。到了iOS 9 中，苹果又再次增加了快速回复功能，进一步的提高了通知的响应性。开发者可以允许用户通过点击推送，并用文字进行回复。再就到了iOS 10 中，推送变得更加给力。因为在iOS X中，推送对iOS系统来说，是很重要的一部分。在日常使用中，我们会经常和推送打交道。推送是我们和设备进行互动非常重要的方式。&lt;/p&gt;

&lt;p&gt;在iOS X 中，你可以按压推送，推送就会被展开，展示出更加详细的用户界面。展示出来的详细界面对用户来说，提供了更加有用的信息。用户可以通过点击下面的按钮，来处理一些事件，并且推送的详细界面也会跟着用户的操作进行更新UI界面。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-28f89dc9b23bb018.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;iOS 8 中iMessage支持了快速回复功能，但是你只能看见一条信息，并且你也只能回复一条信息。但是在iOS X中，你可以展开推送，这个时候你就可以看到整个对话的内容了。你可以等待你的朋友回复，你再回复他，并且可以回复很多条。&lt;/p&gt;

&lt;p&gt;以上就是iOS X的强大功能。以上的所有功能都能通过iOS X的新API来实现。所有的新特性都能在我们开发者开发的app里面有所体现。&lt;/p&gt;

&lt;h4 id=&quot;media-attachments&quot;&gt;二. Media Attachments&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-51beb1aaef4af5ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果经常使用iMessage的朋友们，就会经常收到一些信息，附带了一些照片或者视频，所以推送中能附带这些多媒体是非常重要的。如果推送中包含了这些多媒体信息，可以使用户不用打开app，不用下载就可以快速浏览到内容。众所周知，推送通知中带了push payload，及时去年苹果已经把payload的size提升到了4k bites，但是这么小的容量也无法使用户能发送一张高清的图片，甚至把这张图的缩略图包含在推送通知里面，也不一定放的下去。在iOS X中，我们可以使用新特性来解决这个问题。我们可以通过新的service extensions来解决这个问题。&lt;/p&gt;

&lt;p&gt;为了能去下载service extension 里面的attachment，我们必须去按照如下的要求去设置你的推送通知，使你的推送通知是动态可变的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;aps:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;{……&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;mutable-content&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;my-attachment&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;https://example.com/phtos.jpg&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;在上面代码中，可以看到加载了一个mutable-content 的flag，然后我们就可以引用一个链接，把你想加入到推送里面的attachments加入到里面来。在上面的例子里面，我们就加入了一个URL。更复杂的，你甚至可以去加入一个identifier来标示你想加入到推送里面的内容，这个identifier是你app知道的，app能通过拿到identifier，然后知道去你自己的服务器哪里去下载内容。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-ba7069e754c5bcf8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过设置完上述的部分，推送就被推送到了每个设备的Service Extension那里了。在每个设备里面的Service Extension里面，就可以下载任意想要的attachment了。然后推送就会带着下载好的attachment推送到手机并显示出来了。&lt;/p&gt;

&lt;p&gt;如果来设置Service Extension呢？来看看如下的代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
// Adding an attachment to a user notification

public class NotificationService: UNNotificationServiceExtension {
    override public func didReceive(_ request: UNNotificationRequest, withContentHandler contentHandler: (UNNotificationContent) -&amp;gt; Void)
    {
        let fileURL = // ...
        let attachment = UNNotificationAttachment(identifier: &quot;image&quot;,
                                                  url: fileURL,
                                                  options: nil)
        let content = request.content.mutableCopy as! UNMutableNotificationContent 
        content.attachments = [ attachment ]
        contentHandler(content)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;首先定义了一个didReceive的方法，用来接收request，后面跟着withContentHandler的回调函数。
这个NotificationServiceExtension会在收到推送之后，被调用，然后在这个方法里面去下载自己的attachment。下载可以通过URL，或者任何你喜欢的方式。当下载完成之后，就可以创建attachment对象了。创建完UNMutableNotificationContent，我们就可以把这个加入到推送的content中了。最后，通过contentHandler回调，把它传递给iOS系统，iOS 系统就会展示给用户。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-a02ca43edd228bc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过以上的设置，我们就能在推送中看到丰富的媒体信息了。用户并不需要去打开app，也不用去点击下载。&lt;/p&gt;

&lt;p&gt;简单的概述一下Media Attachments：&lt;br /&gt;
1. 新特性使推送支持附带Media Attachments。本地推送和远程推送同时都可支持。&lt;br /&gt;
2. attachment支持图片，音频，视频，系统会自动提供一套可自定义化的UI，专门针对这3种内容。&lt;br /&gt;
3. 在service extension里面去下载attachment，但是需要注意，service extension会限制下载的时间，并且下载的文件大小也会同样被限制。这里毕竟是一个推送，而不是把所有的内容都推送给用户。所以你应该去推送一些缩小比例之后的版本。比如图片，推送里面附带缩略图，当用户打开app之后，再去下载完整的高清图。视频就附带视频的关键帧或者开头的几秒，当用户打开app之后再去下载完整视频。&lt;br /&gt;
4. 把下载完成的attachment加入到notification中。  &lt;br /&gt;
5. 推送里面包含的attachment这些文件，是由系统帮你管理的，系统会把这些文件放在单独的一个地方，然后统一管理。&lt;br /&gt;
6. 额外说明一点，推送的attachment的图片还可以包含GIF图。&lt;/p&gt;

&lt;p&gt;通过以上可以看出，Media Attachments非常的酷，它为我们提供了更加丰富的推送内容。&lt;/p&gt;

&lt;p&gt;接下来我们再来看看如何自定义推送的用户界面&lt;/p&gt;

&lt;h4 id=&quot;customize-user-interface&quot;&gt;三. Customize user interface&lt;/h4&gt;

&lt;p&gt;要想创建一个自定义的用户界面，需要用到Notification content extension。&lt;/p&gt;

&lt;p&gt;先来说说下面这个例子的应用场景：&lt;/p&gt;

&lt;p&gt;比如有个朋友在日历中给我了一个聚会的邀请，这个时候就来了推送，推送里面的内容就是包含了聚会的时间地点信息，推送下面有三个按钮，接受，谢绝。下面的例子都以此为例。&lt;/p&gt;

&lt;p&gt;Notification content extension允许开发者加入自定义的界面，在这个界面里面，你可以绘制任何你想要的东西。但是有一个最重要的限制就是，这个自定义的界面没有交互。它们不能接受点击事件，用户并不能点击它们。但是推送通知还是可以继续与用户进行交互，因为用户可以使用notificaiton的actions。extension可以处理这些actions。&lt;/p&gt;

&lt;p&gt;接下来我们就来说说如何自定义界面&lt;/p&gt;

&lt;h5 id=&quot;section-2&quot;&gt;1.   推送的四部分&lt;/h5&gt;

&lt;p&gt;先来看一个日历的推送例子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-15b9cc813f3c40cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图，整个推送分4段。用户可以通过点击Header里面的icon来打开app，点击取消来取消显示推送。Header的UI是系统提供的一套标准的UI。这套UI会提供给所有的推送通知。&lt;/p&gt;

&lt;p&gt;Header下面是自定义内容，这里就是显示的Notification content extension。在这里，就可以显示任何你想绘制的内容了。你可以展示任何额外的有用的信息给用户。&lt;/p&gt;

&lt;p&gt;content extension下面就是default content。这里是系统的界面。这里的系统界面就是上面推送里面payload里面附带的内容。这也就是iOS 9 之前的推送的样子。&lt;/p&gt;

&lt;p&gt;最下面一段就是notification action了。在这一段，用户可以触发一些操作。并且这些操作还会相应的反映到上面的自定义的推送界面content extension中。&lt;/p&gt;

&lt;h5 id=&quot;notification-content-extension&quot;&gt;2.创建Notification content extension&lt;/h5&gt;

&lt;p&gt;接下来我们就来看看如何创建一个Notification content extension&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-b8b69cdab7aee38e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;第一件事就是去创建一个新的target。创建好了之后，Xcode会自动帮我们生成一个template。template会在新的target里面生成3个文件，一个新的ViewController，main Interface storyboard，info.plist。info.plist中就是可以定义化一些target的配置。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-bffc21df9faf33e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;打开Notification content extension的ViewController&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
// Minimal Content Extension
class NotificationViewController: UIViewController, UNNotificationContentExtension {
    @IBOutlet var label: UILabel?
    override func viewDidLoad() {
        super.viewDidLoad()
        // Do any required interface initialization here.
    }
    func didReceive(_ notification: UNNotification) {
        label?.text = notification.request.content.body
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;我们会发现，这个ViewController是UIViewController的子类，其实就是一个很普通的ViewController，和我们平时使用的没有啥两样。后面是UNNotificationContentExtension的protocol，这里是系统要求你必须实现的协议。&lt;/p&gt;

&lt;p&gt;UNNotificationContentExtension只有一个required的方法，就是didReceive方法。当推送到达你的设备之后，这个didReceive方法会随着ViewController的生命周期的方法 ，一起被调用。当开发者给推送加上expands的时候，一旦推送送达以后，这时会接到所有的ViewController生命周期的方法，和didReceive方法。这样，我们就可以接收notification object ，接着更新UI。&lt;/p&gt;

&lt;h5 id=&quot;target&quot;&gt;3. 配置target&lt;/h5&gt;
&lt;p&gt;接下来，我们需要做的是，告诉iOS系统，推送送达之后，iOS系统如何找到你自定义的Notification content extension。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-9cafc7af30c557d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Notification content extension和我们注册notification actions一样，注册的相同的category。这个例子中，我们使用event-invite。值得提到的一点是，这里的extension是可以为一个数组的，里面可以为多个category，这样做的目的是多个category共用同一套UI。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-33d02a0c6572c81b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图中，event-invite 和 event-update就共用了一套UI。这样我们就可以把他们打包到一个extension里面来。但是不同的category是独立的，他们可以相应不同的actions。&lt;/p&gt;

&lt;p&gt;通过以上设置，iOS系统就知道了我们的target了。&lt;/p&gt;

&lt;h5 id=&quot;ui&quot;&gt;4. 自定义用户UI界面&lt;/h5&gt;

&lt;p&gt;接下来我们来自定义UI界面。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
// Notification Content Extension
class NotificationViewController: UIViewController, UNNotificationContentExtension {
    @IBOutlet var eventTitle: UILabel!
    @IBOutlet var eventDate: UILabel!
    @IBOutlet var eventLocation: UILabel!
    @IBOutlet var eventMessage: UILabel!
    
    func didReceive(_ notification: UNNotification) {
        let content = notification.request.content
        
        eventTitle.text = content.title
        eventDate.text = content.subtitle
        eventMessage.text = content.body
        
        if let location = content.userInfo[&quot;location&quot;] as? String {
            eventLocation.text = location
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上述代码中，我们在stroyboard 里面加入了一些labels 。当接收到推送的时候，我们提取出内容，得到我们想要的内容，然后把这些内容设置到label上面去，并展示出来。在content的userinfo里面我们还能加入一些额外的信息，这些信息是标准的payload无法展示的，比如说位置信息等等。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-c1962c798ad01273.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;代码完成之后就是如上的样子，中间就是我们自定义的UIView了。但是这样子会有2个问题。第一个问题就是这个自定义的View实在太大了。大量的空白不需要显示出来。第二个问题就是我们自定义的内容和下面默认的推送内容重复了。我们需要去掉一份。&lt;/p&gt;

&lt;h5 id=&quot;section-3&quot;&gt;5.改进&lt;/h5&gt;

&lt;p&gt;我们先来改进上面说的第二个问题。
这个问题很简单，其实就是一个plist的设置。我们可以在plist里面把默认的content隐藏。设置如下图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-b4dc0be29fdce509.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;再来说说第一个问题，界面大小的问题。
我们可以通过平时我们Resize其他ViewController一样，来Resize这个ViewController。来看看如下的代码。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
// Notification Content Extension
class NotificationViewController: UIViewController, UNNotificationContentExtension {
    override func viewDidLoad() {
        
        super.viewDidLoad()
        let size = view.bounds.size
        
        preferredContentSize = CGSize(width: size.width, height: size.width / 2)
    }
    
    func didReceive(_ notification: UNNotification) {
        // ...
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里我们也可以加入constraints来做autolayout。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-7f7cc4a4fc88a599.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;解决完上面2个问题，界面就会变成这个样子。看上去比之前好很多了。正常的尺寸，没有多余的空白。没有重复信息。但是这又出现了另外一个问题。当通知展示出来之后，它的大小并不是正常的我们想要的尺寸。iOS系统会去做一个动画来Resize它的大小。如下图，系统会先展现出第一张图，然后紧接着展示第二张图，这个用户体验很差。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-7d887c3b6ec3fe57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-20779263e0de3c19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;会出现上面这张图的原因是，在推送送达的那一刻，iOS系统需要知道我们推送界面的最终大小。但是我们自定义的extension在系统打算展示推送通知的那一刻，并还没有启动。所以这个时候，在我们代码都还没有跑起来之前，我们需要告诉iOS系统，我们的View最终要展示的大小。&lt;/p&gt;

&lt;p&gt;现在问题又来了。这些通知会跑在不同的设备上，不同的设备的屏幕尺寸不同。为了解决这个问题，我们需要设置一个content size ratio。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-e7cd9adac20e2730.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个属性定义了宽和高的比例。当然设置了这个比例以后，也并不是万能的。因为你并不知道你会接受到多长的content。当你仅仅只设置比例，还是不能完整的展示所有的内容。有些时候如果我们可以知道最终的尺寸，那么我们固定尺寸会更好。&lt;/p&gt;

&lt;h5 id=&quot;section-4&quot;&gt;6. 进一步美化&lt;/h5&gt;

&lt;p&gt;我们可以给这个extension加上Media Attachments。一旦我们加入Media Attachments，我们可以在content extension里面使用这些内容。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
// Notification Content Extension Attachments
class NotificationViewController: UIViewController, UNNotificationContentExtension {
    @IBOutlet var eventImage: UIImageView!
    func didReceive(_ notification: UNNotification) {
        let content = notification.request.content
        if let attachment = content.attachments.first {
            if attachment.url.startAccessingSecurityScopedResource() {
                eventImage.image = UIImage(contentsOfFile: attachment.url.path!)
                attachment.url.stopAccessingSecurityScopedResource()
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;我们可以提取content的attachments。前文提到过，attachment是由系统管理的，系统会把它们单独的管理，这意味着它们存储在我们sandbox之外。所以这里我们要使用attachment之前，我们需要告诉iOS系统，我们需要使用它，并且在使用完毕之后告诉系统我们使用完毕了。对应上述代码就是startAccessingSecurityScopedResource()和stopAccessingSecurityScopedResource()的操作。当我们获取到了attachment的使用权之后，我们就可以使用那个文件获取我们想要的信息了。&lt;/p&gt;

&lt;p&gt;上述例子中，我们从attachment中获取到图片，并展示到UIImageView中。于是notification就变成下面这个样子了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-4640a3c616c41b8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;customize-actions&quot;&gt;四.Customize Actions&lt;/h4&gt;

&lt;p&gt;说道这里，我们不得不说一下iOS8开始引入的action的工作原理：
默认系统的Action的处理是，当用户点击的按钮，就把action传递给app，与此同时，推送通知会立即消失。这种做法很方便。&lt;/p&gt;

&lt;p&gt;但是还有一种情况，当用户点击了按钮，希望接受一些日历上的邀请，我们需要把这个操作即时的展示在我们自定义的UI上，这是我们就只能用Notification content extension来处理这些用户点击事件了。这个时候，用户点击完按钮，我们把这个action直接传递给extension，而不是传递给app。当actions传递给extension时，它可以延迟推送通知的消失时间。在这段延迟的时间之内，我们就可以处理用户点击按钮的事件了，并且更新UI，一切都处理完成之后，我们再去让推送通知消失掉。&lt;/p&gt;

&lt;p&gt;这里我们可以运用UNNotificationContentExtension协议的第二个方法，这方法是Optional&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
// Intercepting notification action response
class NotificationViewController: UIViewController, UNNotificationContentExtension {
    func didReceive(_ response: UNNotificationResponse, completionHandler done: (UNNotificationContentExtensionResponseOption) -&amp;gt; Void) {
        server.postEventResponse(response.actionIdentifier) {
            if response.actionIdentifier == &quot;accept&quot; {
                eventResponse.text = &quot;Going!&quot;
                eventResponse.textColor = UIColor.green()
            } else if response.actionIdentifier == &quot;decline&quot; {
                eventResponse.text = &quot;Not going :(&quot;
                eventResponse.textColor = UIColor.red()
            }
            done(.dismiss)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;不用这个方法的时候就可以不声明出来。但是一旦声明了，那么你就需要在这个方法里面处理推送通知里面所有的actions。这就意味着你不能只处理一个action，而不管其他的action。&lt;/p&gt;

&lt;p&gt;在上述代码中，当用户点击了按钮，这个时候我们同步一下服务器信息，当接收到了服务器应答之后，然后我们更新UI。用户点击了“accept”之后，表示接受了这次聚会邀请，于是我们把text的颜色变成绿色。当用户点击了“decline”，表示谢绝，于是我们把text的颜色变成红色。当用户点击之后，更新完界面，我们就让推送通知消失掉。&lt;/p&gt;

&lt;p&gt;这里值得一提的是，如果你还想把这个action传递给app，那么最后的参数应该是这样。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;done(.dismissAndForwardAction)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;参数设置成这样之后，用户的action就会再传递给app。&lt;/p&gt;

&lt;p&gt;如果此时用户还想输入写文字来评论这条推送，我们该如何做？&lt;/p&gt;

&lt;p&gt;这个输入文字的需求是来自于iOS 9 。这个的使用方法和9是相同的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
// Text Input Action
private func makeEventExtensionCategory() -&amp;gt; UNNotificationCategory {
    let commentAction = UNTextInputNotificationAction(
        identifier: &quot;comment&quot;,
        title: &quot;Comment&quot;,
        options: [],
        textInputButtonTitle: &quot;Send&quot;,
        textInputPlaceholder: &quot;Type here...&quot;)
    return UNNotificationCategory(identifier: &quot;event-invite&quot;, actions: [ acceptAction, declineAction, commentAction ],
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;我们可以创建一个UNTextInputNotificationAction，并把它设置到plist里面的Category中。当推送通知到来之后，用户点击了按钮，textfield就会显示出来。同样的处理action代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
// Text input action response
class NotificationViewController: UIViewController, UNNotificationContentExtension {
    func didReceive(_ response: UNNotificationResponse,
                      completionHandler done: (UNNotificationContentExtensionResponseOption) -&amp;gt; Void) {
        if let textResponse = response as? UNTextInputNotificationResponse {
            server.send(textResponse.userText) {
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个时候当用户点击了评论按钮，就会弹出textfield。&lt;/p&gt;

&lt;p&gt;这里还有一个问题，就是用户点完评论按钮之后，之前的接受和谢绝的按钮就消失了。这个时候用户可能有这个需求，想又评论，又接受或者谢绝。那么我们就需要在下面键盘上加入这两个按钮。如下图这样子。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-68965591c8c9c0c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里并没有新的API，还是用原来的API。我们可以使用已经存在的UIKit的API去定制输入的input accessory view。它可以让我们开发者加入自定义的按钮。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
// Custom input accessory view
class NotificationViewController: UIViewController, UNNotificationContentExtension {
    override func canBecomeFirstResponder() -&amp;gt; Bool {
        return true
    }
    override var inputAccessoryView: UIView { get {
        return inputView
        }
    }
    func didReceive(_ response: UNNotificationResponse,
                      completionHandler done: (UNNotificationContentExtensionResponseOption) -&amp;gt; Void) {
        if response.actionIdentifier == &quot;comment&quot; {
            becomeFirstResponder()
            textField.becomeFirstResponder()
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;解析一下上述的代码。首先我们需要让ViewController BecomeFirstResponder。这里做了2件事情，一是告诉responder chain，我成为了第一响应者，二是告诉iOS系统，我不想使用系统标准的text field。接着就可以创建自定义化的inputAccessoryView。如上图中显示的，带自定义的两个按钮。然后，当extension接受到了用户点击按钮后产生的action，这时自定义的textfield就会变成第一响应者，并且伴随着键盘的弹起。&lt;/p&gt;

&lt;p&gt;注意，这里需要2个becomeFirstResponder，第一个becomeFirstResponder是使viewController变成第一响应者，这样textfield就会出现。第二个becomeFirstResponder是使我们自定义的textfield变成第一响应者，这样键盘才会弹起。&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;以上就是iOS X中notification的所有新特性，通过上文，我们学到的以下的知识，总结一下：&lt;br /&gt;
1. 什么是attachment&lt;br /&gt;
2. 如何在service extension中使用attachment&lt;br /&gt;
3. 如何定义content extension的用户UI界面&lt;br /&gt;
4. 如何响应用户操作action&lt;/p&gt;

&lt;p&gt;最后，请大家多多指教。&lt;/p&gt;
</description>
        <pubDate>Sun, 26 Jun 2016 21:21:00 +0800</pubDate>
        <link>http://vno.onevcat.com/2016/06/WWDC2016-Session%E7%AC%94%E8%AE%B0-iOS-10-%E6%8E%A8%E9%80%81Notification%E6%96%B0%E7%89%B9%E6%80%A7/</link>
        <guid isPermaLink="true">http://vno.onevcat.com/2016/06/WWDC2016-Session%E7%AC%94%E8%AE%B0-iOS-10-%E6%8E%A8%E9%80%81Notification%E6%96%B0%E7%89%B9%E6%80%A7/</guid>
        
        <category>iOS</category>
        
        
        <category>Blog</category>
        
      </item>
    
      <item>
        <title>iOS如何优雅的处理“回调地狱Callback hell”(二)——使用Swift</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-a590ae3efef185d3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;前言&lt;/h4&gt;
&lt;p&gt;在上篇中，我谈到了可以用promise来解决Callback hell的问题，这篇我们换一种方式一样可以解决这个问题。&lt;/p&gt;

&lt;p&gt;我们先分析一下为何promise能解决多层回调嵌套的问题，经过上篇的分析，我总结也一下几点：&lt;/p&gt;

&lt;p&gt;1.promise封装了所有异步操作，把异步操作封装成了一个“盒子”。&lt;br /&gt;
2.promise提供了Monad，then相当于flatMap。&lt;br /&gt;
3.promise的函数返回对象本身，于是就可形成链式调用&lt;/p&gt;

&lt;p&gt;好了，既然这些能优雅的解决callback hell，那么我们只要能做到这些，也一样可以完成任务。到这里大家可能就已经恍然大悟了，Swift就是完成这个任务的最佳语言！Swift支持函数式编程，分分钟就可以完成promise的基本功能。&lt;/p&gt;

&lt;h4 id=&quot;swiftcallback-hell&quot;&gt;一.利用Swift特性处理回调Callback hell&lt;/h4&gt;

&lt;p&gt;我们还是以上篇的例子来举例，先来描述一下场景：
假设有这样一个提交按钮，当你点击之后，就会提交一次任务。当你点下按钮的那一刻，首先要先判断是否有权限提交，没有权限就弹出错误。有权限提交之后，还要请求一次，判断当前任务是否已经存在，如果存在，弹出错误。如果不存在，这个时候就可以安心提交任务了。&lt;/p&gt;

&lt;p&gt;那么代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func requestAsyncOperation(request : String , success : String -&amp;gt; Void , failure : NSError -&amp;gt; Void)
{
    WebRequestAPI.fetchDataAPI(request, success : { result in
        WebOtherRequestAPI.fetchOtherDataAPI ( result ,  success : {OtherResult in
            [self fulfillData:OtherResult];
            
            let finallyTheParams = self.transformResult(OtherResult)
            TaskAPI.fetchOtherDataAPI ( finallyTheParams , success : { TaskResult in
                
                let finallyTaskResult = self.transformTaskResult(TaskResult)
                
                success(finallyTaskResult)
                },
                failure:{ TaskError in
                    failure(TaskError)
                }
                
            )
            },failure : { ExistError in
                failure(ExistError)
            }
        )
        } , failure : { AuthorityError in
            failure(AuthorityError)
        }
    )
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;接下来我们就来优雅的解决上述看上去不好维护的Callback hell。&lt;/p&gt;

&lt;p&gt;1.首先我们要封装异步操作，把异步操作封装到Async中，顺带把返回值也一起封装成Result。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
enum Result &amp;lt;T&amp;gt; {
    case Success(T)
    case Failure(ErrorType)
}

struct Async&amp;lt;T&amp;gt; {
    let trunk:(Result&amp;lt;T&amp;gt;-&amp;gt;Void)-&amp;gt;Void
    init(function:(Result&amp;lt;T&amp;gt;-&amp;gt;Void)-&amp;gt;Void) {
        trunk = function
    }
    func execute(callBack:Result&amp;lt;T&amp;gt;-&amp;gt;Void) {
        trunk(callBack)
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2.封装Monad，提供Map和flatMap操作。顺带返回值也返回Async，以方便后面可以继续链式调用。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Monad
extension Async{


    func map&amp;lt;U&amp;gt;(f: T throws-&amp;gt; U) -&amp;gt; Async&amp;lt;U&amp;gt; {
        return flatMap{ .unit(try f($0)) }
    }

    func flatMap&amp;lt;U&amp;gt;(f:T throws-&amp;gt; Async&amp;lt;U&amp;gt;) -&amp;gt; Async&amp;lt;U&amp;gt; {
        return Async&amp;lt;U&amp;gt;{ cont in
            self.execute{
                switch $0.map(f){
                case .Success(let async):
                    async.execute(cont)
                case .Failure(let error):
                    cont(.Failure(error))
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这是我们把异步的过程就封装成一个盒子了，盒子里面有Map，flatMap操作，flatMap对应的其实就是promise的then&lt;/p&gt;

&lt;p&gt;3.我们可以把flatMap名字直接换成then，那么之前那30多行的代码就会简化成下面这样：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
func requestAsyncOperation(request : String ) -&amp;gt; Async &amp;lt;String&amp;gt;
{
    return fetchDataAPI(request)
           .then(fetchOtherDataAPI)
           .map(transformResult)
           .then(fetchOtherDataAPI)
           .map(transformTaskResult)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;基本上和用promise一样的效果。这样就不用PromiseKit库，利用promise思想的精髓，优雅的完美的处理了回调地狱。这也得益于Swift语言的优点。&lt;/p&gt;

&lt;p&gt;文章至此，虽然已经解决了问题了，不过还没有结束，我们还可以继续再进一步讨论一些东西。&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;二.进一步的讨论&lt;/h4&gt;
&lt;p&gt;1.@noescape，throws，rethrows关键字
flatMap还有这种写法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func flatMap&amp;lt;U&amp;gt; (@noescape f: T throws -&amp;gt; Async&amp;lt;U&amp;gt;)rethrows -&amp;gt; Async&amp;lt;U&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;@noescape 从字面上看，就知道是“不会逃走”的意思，这个关键字专门用于修饰函数闭包这种参数类型的，当出现这个参数时，它表示该闭包不会跳出这个函数调用的生命期：即函数调用完之后，这个闭包的生命期也结束了。
在苹果官方文档上是这样写的：
&amp;gt;A new @noescape attribute may be used on closure parameters to functions. This indicates that the parameter is only ever called (or passed as an @noescape parameter in a call), which means that it cannot outlive the lifetime of the call. This enables some minor performance optimizations, but more importantly disables the self. requirement in closure arguments.&lt;/p&gt;

&lt;p&gt;那什么时候一个闭包参数会跳出函数的生命期呢？&lt;/p&gt;

&lt;p&gt;引用唐巧大神的解释：
&amp;gt;在函数实现内，将一个闭包用 dispatch_async
嵌套，这样这个闭包就会在另外一个线程中存在，从而跳出了当前函数的生命期。这样做主要是可以帮助编译器做性能的优化。&lt;/p&gt;

&lt;p&gt;throws关键字是代表该闭包可能会抛出异常。
rethrows关键字是代表这个闭包如果抛出异常，仅可能是因为传递给它的闭包的调用导致了异常。&lt;/p&gt;

&lt;p&gt;2.继续说说上面例子里面的Result，和Async一样，我们也可以继续封装Result，也加上map和flatMap方法。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
func ==&amp;lt;T:Equatable&amp;gt;(lhs:Result&amp;lt;T&amp;gt;, rhs:Result&amp;lt;T&amp;gt;) -&amp;gt; Bool{
    if case (.Success(let l), .Success(let r)) = (lhs, rhs){
        return l == r
    }
    return false
}

extension Result{

    func map&amp;lt;U&amp;gt;(f:T throws-&amp;gt; U) -&amp;gt; Result&amp;lt;U&amp;gt; {
        return flatMap{.unit(try f($0))}
    }

    func flatMap&amp;lt;U&amp;gt;(f:T throws-&amp;gt; Result&amp;lt;U&amp;gt;) -&amp;gt; Result&amp;lt;U&amp;gt; {
        switch self{
        case .Success(let value):
            do{
                return try f(value)
            }catch let e{
                return .Failure(e)
            }
        case .Failure(let e):
            return .Failure(e)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;3.上面我们已经把Async和Result封装了map方法，所以他们也可以叫做&lt;strong&gt;函子(Functor)&lt;/strong&gt;。接下来可以继续封装，把他们都封装成&lt;strong&gt;适用函子(Applicative Functor)&lt;/strong&gt;和&lt;strong&gt;单子(Monad)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;适用函子(Applicative Functor)&lt;/strong&gt;根据定义：
对于任意一个函子F，如果能支持以下运算，该函子就是一个适用函子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func pure&amp;lt;A&amp;gt;(value:A) -&amp;gt;F&amp;lt;A&amp;gt;

func &amp;lt;*&amp;gt;&amp;lt;A,B&amp;gt;(f:F&amp;lt;A - &amp;gt; B&amp;gt;, x:F&amp;lt;A&amp;gt;) -&amp;gt;F&amp;lt;B&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;以Async为例，我们为它加上这两个方法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
extension Async{

    static func unit(x:T) -&amp;gt; Async&amp;lt;T&amp;gt; {
        return Async{ $0(.Success(x)) }
    }

    func map&amp;lt;U&amp;gt;(f: T throws-&amp;gt; U) -&amp;gt; Async&amp;lt;U&amp;gt; {
        return flatMap{ .unit(try f($0)) }
    }

    func flatMap&amp;lt;U&amp;gt;(f:T throws-&amp;gt; Async&amp;lt;U&amp;gt;) -&amp;gt; Async&amp;lt;U&amp;gt; {
        return Async&amp;lt;U&amp;gt;{ cont in
            self.execute{
                switch $0.map(f){
                case .Success(let async):
                    async.execute(cont)
                case .Failure(let error):
                    cont(.Failure(error))
                }
            }
        }
    }

    func apply&amp;lt;U&amp;gt;(af:Async&amp;lt;T throws-&amp;gt; U&amp;gt;) -&amp;gt; Async&amp;lt;U&amp;gt; {
        return af.flatMap(map)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;unit和apply就是上面定义中的两个方法。接下来我们在看看Monad的定义。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;单子(Monad)&lt;/strong&gt;根据定义：
对于任意一个类型构造体F定义了下面两个函数，它就是一个单子Monad：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func pure&amp;lt;A&amp;gt;(value:A) -&amp;gt;F&amp;lt;A&amp;gt;

func flatMap&amp;lt;A,B&amp;gt;(x:F&amp;lt;A&amp;gt;)-&amp;gt;(A-&amp;gt;F&amp;lt;B&amp;gt;)-&amp;gt;F&amp;lt;B&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;还是以Async为例，此时的Async已经有了unit和flatMap满足定义了，这个时候，就可以说Async已经是一个Monad了。&lt;/p&gt;

&lt;p&gt;至此，我们就把Async和Result都变成了&lt;strong&gt;适用函子(Applicative Functor)&lt;/strong&gt;和&lt;strong&gt;单子(Monad)&lt;/strong&gt;了。&lt;/p&gt;

&lt;p&gt;4.再说说运算符。
flatMap函数有时候会被定义为一个运算符»=。由于它会将第一个参数的计算结果绑定到第二个参数的输入上面，这个运算符也会被称为“绑定(bind)”运算.&lt;/p&gt;

&lt;p&gt;为了方便，那我们就把上面的4个操作都定义成运算符吧。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func unit&amp;lt;T&amp;gt; (x:T) -&amp;gt; Async&amp;lt;T&amp;gt; {
    return Async{$0(.Success(x))}
}

func &amp;lt;^&amp;gt; &amp;lt;T, U&amp;gt; (f: T throws-&amp;gt; U, async: Async&amp;lt;T&amp;gt;) -&amp;gt; Async&amp;lt;U&amp;gt; {
    return async.map(f)
}

func &amp;gt;&amp;gt;= &amp;lt;T, U&amp;gt; (async:Async&amp;lt;T&amp;gt;, f:T throws-&amp;gt; Async&amp;lt;U&amp;gt;) -&amp;gt; Async&amp;lt;U&amp;gt; {
    return async.flatMap(f)
}

func &amp;lt;*&amp;gt; &amp;lt;T, U&amp;gt; (af: Async&amp;lt;T throws-&amp;gt; U&amp;gt;, async:Async&amp;lt;T&amp;gt;) -&amp;gt; Async&amp;lt;U&amp;gt; {
    return async.apply(af)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;按照顺序，第二个对应的就是原来的map函数，第三个对应的就是原来的flatMap函数。&lt;/p&gt;

&lt;p&gt;5.说到运算符，我们这里还可以继续回到文章最开始的地方去讨论一下那段回调地狱的代码。上面我们通过map和flatMap成功的展开了Callback hell，其实这里还有另外一个方法可以解决问题，那就是用自定义运算符。这里我们用不到适用函子的&amp;lt;*&amp;gt;，有些问题就可能用到它。还是回到上述问题，这里我们用Monad里面的运算符来解决回调地狱。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
func requestAsyncOperation(request : String ) -&amp;gt; Async &amp;lt;String&amp;gt;
{
    return fetchDataAPI(request) &amp;gt;&amp;gt;= (fetchOtherDataAPI) &amp;lt;^&amp;gt;(transformResult) &amp;gt;&amp;gt;= (fetchOtherDataAPI) &amp;lt;^&amp;gt; (transformTaskResult)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通过运算符，最终原来的40多行代码变成了最后一行了！当然，我们中间封装了一些操作。&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;三.总结&lt;/h4&gt;
&lt;p&gt;经过上篇和本篇的讨论，优雅的处理”回调地狱Callback hell”的方法有以下几种:&lt;br /&gt;
1.使用PromiseKit&lt;br /&gt;
2.使用Swift的map和flatMap封装异步操作(思想和promise差不多)&lt;br /&gt;
3.使用Swift自定义运算符展开回调嵌套&lt;/p&gt;

&lt;p&gt;目前为止，我能想到的处理方法还有2种：&lt;br /&gt;
4.使用Reactive cocoa&lt;br /&gt;
5.使用RxSwift&lt;/p&gt;

&lt;p&gt;下篇或者下下篇可能应该就是讨论RAC和RxSwift如果优雅的处理回调地狱了。如果大家还有什么其他方法能优雅的解决这个问题，也欢迎大家提出来，一起讨论，相互学习！&lt;/p&gt;
</description>
        <pubDate>Wed, 22 Jun 2016 22:45:00 +0800</pubDate>
        <link>http://vno.onevcat.com/2016/06/iOS%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%A4%84%E7%90%86-%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1Callback-hell-(%E4%BA%8C)-%E4%BD%BF%E7%94%A8Swift/</link>
        <guid isPermaLink="true">http://vno.onevcat.com/2016/06/iOS%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%A4%84%E7%90%86-%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1Callback-hell-(%E4%BA%8C)-%E4%BD%BF%E7%94%A8Swift/</guid>
        
        <category>iOS</category>
        
        
        <category>Blog</category>
        
      </item>
    
      <item>
        <title>如何快速给自己构建一个温馨的&quot;家&quot;——用Jekyll搭建静态博客</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-da55e05ede63372b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;前言&lt;/h4&gt;
&lt;p&gt;我相信，每个程序员都有一个愿望，都想有一个属于自己的”家”——属于自己的博客，专属的网站。在自己的“家”中，可以和志同道合的兄弟一起分享和讨论任何技术，谈天说地。更重要的是可以当做自己的技术积累，提升自己实力。那么接下来就来说说我博客搭建过程。&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;目录：&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;本地搭建Jekyll&lt;/li&gt;
  &lt;li&gt;开发或者选择Jekyll主题&lt;/li&gt;
  &lt;li&gt;使用Github Pages服务&lt;/li&gt;
  &lt;li&gt;申请个人域名&lt;/li&gt;
  &lt;li&gt;给博客增加访客评论功能&lt;/li&gt;
  &lt;li&gt;申请”小绿锁”HTTPS&lt;/li&gt;
  &lt;li&gt;日后维护&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;kekyll&quot;&gt;一.本地搭建Kekyll&lt;/h4&gt;
&lt;p&gt;Jekyll是什么？它是一个简单静态博客生成工具，相对于动态博客。&lt;br /&gt;
1. 简单。因为它是不需要数据库的，通过markdown编写静态文件，生成Html页面，它的优点是提升了页面的响应速度，并且让博主可以只专注于写文章，不用再去考虑如何排版。&lt;br /&gt;
2. 静态。Markdown（或 Textile）、Liquid 和 HTML &amp;amp; CSS 构建可发布的静态网站。&lt;br /&gt;
3. 博客支持。支持自定义地址、博客分类、页面、文章以及自定义的布局设计。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//使用gem安装Jekyll
gem install jekyll


//使用Jekyll创建你的博客站点
jekyll new blog  #创建你的站点


//开启Jekyll服务
//进入blog目录,记得一定要进入创建的目录，否则服务无法开启
cd blog    	 
jekyll serve 	 #启动你的http服务 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;本地服务开启后，Jekyll服务默认端口是4000，所以我打开浏览器，输入：http://localhost:4000 即可访问&lt;/p&gt;

&lt;p&gt;到这里一个简单的博客页面就会显示出来了。&lt;/p&gt;

&lt;p&gt;关于jekyll其他一些命令的用法如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ jekyll build
# =&amp;gt; 当前文件夹中的内容将会生成到 ./_site 文件夹中。

$ jekyll build --destination &amp;lt;destination&amp;gt;
# =&amp;gt; 当前文件夹中的内容将会生成到目标文件夹&amp;lt;destination&amp;gt;中。

$ jekyll build --source &amp;lt;source&amp;gt; --destination &amp;lt;destination&amp;gt;
# =&amp;gt; 指定源文件夹&amp;lt;source&amp;gt;中的内容将会生成到目标文件夹&amp;lt;destination&amp;gt;中。

$ jekyll build --watch
# =&amp;gt; 当前文件夹中的内容将会生成到 ./_site 文件夹中，
#    查看改变，并且自动再生成。

$ jekyll serve
# =&amp;gt; 一个开发服务器将会运行在 http://localhost:4000/
# Auto-regeneration（自动再生成文件）: 开启。使用 `--no-watch` 来关闭。

$ jekyll serve --detach
# =&amp;gt; 功能和`jekyll serve`命令相同，但是会脱离终端在后台运行。
#    如果你想关闭服务器，可以使用`kill -9 1234`命令，&quot;1234&quot; 是进程号（PID）。
#    如果你找不到进程号，那么就用`ps aux | grep jekyll`命令来查看，然后关闭服务器。[更多](http://unixhelp.ed.ac.uk/shell/jobz5.html).

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Jekyll 的核心其实是一个文本转换引擎。它的概念其实就是：你用你最喜欢的标记语言来写文章，可以是 Markdown, 也可以是 Textile, 或者就是简单的 HTML, 然后 Jekyll 就会帮你套入一个或一系列的布局中。在整个过程中你可以设置 URL 路径，你的文本在布局中的显示样式等等。这些都可以通过纯文本编辑来实现，最终生成的静态页面就是你的成品了。&lt;/p&gt;

&lt;p&gt;接下来再说说jeykll的目录结构：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;├── _config.yml  			(配置文件)
├── _drafts  				(drafts（草稿）是未发布的文章)
|   ├── begin-with-the-crazy-ideas.textile
|   └── on-simplicity-in-technology.markdown
├── _includes 			(加载这些包含部分到你的布局)
|   ├── footer.html
|   └── header.html
├── _layouts 			    (包裹在文章外部的模板)
|   ├── default.html
|   └── post.html
├── _posts 				  (这里都是存放文章)
|   ├── 2007-10-29-why-every-programmer-should-play-nethack.textile
|   └── 2009-04-26-barcamp-boston-4-roundup.textile
├── _site 				(生成的页面都会生成在这个目录下)
├── .jekyll-metadata	  (该文件帮助 Jekyll 跟踪哪些文件从上次建立站点开始到现在没有被修改，哪些文件需要在下一次站点建立时重新生成。该文件不会被包含在生成的站点中。)
└── index.html 		   (网站的index)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;jekyll&quot;&gt;二.开发或者选择Jekyll主题&lt;/h4&gt;
&lt;p&gt;再来说说博客的外观，这可能是很多人很看重的，一个高逼格的博客里面看文章也是一种享受。这里就需要自定义主题了。你可以选择自己开发一套，也可以直接选择已有的，然后自己再更改css布局形成自己的。&lt;a href=&quot;http://jekyllthemes.org/&quot;&gt;jekyll主题&lt;/a&gt;在这里，你可以选择到你自己喜欢的主题。下载下来，改改css，或者借用一下，就会有很漂亮的blog就出炉了。&lt;/p&gt;

&lt;h4 id=&quot;github-pages&quot;&gt;三.使用Github Pages服务&lt;/h4&gt;

&lt;h5 id=&quot;section-2&quot;&gt;1. 创建我们自己的仓库&lt;/h5&gt;
&lt;p&gt;以下用usename代替自己的用户名
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-1609f73ca0242750.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;section-3&quot;&gt;2. 配置我们的仓库&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-35e073b16f96a9aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在Settings里面找到Github Pages&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-a97613e15a848289.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;选择&lt;strong&gt;Launch automatic page generator&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;接下来的界面就直接选择&lt;strong&gt;Continue to layouts&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-a935d6e86644bf94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;到了这个界面就随便选择一个模板，点击&lt;strong&gt;Publish Page&lt;/strong&gt;即可&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-8984c24b9588e13b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;
这里就生成了一个静态网页了，直接访问刚刚的设置的&lt;a href=&quot;https://halfrost.com/username.github.io/&quot;&gt;地址https://halfrost.com/username.github.io/&lt;/a&gt;，这个地址，就可以访问到了。&lt;/p&gt;

&lt;p&gt;接下来我们要做的就是把我们的Jekyll生成的blog部署到Github Pages上去即可&lt;/p&gt;

&lt;h5 id=&quot;blog&quot;&gt;3.部署blog&lt;/h5&gt;

&lt;p&gt;我们先把刚刚新建的仓库git clone到本地，然后cd 到仓库的目录下，执行jekyll serve -B&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd username.github.com
jekyll serve -B
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;注意，启动前确保其他目录下没有jekyll服务，可以ps aux|grep jekyll
查看进程,有的话,用kill -9 进程号 杀掉其他进程。&lt;/p&gt;

&lt;p&gt;现在我们打开&lt;a href=&quot;localhost:4000&quot;&gt;http://localhost:4000&lt;/a&gt;,即可看见我们在Github上创建的主页，理论上和https://username.com/username.github.io/ 访问的应该是一模一样的。&lt;/p&gt;

&lt;p&gt;接着我们把我们自己做好的blog目录整个都拷贝到这个仓库文件夹中，当然，这个仓库之前的文件可以删除了，只留下README即可。把整个文件都push到github上去&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git add --all                          #添加到暂存区 
git commit -m &quot;提交jekyll默认页面&quot;       #提交到本地仓库
git push origin master                 #线上的站点是部署在master下面的
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;注意，在提交前，请确保_config.yml文件里面下面是这样配置的，因为这个是Github Pages的规定，如果选择了其他的模式，会立即收到编译警告的邮件提醒的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;highlighter: rouge
markdown: kramdown

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;等待大概1-2分钟之后，再次刷新username.github.io，就能看到我们的blog了。&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;四.申请个人域名&lt;/h4&gt;

&lt;p&gt;现在很多地方都支持个性化域名，比如新浪微博，就可以自己申请一个个性域名，那么以后只要访问weibo.com/你的名字，这个网址就可以直达你的主页。同理，我们也希望有一个名字直达我们的博客首页，那么我们就需要先买一个域名。一般国内用的比较多的应该就是&lt;strong&gt;万网&lt;/strong&gt;，国外的就是&lt;strong&gt;Go Daddy&lt;/strong&gt;。选择一个你喜欢的用户名，如果没有人先买下那个域名，那就可以恭喜你了，可以去买下来了。&lt;/p&gt;

&lt;p&gt;买好域名以后，就是配置的问题了。 &lt;br /&gt;
1. 我们要绑定的话需要在username.github.com目录下增加一个CNAME文件。 在里面添加你的域名，假设为example.com，然后推送CNAME文件到远程仓库:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git add CNAME
git push origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;2.到域名服务商增加你的CNAME记录。 添加两条记录，@和www的主机记录，记录类型为CNAME类型，CNAME表示别名记录，该记录可以将多个名字映射到同一台计算机。 记录值请写&lt;strong&gt;username.github.io.&lt;/strong&gt;,值得注意的是io
后面还有一个圆点，切记。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-888c87d7134d7ff8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;
注意，当添加@的记录的时候，很可能会提示冲突了，和MX那条冲突了，这里我就直接删除了MX的@规则。想知道原因，其实可以看这个链接，http://cn.v2ex.com/t/204489 。结论还是自己删除MX的@吧。&lt;/p&gt;

&lt;p&gt;如果是国内的域名，解析会很快，一般10分钟之内就能解析完成。我们就可以直接通过访问我们买的个性域名访问到我们的博客了。&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;五.给博客增加访客评论功能&lt;/h4&gt;
&lt;p&gt;一般静态博客添加访客评论功能都是用&lt;a href=&quot;https://disqus.com/&quot;&gt;disqus&lt;/a&gt;来集成的。一般都是放在博客的一篇文章的最后，当然这个排版就看你自己怎么设计的了。我这里就贴一下我集成disqus的代码。大家估计都类似。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;section class=&quot;post-comments&quot;&amp;gt;
  
    &amp;lt;div id=&quot;disqus_thread&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;script&amp;gt;
    
    var disqus_config = function () {
        this.page.url = &quot;http://vno.onevcat.com/2016/06/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E7%BB%99%E8%87%AA%E5%B7%B1%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%B8%A9%E9%A6%A8%E7%9A%84_%E5%AE%B6_-%E7%94%A8Jekyll%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/&quot;;
        this.page.identifier = &quot;/2016/06/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E7%BB%99%E8%87%AA%E5%B7%B1%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%B8%A9%E9%A6%A8%E7%9A%84_%E5%AE%B6_-%E7%94%A8Jekyll%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/&quot;;
    };

    var disqus_shortname = &#39;halfrostsfield&#39;;
    
    (function() { // DON&#39;T EDIT BELOW THIS LINE
        var d = document, s = d.createElement(&#39;script&#39;);
        s.src = &#39;//&#39; + disqus_shortname + &#39;.disqus.com/embed.js&#39;;
        s.setAttribute(&#39;data-timestamp&#39;, +new Date());
            (d.head || d.body).appendChild(s);
        })();
    &amp;lt;/script&amp;gt;
    &amp;lt;noscript&amp;gt;要查看&amp;lt;a href=&quot;http://disqus.com/?ref_noscript&quot;&amp;gt; Disqus &amp;lt;/a&amp;gt;评论，请启用 JavaScript&amp;lt;/noscript&amp;gt;
    
  
  
  
  
&amp;lt;/section&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;https&quot;&gt;六.申请”小绿锁”HTTPS&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-fcbd290c62a45816.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;
要想使用HTTPS开头，目前就2种做法，一是申请HTTPS证书，免费的就用Let’s Encrypt 提供的免费 SSL 证书，二是使用kloudsec提供的服务。申请SSL证书的做法我就不说了，我来说说第二种使用kloudsec提供的服务的做法。&lt;/p&gt;

&lt;p&gt;实现原理
看 Kloudsec 的文档里描述的 &lt;a href=&quot;https://docs.kloudsec.com/#section-how-does-it-work-&quot;&gt;HOW DOES IT WORK?&lt;/a&gt;，它提供的服务处于我们的网站服务器和我们的网站访问者之间，其原理是缓存了我们服务器上的页面，所以实际用户建立的 HTTPS 连接是用户的浏览器与 Kloudsec 之间的。&lt;/p&gt;

&lt;p&gt;首先注册Kloudsec的账户，填写邮箱和密码，接下来会让你填写仓库的地址和域名，它会检测仓库是否存在。然后最后是激活 Kloudsec 账号并登录。&lt;/p&gt;

&lt;p&gt;然后最关键的一步来了，就是要设置域名解析规则。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-63d0ee7385034236.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;按照上面给的，要设置3个A的解析规则。设置完成之后点击&lt;strong&gt;Verify DNS records&lt;/strong&gt;，如果通过，那么就可以接下来的设置了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-e6615fa4f840932f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里会有一些免费和付费的服务，大家看自己需要选取。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-962aa0ffcb15e729.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里的SSL Encryption要选上，打开会有如下的设置。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-ee6c9cc414be8e87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里如果不上传自己的SSL，就会用它帮你生成免费的SSL证书。如果要用自己的，点击ADD CUSTOM CERT按钮上传SSL证书。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-436818e0d0989824.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;
这里是一些插件。看自己需不需要。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-1ac0bce6a395d638.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后，SETTING里面加上这个IP地址。这个IP是GitHub Pages 的可用 IP地址。&lt;/p&gt;

&lt;p&gt;使用 Kloudsec 的好处&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;摆脱了证书不可信存在安全风险的不友好提示。&lt;/li&gt;
  &lt;li&gt;配置方便，一劳永逸。&lt;/li&gt;
  &lt;li&gt;访问速度并未受影响&lt;/li&gt;
  &lt;li&gt;小绿锁看着舒心&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;后来又发现了第三种方法能用HTTPS访问博客的方法：
使用 GitLab 提供的 Pages 服务，那它直接支持添加自定义域名的 SSL 证书，可以配合免费申请的 SSL 证书一起使用。详情可见 &lt;a href=&quot;https://www.figotan.org/2016/04/26/using-free-wosign-to-certificate-your-blog-on-gitlab/&quot;&gt;零成本打造安全博客的简单办法&lt;/a&gt;。&lt;/p&gt;

&lt;h4 id=&quot;section-6&quot;&gt;七.日后维护&lt;/h4&gt;
&lt;p&gt;至此，个人博客也绑定好域名成功上线了。以后的维护工作其实并没有多少。&lt;/p&gt;

&lt;h5 id=&quot;section-7&quot;&gt;1. 本地编辑文章：&lt;/h5&gt;
&lt;p&gt;用markdown工具，先写好博文，注意，每篇博文前面题头都要带下面这些格式。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;---
layout: post
title: 如何快速给自己搭建一个温馨的&quot;家&quot;——用Jekyll生成静态博客
author: 一缕殇流化隐半边冰霜
date: 2016.06.21 01:57:32 +0800
categories: Blog
tag: Blog
---
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;文章写完之后，通过jekyll build生成页面，jekyll serve -B 通过本地localhost:4000查看文章。&lt;/p&gt;

&lt;h5 id=&quot;section-8&quot;&gt;2. 发布线上博客&lt;/h5&gt;
&lt;p&gt;本地确认文章无误，可以通过git add,git commit,git push
等git命令推送文章到Github Pages服务器就可以啦。过1，2分钟，访问自己的域名就可以看到新的博文啦！&lt;/p&gt;

&lt;h4 id=&quot;section-9&quot;&gt;结尾&lt;/h4&gt;
&lt;p&gt;关于静态博客的搭建就到这里了，如果大家还有什么不清楚了，请直接给我留言就好。静态博客还有一个hexo，也是很优秀的静态博客，如果大家有兴趣，想折腾的，也可以去试试它。唐巧就是用这个搭建博客的。当然也有动态博客，ghost搭建的，搭建动态博客就需要自己买一个服务器，然后去安装node.js环境，日后的维护也都需要自己一个人去完成。有兴趣的同学一样可以去试试！&lt;/p&gt;

</description>
        <pubDate>Tue, 21 Jun 2016 02:57:00 +0800</pubDate>
        <link>http://vno.onevcat.com/2016/06/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E7%BB%99%E8%87%AA%E5%B7%B1%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%B8%A9%E9%A6%A8%E7%9A%84_%E5%AE%B6_-%E7%94%A8Jekyll%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/</link>
        <guid isPermaLink="true">http://vno.onevcat.com/2016/06/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E7%BB%99%E8%87%AA%E5%B7%B1%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%B8%A9%E9%A6%A8%E7%9A%84_%E5%AE%B6_-%E7%94%A8Jekyll%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/</guid>
        
        <category>Blog</category>
        
        
        <category>Blog</category>
        
      </item>
    
      <item>
        <title>iOS如何优雅的处理“回调地狱Callback hell”(一)——使用PromiseKit</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-2f5b4fb0534c69cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;前言&lt;/h4&gt;
&lt;p&gt;最近看了一些Swift关于封装异步操作过程的文章，比如RxSwift，RAC等等，因为回调地狱我自己也写过，很有感触，于是就翻出了Promise来研究学习一下。现将自己的一些收获分享一下，有错误欢迎大家多多指教。&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;目录&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;1.PromiseKit简介&lt;/li&gt;
  &lt;li&gt;2.PromiseKit安装和使用&lt;/li&gt;
  &lt;li&gt;3.PromiseKit主要函数的使用方法&lt;/li&gt;
  &lt;li&gt;4.PromiseKit的源码解析&lt;/li&gt;
  &lt;li&gt;5.使用PromiseKit优雅的处理回调地狱&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;promisekit&quot;&gt;一.PromiseKit简介&lt;/h4&gt;
&lt;p&gt;PromiseKit是iOS/OS X 中一个用来出来异步编程框架。这个框架是由Max Howell(Mac下Homebrew的作者，传说中因为”不会”写反转二叉树而没有拿到Google offer)大神级人物开发出来的。&lt;/p&gt;

&lt;p&gt;在PromiseKit中，最重要的一个概念就是Promise的概念，Promise是异步操作后的future的一个值。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A &lt;a href=&quot;http://wikipedia.org/wiki/Promise_%28programming%29&quot;&gt;promise&lt;/a&gt; represents the future value of an asynchronous task.
A promise is an object that wraps an asynchronous task&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Promise也是一个包装着异步操作的一个对象。使用PromiseKit，能够编写出整洁，有序的代码，逻辑简单的，将Promise作为参数，模块化的从一个异步任务到下一个异步任务中去。用PromiseKit写出的代码就是这样：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
[self login].then(^{
                  
     // our login method wrapped an async task in a promise
     return [API fetchData];
                  
}).then(^(NSArray *fetchedData){
                          
     // our API class wraps our API and returns promises
     // fetchedData returned a promise that resolves with an array of data
     self.datasource = fetchedData;
     [self.tableView reloadData];
                          
}).catch(^(NSError *error){
                                   
     // any errors in any of the above promises land here
     [[[UIAlertView alloc] init…] show];
                                   
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;PromiseKit就是用来干净简洁的代码，来解决异步操作，和奇怪的错误处理回调的。它将异步操作变成了链式的调用，简单的错误处理方式。&lt;/p&gt;

&lt;p&gt;PromiseKit里面目前有2个类，一个是Promise&lt;T&gt;(Swift)，一个是AnyPromise(Objective-C)，2者的区别就在2种语言的特性上，Promise&lt;T&gt;是定义精确严格的，AnyPromise是定义宽松，灵活，动态的。&lt;/T&gt;&lt;/T&gt;&lt;/p&gt;

&lt;p&gt;在异步编程中，有一个最最典型的例子就是回调地狱CallBack hell，要是处理的不优雅，就会出现下图这样:
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-76966b54ee252dce.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;
上图的代码是真实存在的，也是朋友告诉我的，来自&lt;a href=&quot;http://www.kuaidadi.com/assets/js/animate.js&quot;&gt;快的的代码&lt;/a&gt;，当然现在人家肯定改掉了。虽然这种代码看着像这样：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-77a2f359c5a95e9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;
代码虽然看上去不优雅，功能都是正确的，但是这种代码基本大家都自己写过，我自己也写过很多。今天就让我们动起手来，用PromiseKit来优雅的处理掉Callback hell吧。&lt;/p&gt;

&lt;h4 id=&quot;promisekit-1&quot;&gt;二.PromiseKit安装和使用&lt;/h4&gt;
&lt;p&gt;1.下载安装CocoaPods&lt;/p&gt;

&lt;p&gt;在墙外的安装步骤:
在Terminal里面输入&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo gem install cocoapods &amp;amp;&amp;amp; pod setup
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;大多数在墙内的同学应该看如下步骤了:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//移除原有的墙外Ruby 默认源
$ gem sources --remove https://rubygems.org/
//添加现有的墙内的淘宝源
$ gem sources -a https://ruby.taobao.org/
//验证新源是否替换成功
$ gem sources -l
//下载安装cocoapods
// OS 10.11之前
$ sudo gem install cocoapods
//mark：OS 升级 OS X EL Capitan 后命令应该为:
$ sudo gem install -n /usr/local/bin cocoapods
//设置cocoapods
$ pod setup
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2.找到项目的路径，进入项目文件夹下面，执行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ touch Podfile &amp;amp;&amp;amp; open -e Podfile
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;此时会打开TextEdit，然后输入一下命令:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;platform:ios, ‘7.0’

target &#39;PromisekitDemo&#39; do  //由于最新版cocoapods的要求，所以必须加入这句话
    pod &#39;PromiseKit&#39;
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;Tips：感谢qinfensky大神提醒，其实这里也可以用init命令
Podfile是CocoaPods的特殊文件，在其中可以列入在项目中想要使用的开源库，若想创建Podfile，有2种方法：
1.在项目目录中创建空文本文件，命名为Podfile
2.或者可以再项目目录中运行“$ pod init “，来创建功能性文件（终端中输入cd 文件夹地址，然后再输入 pod init）
两种方法都可以创建Podfile，使用你最喜欢使用的方法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;3.安装PromiseKit&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ pod install
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;安装完成之后，退出终端，打开新生成的.xcworkspace文件即可&lt;/p&gt;

&lt;h4 id=&quot;promisekit-2&quot;&gt;三.PromiseKit主要函数的使用方法&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;then
经常我们会写出这样的代码:&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)showUndoRedoAlert:(UndoRedoState *)state
{
     UIAlertView *alert = [[UIAlertView alloc] initWithTitle:……];
     alert.delegate = self; 
     self.state = state;
     [alert show];
}

- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex
{
    if (buttonIndex == 1) {
        [self.state do];
    }

}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;上面的写法也不是错误的，就是它在调用函数中保存了一个属性，在调用alertView会使用到这个属性。其实这个中间属性是不需要存储的。接下来我们就用then来去掉这个中间变量。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
- (void)showUndoRedoAlert:(UndoRedoState *)state
 {
    UIAlertView *alert = [[UIAlertView alloc] initWithTitle:……];
    [alert promise].then(^(NSNumber *dismissedButtonIndex){
        [state do];
    });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这时就有人问了，为啥能调用[alert promise]这个方法？后面点语法跟着then是什么？我来解释一下，原因其实只要打开Promise源码就一清二楚了。在pormise源码中&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
@interface UIAlertView (PromiseKit)

/**
 Displays the alert view.

 @return A promise the fulfills with two parameters:
 1) The index of the button that was tapped to dismiss the alert.
 2) This alert view.
*/
- (PMKPromise *)promise;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;对应的实现是这样的&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (PMKPromise *)promise {
    PMKAlertViewDelegater *d = [PMKAlertViewDelegater new];
    PMKRetain(d);
    self.delegate = d;
    [self show];
    return [PMKPromise new:^(id fulfiller, id rejecter){
        d-&amp;gt;fulfiller = fulfiller;
    }];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;调用[alert promise]返回还是一个promise对象，在promise的方法中有then的方法，所以上面可以那样链式的调用。上面代码里面的fulfiller放在源码分析里面去讲讲。&lt;/p&gt;

&lt;p&gt;在PromiseKit里面，其实就默认给你创建了几个类的延展，如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-ab9c742c3b4ce5a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;
这些扩展类里面就封装了一些常用的生成promise方法，调用这些方法就可以愉快的一路.then执行下去了！&lt;/p&gt;

&lt;p&gt;2.dispatch_promise
项目中我们经常会异步的下载图片&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedefvoid(^onImageReady) (UIImage* image);

+ (void)getImageWithURL:(NSURL *)url onCallback:(onImageReady)callback
{
    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0ul);
    dispatch_async(queue, ^{
        NSData * imageData = [NSData dataWithContentsOfURL:url];
        dispatch_async(dispatch_get_main_queue(), ^{
            UIImage *image = [UIImage imageWithData:imageData];
            callback(image);
        });
    });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;使用dispatch_promise，我们可以将它改变成下面这样:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    dispatch_promise(^{
        return [NSData dataWithContentsOfURL:url];     
    }).then(^(NSData * imageData){ 
        self.imageView.image = [UIImage imageWithData:imageData];  
    }).then(^{
        // add code to happen next here
    });
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;我们看看源码，看看调用的异步过程对不对&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (PMKPromise *(^)(id))then {
    return ^(id block){
        return self.thenOn(dispatch_get_main_queue(), block);
    };
}

PMKPromise *dispatch_promise(id block) {
    return dispatch_promise_on(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), block);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;看了源码就知道上述是正确的。&lt;/p&gt;

&lt;p&gt;3.catch
在异步操作中，处理错误也是一件很头疼的事情，如下面这段代码，每次异步请求回来都必须要处理错误。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
void (^errorHandler)(NSError *) = ^(NSError *error) {
    [[UIAlertView …] show];
};
[NSURLConnection sendAsynchronousRequest:rq queue:q completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError) {
    if (connectionError) {
        errorHandler(connectionError);
    } else {
        NSError *jsonError = nil;
        NSDictionary *json = [NSJSONSerialization JSONObjectWithData:data options:0 error:&amp;amp;jsonError];
        if (jsonError) {
            errorHandler(jsonError);
        } else {
            id rq = [NSURLRequest requestWithURL:[NSURL URLWithString:json[@&quot;avatar_url&quot;]]];
            [NSURLConnection sendAsynchronousRequest:rq queue:q completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError) {
                UIImage *image = [UIImage imageWithData:data];
                if (!image) {
                    errorHandler(nil); // NSError TODO!
                } else {
                    self.imageView.image = image;
                }
            }];
        }
    }
}];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;我们可以用promise的catch来解决上面的错误处理的问题&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//oc版
[NSURLSession GET:url].then(^(NSDictionary *json){
    return [NSURLConnection GET:json[@&quot;avatar_url&quot;]];
}).then(^(UIImage *image){
    self.imageView.image = image;
}).catch(^(NSError *error){
    [[UIAlertView …] show];
})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//swift版
firstly {
    NSURLSession.GET(url)
}.then { (json: NSDictionary) in
    NSURLConnection.GET(json[&quot;avatar_url&quot;])
}.then { (image: UIImage) in
    self.imageView.image = image
}.error { error in
    UIAlertView(…).show()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;用了catch以后，在传递promise的链中，一旦中间任何一环产生了错误，都会传递到catch去执行Error Handler。&lt;/p&gt;

&lt;p&gt;4.when
通常我们有这种需求:
在执行一个A任务之前还有1，2个异步的任务，在全部异步操作完成之前，需要阻塞A任务。代码可能会写的像下面这样子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
__block int x = 0;
void (^completionHandler)(id, id) = ^(MKLocalSearchResponse *response, NSError *error){
    if (++x == 2) {
        [self finish];
    }
};
[[[MKLocalSearch alloc] initWithRequest:rq1] startWithCompletionHandler:completionHandler];
[[[MKLocalSearch alloc] initWithRequest:rq2] startWithCompletionHandler:completionHandler];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里就可以使用when来优雅的处理这种情况:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
id search1 = [[[MKLocalSearch alloc] initWithRequest:rq1] promise];
id search2 = [[[MKLocalSearch alloc] initWithRequest:rq2] promise];

PMKWhen(@[search1, search2]).then(^(NSArray *results){
    //…
}).catch(^{
    // called if either search fails
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;在when后面传入一个数组，里面是2个promise，只有当这2个promise都执行完，才会去执行后面的then的操作。这样就达到了之前所说的需求。&lt;/p&gt;

&lt;p&gt;这里when还有2点要说的，when的参数还可以是字典。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
id coffeeSearch = [[MKLocalSearch alloc] initWithRequest:rq1];
id beerSearch = [[MKLocalSearch alloc] initWithRequest:rq2];
id input = @{@&quot;coffee&quot;: coffeeSearch, @&quot;beer&quot;: beerSearch};

PMKWhen(input).then(^(NSDictionary *results){
    id coffeeResults = results[@&quot;coffee&quot;];
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这个例子里面when传入了一个input字典，处理完成之后依旧可以生成新的promise传递到下一个then中，在then中可以去到results的字典，获得结果。传入字典的工作原理放在第四章会解释。&lt;/p&gt;

&lt;p&gt;when传入的参数还可以是一个可变的属性：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dataSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dataSource&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dataSource&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;?:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PMKPromise&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;…&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;viewDidAppear&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PMKPromise&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;when&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dataSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// cache the result
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dataSource&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;dataSource如果为空就新建一个promise，传入到when中，执行完之后，在then中拿到result，并把result赋值给dataSource，这样dataSource就有数据了。由此看来，when的使用非常灵活！&lt;/p&gt;

&lt;p&gt;5.always &amp;amp; finally&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//oc版
[UIApplication sharedApplication].networkActivityIndicatorVisible = YES;
[self myPromise].then(^{
    //…
}).finally(^{
    [UIApplication sharedApplication].networkActivityIndicatorVisible = NO;
})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//swift版
UIApplication.sharedApplication().networkActivityIndicatorVisible = true
myPromise().then {
    //…
}.always {
    UIApplication.sharedApplication().networkActivityIndicatorVisible = false
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;在我们执行完then，处理完error之后，还有一些操作，那么就可以放到finally和always里面去执行。&lt;/p&gt;

&lt;h4 id=&quot;promisekit-3&quot;&gt;四.PromiseKit的源码解析&lt;/h4&gt;
&lt;p&gt;经过上面对promise的方法的学习，我们已经可以了解到，在异步操作我们可以通过不断的返回promise，传递给后面的then来形成链式调用，所以重点就在then的实现了。在讨论then之前，我先说一下promise的状态和传递机制。&lt;/p&gt;

&lt;p&gt;一个promise可能有三种状态：等待（pending）、已完成（fulfilled）、已拒绝（rejected）。
一个promise的状态只可能从“等待”转到“完成”态或者“拒绝”态，不能逆向转换，同时“完成”态和“拒绝”态不能相互转换。
promise必须实现then方法（可以说，then就是promise的核心），而且then必须返回一个promise，同一个promise的then可以调用多次，并且回调的执行顺序跟它们被定义时的顺序一致
then方法接受两个参数，第一个参数是成功时的回调，在promise由“等待”态转换到“完成”态时调用，另一个是失败时的回调，在promise由“等待”态转换到“拒绝”态时调用。同时，then可以接受另一个promise传入，也接受一个“类then”的对象或方法，即thenable对象&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1194012-2f135482415329ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;
总结起来就是上图，pending状态的promise对象既可转换为带着一个成功值的 fulfilled 状态，也可变为带着一个 error 信息的 rejected 状态。当状态发生转换时， promise.then 绑定的方法就会被调用。(当绑定方法时，如果 promise 对象已经处于 fulfilled 或 rejected 状态，那么相应的方法将会被立刻调用， 所以在异步操作的完成情况和它的绑定方法之间不存在竞争关系。)从Pending转换为fulfilled或Rejected之后， 这个promise对象的状态就不会再发生任何变化。因此 then是只被调用一次的函数，从而也能说明，then生成的是一个新的promise，而不是原来的那个。&lt;/p&gt;

&lt;p&gt;了解完流程之后，就可以开始继续研究源码了。在PromiseKit当中，最常用的当属then，thenInBackground，catch，finally&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
- (PMKPromise *(^)(id))then {
    return ^(id block){
        return self.thenOn(dispatch_get_main_queue(), block);
    };
}

- (PMKPromise *(^)(id))thenInBackground {
    return ^(id block){
        return self.thenOn(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), block);
    };
}

- (PMKPromise *(^)(id))catch {
    return ^(id block){
        return self.catchOn(dispatch_get_main_queue(), block);
    };
}

- (PMKPromise *(^)(dispatch_block_t))finally {
    return ^(dispatch_block_t block) {
        return self.finallyOn(dispatch_get_main_queue(), block);
    };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这四个方法底层调用了各自的thenon，catchon，finallyon方法，这些on的方法实现基本都差不多，那我就以最重要的thenon来分析一下。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
- (PMKResolveOnQueueBlock)thenOn {
    return [self resolved:^(id result) {
        if (IsPromise(result))
            return ((PMKPromise *)result).thenOn;

        if (IsError(result)) return ^(dispatch_queue_t q, id block) {
            return [PMKPromise promiseWithValue:result];
        };

        return ^(dispatch_queue_t q, id block) {
            block = [block copy];
            return dispatch_promise_on(q, ^{
                return pmk_safely_call_block(block, result);
            });
        };
    }
    pending:^(id result, PMKPromise *next, dispatch_queue_t q, id block, void (^resolve)(id)) {
        if (IsError(result))
            PMKResolve(next, result);
        else dispatch_async(q, ^{
            resolve(pmk_safely_call_block(block, result));
        });
    }];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这个thenon就是返回一个方法，所以继续往下看&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (id)resolved:(PMKResolveOnQueueBlock(^)(id result))mkresolvedCallback
       pending:(void(^)(id result, PMKPromise *next, dispatch_queue_t q, id block, void (^resolver)(id)))mkpendingCallback
{
    __block PMKResolveOnQueueBlock callBlock;
    __block id result;
    
    dispatch_sync(_promiseQueue, ^{
        if ((result = _result))
            return;

        callBlock = ^(dispatch_queue_t q, id block) {

            block = [block copy];

            __block PMKPromise *next = nil;

            dispatch_barrier_sync(_promiseQueue, ^{
                if ((result = _result))
                    return;

                __block PMKPromiseFulfiller resolver;
                next = [PMKPromise new:^(PMKPromiseFulfiller fulfill, PMKPromiseRejecter reject) {
                    resolver = ^(id o){
                        if (IsError(o)) reject(o); else fulfill(o);
                    };
                }];
                [_handlers addObject:^(id value){
                    mkpendingCallback(value, next, q, block, resolver);
                }];
            });

            return next ?: mkresolvedCallback(result)(q, block);
        };
    });

    // We could just always return the above block, but then every caller would
    // trigger a barrier_sync on the promise queue. Instead, if we know that the
    // promise is resolved (since that makes it immutable), we can return a simpler
    // block that doesn&#39;t use a barrier in those cases.

    return callBlock ?: mkresolvedCallback(result);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这个方法看上去很复杂，仔细看看，函数的形参其实就是2个block，一个是resolved的block，还有一个是pending的block。当一个promise经历过resolved之后，可能是fulfill，也可能是reject，之后生成next新的promise，传入到下一个then中，并且状态会变成pending。上面代码中第一个return，如果next为nil，那么意味着promise没有生成，这是会再调用一次mkresolvedCallback，并传入参数result，生成的PMKResolveOnQueueBlock，再次传入(q, block)，直到next的promise生成，并把pendingCallback存入到handler当中。这个handler存了所有待执行的block，如果把这个数组里面的block都执行，那么就相当于依次完成了上面的所有异步操作。第二个return是在callblock为nil的时候，还会再调一次mkresolvedCallback(result)，保证一定要生成next的promise。&lt;/p&gt;

&lt;p&gt;这个函数里面的这里dispatch_barrier_sync这个方法，就是promise后面可以链式调用then的原因，因为GCD的这个方法，让后面then变得像一行行的then顺序执行了。&lt;/p&gt;

&lt;p&gt;可能会有人问了，并没有看到各个block执行，仅仅只是加到handler数组里了，这个问题的答案，就是promise的核心了。promise执行block的操作是放在resove里面的。先来看看源码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
static void PMKResolve(PMKPromise *this, id result) {
    void (^set)(id) = ^(id r){
        NSArray *handlers = PMKSetResult(this, r);
        for (void (^handler)(id) in handlers)
            handler(r);
    };

    if (IsPromise(result)) {
        PMKPromise *next = result;
        dispatch_barrier_sync(next-&amp;gt;_promiseQueue, ^{
            id nextResult = next-&amp;gt;_result;
            
            if (nextResult == nil) {  // ie. pending
                [next-&amp;gt;_handlers addObject:^(id o){
                    PMKResolve(this, o);
                }];
            } else
                set(nextResult);
        });
    } else
        set(result);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这是一个递归函数，能形成递归的条件就是那句PMKResolve(this, o);当nextResult = nil的时候，就代表了这个promise还是pending状态，还没有被执行，这个时候就要递归调用，直到nextResult不为nil。不为nil，就会调用set方法，set方法是一个匿名函数，里面的for循环会依次循环，执行handler数组里面的每一个block。里面的那个if语句，是先判断result是否是一个promise，如果不是promise，就去执行set方法，依次调用各个block。&lt;/p&gt;

&lt;p&gt;至此，一个then的执行原理就到此结束了。接下来我们再看看when的原理。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    return newPromise = [PMKPromise new:^(PMKPromiseFulfiller fulfiller, PMKPromiseRejecter rejecter){
        NSPointerArray *results = nil;
      #if TARGET_OS_IPHONE
        results = [NSPointerArray strongObjectsPointerArray];
      #else
        if ([[NSPointerArray class] respondsToSelector:@selector(strongObjectsPointerArray)]) {
            results = [NSPointerArray strongObjectsPointerArray];
        } else {
          #pragma clang diagnostic push
          #pragma clang diagnostic ignored &quot;-Wdeprecated-declarations&quot;
            results = [NSPointerArray pointerArrayWithStrongObjects];
          #pragma clang diagnostic pop
        }
      #endif
        results.count = count;

        NSUInteger ii = 0;

        for (__strong PMKPromise *promise in promises) {
            if (![promise isKindOfClass:[PMKPromise class]])
                promise = [PMKPromise promiseWithValue:promise];
            promise.catch(rejecter(@(ii)));
            promise.then(^(id o){
                [results replacePointerAtIndex:ii withPointer:(__bridge void *)(o ?: [NSNull null])];
                if (--count == 0)
                    fulfiller(results.allObjects);
            });
            ii++;
        }
    }];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里只截取了return的部分，理解了then，这里再看when就好理解了。when就是在传入的promises的数组里面，依次执行各个promise，结果最后传给新生成的一个promise，作为返回值返回。&lt;/p&gt;

&lt;p&gt;这里要额外提一点的就是如果给when传入一个字典，它会如何处理的&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
    if ([promises isKindOfClass:[NSDictionary class]])
        return newPromise = [PMKPromise new:^(PMKPromiseFulfiller fulfiller, PMKPromiseRejecter rejecter){
            NSMutableDictionary *results = [NSMutableDictionary new];
            for (id key in promises) {
                PMKPromise *promise = promises[key];
                if (![promise isKindOfClass:[PMKPromise class]])
                    promise = [PMKPromise promiseWithValue:promise];
                promise.catch(rejecter(key));
                promise.then(^(id o){
                    if (o)
                        results[key] = o;
                    if (--count == 0)
                        fulfiller(results);
                });
            }
        }];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;方式和when的数组方式基本一样，只不过多了一步，就是从字典里面先取出promise[key]，然后再继续对这个promise执行操作而已。所以when可以传入以promise为value的字典。&lt;/p&gt;

&lt;h4 id=&quot;promisekit-4&quot;&gt;五.使用PromiseKit优雅的处理回调地狱&lt;/h4&gt;
&lt;p&gt;这里我就举个例子，大家一起来感受感受用promise的简洁。
先描述一下环境，假设有这样一个提交按钮，当你点击之后，就会提交一次任务。首先要先判断是否有权限提交，没有权限就弹出错误。有权限提交之后，还要请求一次，判断当前任务是否已经存在，如果存在，弹出错误。如果不存在，这个时候就可以安心提交任务了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
void (^errorHandler)(NSError *) = ^(NSError *error) {
    [[UIAlertView …] show];
};
[NSURLConnection sendAsynchronousRequest:rq queue:q completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError) {
    if (connectionError) {
        errorHandler(connectionError);
    } else {
        NSError *jsonError = nil;
        NSDictionary *json = [NSJSONSerialization JSONObjectWithData:data options:0 error:&amp;amp;jsonError];
        if (jsonError) {
            errorHandler(jsonError);
        } else {
            id rq = [NSURLRequest requestWithURL:[NSURL URLWithString:json[@&quot;have_authority&quot;]]];
            [NSURLConnection sendAsynchronousRequest:rq queue:q completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError) {
                
                NSError *jsonError = nil;
                NSDictionary *json = [NSJSONSerialization JSONObjectWithData:data options:0 error:&amp;amp;jsonError];
                
                if (jsonError) {
                    errorHandler(jsonError);
                } else {
                    id rq = [NSURLRequest requestWithURL:[NSURL URLWithString:json[@&quot;exist&quot;]]];
                    [NSURLConnection sendAsynchronousRequest:rq queue:q completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError) {
                        
                        NSError *jsonError = nil;
                        NSDictionary *json = [NSJSONSerialization JSONObjectWithData:data options:0 error:&amp;amp;jsonError];
                        
                        if (jsonError) {
                            errorHandler(jsonError);
                        } else {
                            if ([json[@&quot;status&quot;] isEqualToString:@&quot;OK&quot;]) {
                                [self submitTask];
                            } else {
                                errorHandler(json[@&quot;status&quot;]);
                            }
                        }
                    }];
                }
            }];
        }
    }
}];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;上面的代码里面有3层回调，看上去就很晕，接下来我们用promise来整理一下。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
[NSURLSession GET:url].then(^(NSDictionary *json){
    return [NSURLConnection GET:json[@&quot;have_authority&quot;]];
}).then(^(NSDictionary *json){
    return [NSURLConnection GET:json[@&quot;exist&quot;]];
}).then(^(NSDictionary *json){
    if ([json[@&quot;status&quot;] isEqualToString:@&quot;OK&quot;]) {
        return [NSURLConnection GET:submitJson];
    } else
        @throw [NSError errorWithDomain:… code:… userInfo:json[@&quot;status&quot;]];
}).catch(^(NSError *error){
    [[UIAlertView …] show];
})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;之前将近40行代码就一下子变成15行左右，看上去比原来清爽多了，可读性更高。&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;最后&lt;/h4&gt;
&lt;p&gt;看完上面关于PromiseKit的使用方法之后，其实对于PromiseKit，我个人的理解它就是一个Monad（这是最近很火的一个概念，4月底在上海SwiftCon 2016中，唐巧大神分享的主题就是关于Monad，还不是很了解这个概念的可以去他博客看看，或者找视频学习学习。）Promise就是一个盒子里面封装了一堆操作，then对应的就是一组flatmap或map操作。不过缺点也还是有，如果网络用的AFNetWorking，网络请求很有可能会回调多次，这时用PromiseKit，就需要自己封装一个属于自己的promise了。PromiseKit原生的是用的OMGHTTPURLRQ这个网络框架。PromiseKit里面自带的封装的网络请求也还是基于NSURLConnection的。所以用了AFNetWorking的同学，要想再优雅的处理掉网络请求引起的回调地狱的时候，自己还是需要先封装一个自己的Promise，然后优雅的then一下。很多人可能看到这里，觉得我引入一个框架，本来是来解决问题的，但是现在还需要我再次封装才能解决问题，有点不值得。&lt;/p&gt;

&lt;p&gt;我自己的看法是，PromiseKit是个解决异步问题很优秀的一个开源库，尤其是解决回调嵌套，回调地狱的问题，效果非常明显。虽然需要自己封装AFNetWorking的promise，但是它的思想非常值得我们学习的！这也是接下来第二篇想和大家一起分享的内容，利用promise的思想，自己来优雅的处理回调地狱！这一篇PromiseKit先分享到这里。&lt;/p&gt;

&lt;p&gt;如有错误，还请大家请多多指教。&lt;/p&gt;

</description>
        <pubDate>Fri, 10 Jun 2016 19:51:00 +0800</pubDate>
        <link>http://vno.onevcat.com/2016/06/iOS%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%A4%84%E7%90%86-%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1Callback-hell-(%E4%B8%80)-%E4%BD%BF%E7%94%A8PromiseKit/</link>
        <guid isPermaLink="true">http://vno.onevcat.com/2016/06/iOS%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%A4%84%E7%90%86-%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1Callback-hell-(%E4%B8%80)-%E4%BD%BF%E7%94%A8PromiseKit/</guid>
        
        <category>iOS</category>
        
        
        <category>iOS</category>
        
      </item>
    
  </channel>
</rss>
