<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <title>深入研究Block捕获外部变量和__block实现原理</title>
  <meta name="description" content="">
  <meta name="author" content="Wei Wang">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="深入研究Block捕获外部变量和__block实现原理">
  <meta name="twitter:description" content="">

  <meta property="og:type" content="article">
  <meta property="og:title" content="深入研究Block捕获外部变量和__block实现原理">
  <meta property="og:description" content="">

  <link rel="icon" type="image/ico" href="/assets/images/favicon.ico" />
  <link href="/assets/images/favicon.ico" rel="shortcut icon" type="image/ico">

  <link rel="stylesheet" href="/css/main.css">
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.6.0/css/font-awesome.min.css" rel="stylesheet">

  <link rel="canonical" href="http://vno.onevcat.com/2016/08/%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6Block%E6%8D%95%E8%8E%B7%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C__block%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">
  <link rel="alternate" type="application/rss+xml" title="Halfrost's Field | 冰霜之地" href="http://vno.onevcat.com/feed.xml">

  <meta name="google-site-verification" content="1-1ZlHoRvM0T2FqPbW2S-qLgYXN6rsn52kErlMPd_gw" />
</head>


  <body>

    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>
    
    <header class="panel-cover panel-cover--collapsed" style="background-image: url('/assets/images/background-cover.jpg')">
  <div class="panel-main">

    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/#blog" title="前往 Halfrost's Field | 冰霜之地 的主页" class="blog-button"><img src="/assets/images/avatar.jpg" width="80" alt="Halfrost's Field | 冰霜之地 logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/#blog" title="link to homepage for Halfrost's Field | 冰霜之地" class="blog-button">Halfrost's Field | 冰霜之地</a></h1>
        
        <span class="panel-cover__subtitle panel-subtitle">一缕殇流化隐半边冰霜</span>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">嗨，我是 @halfrost，一名来自中国的 iOS 开发者，已退役 acmer 。现居上海。吾笃信：德不孤，必有志，技不疏，必有朋。</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />

        

        <div class="navigation-wrapper">
          <div>
            <nav class="cover-navigation cover-navigation--primary">
              <ul class="navigation">

                  

                <li class="navigation__item"><a href="/" title="Home" class="home-button">首页</a></li>
                <li class="navigation__item"><a href="/#blog" title="Visit blog" class="blog-button">博客</a></li>
                
                  <li class="navigation__item"><a href="http://about.halfrost.com" target="_blank" title="About">关于</a></li>
                
              </ul>
            </nav>
          </div>

          <div><nav class="cover-navigation navigation--social">
  <ul class="navigation">

    
    <!-- jianshu-->
    <li class="navigation__item">
      <a href="http://jianshu.com/users/12201cdd5d7a/latest_articles" title="@halfrost 的简书" target="_blank">
        <i class='social fa fa-book'></i>
        <span class="label">jianshu</span>
      </a>
    </li>
    

    
    <!-- juejin-->
    <li class="navigation__item">
      <a href="http://gold.xitu.io/user/5692e1e000b09aa2e8dcd422" title="@halfrost 的稀土掘金" target="_blank">
        <i class='social fa fa-forumbee'></i>
        <span class="label">juejin</span>
      </a>
    </li>
    

  
  <!-- Weibo -->
  <li class="navigation__item">
    <a href="http://weibo.com/halfrost" title="@halfrost 的微博" target="_blank">
      <i class='social fa fa-weibo'></i>
      <span class="label">Weibo</span>
    </a>
  </li>
  

  
  <!-- Github -->
  <li class="navigation__item">
    <a href="https://github.com/halfrost" title="@halfrost 的 Github" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>
  

  

  

  <!-- RSS -->
  <li class="navigation__item">
    <a href="/feed.xml" rel="author" title="RSS" target="_blank">
      <i class='social fa fa-rss'></i>
      <span class="label">RSS</span>
    </a>
  </li>

  
  <!-- Email -->
  <li class="navigation__item">
    <a href="mailto:ydz627@gamil.com" title="Contact me">
      <i class='social fa fa-envelope'></i>
      <span class="label">Email</span>
    </a>
  </li>
  

  </ul>
</nav>
</div>
        </div>
      </div>
    </div>

    
    <div class="panel-cover--overlay cover-black"></div>
    
  </div>
</header>


    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <div class="post-meta">
      <time datetime="2016-08-27 22:05:03+0800" itemprop="datePublished" class="post-meta__date date">2016-08-27</time> &#8226; <span class="post-meta__tags tags">iOS</span>
    </div>
    <h1 class="post-title">深入研究Block捕获外部变量和__block实现原理</h1>
  </header>

  <section class="post">
    <p><img src="http://upload-images.jianshu.io/upload_images/1194012-3b6a5c9d5edb1aae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" /></p>

<h4 id="section">前言</h4>

<p>Blocks是C语言的扩充功能，而Apple 在OS X Snow Leopard 和 iOS 4中引入了这个新功能“Blocks”。从那开始，Block就出现在iOS和Mac系统各个API中，并被大家广泛使用。一句话来形容Blocks，带有自动变量（局部变量）的匿名函数。</p>

<p>Block在OC中的实现如下：</p>

<pre><code class="language-objectivec">
struct Block_layout {
    void *isa;
    int flags;
    int reserved;
    void (*invoke)(void *, ...);
    struct Block_descriptor *descriptor;
    /* Imported variables. */
};

struct Block_descriptor {
    unsigned long int reserved;
    unsigned long int size;
    void (*copy)(void *dst, void *src);
    void (*dispose)(void *);
};
</code></pre>

<p><img src="http://upload-images.jianshu.io/upload_images/1194012-1739b7e85e46b4db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" /></p>

<p>从结构图中很容易看到isa，所以OC处理Block是按照对象来处理的。在iOS中，isa常见的就是_NSConcreteStackBlock，_NSConcreteMallocBlock，_NSConcreteGlobalBlock这3种(另外只在GC环境下还有3种使用的_NSConcreteFinalizingBlock，_NSConcreteAutoBlock，_NSConcreteWeakBlockVariable，本文暂不谈论这3种，有兴趣的看看官方文档)</p>

<p>以上介绍是Block的简要实现，接下来我们来仔细研究一下Block的捕获外部变量的特性以及__block的实现原理。</p>

<p><strong>研究工具：clang</strong>
为了研究编译器的实现原理，我们需要使用 clang 命令。clang 命令可以将 Objetive-C 的源码改写成 C / C++ 语言的，借此可以研究 block 中各个特性的源码实现方式。该命令是</p>

<div class="language-vim highlighter-rouge"><pre class="highlight"><code>clang <span class="p">-</span>rewrite<span class="p">-</span>objc block<span class="p">.</span><span class="k">c</span>

</code></pre>
</div>

<p>####目录
- 1.Block捕获外部变量实质
- 2.Block的copy和release
- 3.Block中__block实现原理</p>

<h4 id="block">一.Block捕获外部变量实质</h4>

<p><img src="http://upload-images.jianshu.io/upload_images/1194012-b7046feffe189bfa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" /></p>

<p>拿起我们的Block一起来捕捉外部变量吧。</p>

<p>说到外部变量，我们要先说一下C语言中变量有哪几种。一般可以分为一下5种：</p>

<ul>
  <li>自动变量</li>
  <li>函数参数</li>
  <li>静态变量</li>
  <li>静态全局变量</li>
  <li>全局变量</li>
</ul>

<p>研究Block的捕获外部变量就要除去函数参数这一项，下面一一根据这4种变量类型的捕获情况进行分析。</p>

<p>我们先根据这4种类型
- 自动变量 
- 静态变量
- 静态全局变量
- 全局变量</p>

<p>写出Block测试代码。</p>

<p><img src="http://upload-images.jianshu.io/upload_images/1194012-cba895ef7fe45179.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" /></p>

<p>这里很快就出现了一个错误，提示说自动变量没有加__block，由于__block有点复杂，我们先实验静态变量，静态全局变量，全局变量这3类。测试代码如下：</p>

<pre><code class="language-objectivec">
#import &lt;Foundation/Foundation.h&gt;

int global_i = 1;

static int static_global_j = 2;

int main(int argc, const char * argv[]) {
   
    static int static_k = 3;
    int val = 4;
    
    void (^myBlock)(void) = ^{
        global_i ++;
        static_global_j ++;
        static_k ++;
        NSLog(@"Block中 global_i = %d,static_global_j = %d,static_k = %d,val = %d",global_i,static_global_j,static_k,val);
    };
    
    global_i ++;
    static_global_j ++;
    static_k ++;
    val ++;
    NSLog(@"Block外 global_i = %d,static_global_j = %d,static_k = %d,val = %d",global_i,static_global_j,static_k,val);
    
    myBlock();
    
    return 0;
}

</code></pre>

<p>运行结果
<code class="highlighter-rouge">vim
Block 外  global_i = 2,static_global_j = 3,static_k = 4,val = 5
Block 中  global_i = 3,static_global_j = 4,static_k = 5,val = 4
</code></p>

<p>这里就有2点需要弄清楚了
1.为什么在Block里面不加__bolck不允许更改变量？
2.为什么自动变量的值没有增加，而其他几个变量的值是增加的？自动变量是什么状态下被block捕获进去的？</p>

<p>为了弄清楚这2点，我们用clang转换一下源码出来分析分析。</p>

<p>（main.m代码行37行，文件大小832bype， 经过clang转换成main.cpp以后，代码行数飙升至104810行，文件大小也变成了3.1MB）</p>

<p>源码如下</p>

<pre><code class="language-objectivec">
int global_i = 1;

static int static_global_j = 2;

struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  int *static_k;
  int val;
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_static_k, int _val, int flags=0) : static_k(_static_k), val(_val) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
  int *static_k = __cself-&gt;static_k; // bound by copy
  int val = __cself-&gt;val; // bound by copy

        global_i ++;
        static_global_j ++;
        (*static_k) ++;
        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_45_k1d9q7c52vz50wz1683_hk9r0000gn_T_main_6fe658_mi_0,global_i,static_global_j,(*static_k),val);
    }

static struct __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};


int main(int argc, const char * argv[]) {

    static int static_k = 3;
    int val = 4;

    void (*myBlock)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;static_k, val));

    global_i ++;
    static_global_j ++;
    static_k ++;
    val ++;
    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_45_k1d9q7c52vz50wz1683_hk9r0000gn_T_main_6fe658_mi_1,global_i,static_global_j,static_k,val);

    ((void (*)(__block_impl *))((__block_impl *)myBlock)-&gt;FuncPtr)((__block_impl *)myBlock);

    return 0;
}
</code></pre>

<p>首先全局变量global_i和静态全局变量static_global_j的值增加，以及它们被Block捕获进去，这一点很好理解，因为是全局的，作用域很广，所以Block捕获了它们进去之后，在Block里面进行++操作，Block结束之后，它们的值依旧可以得以保存下来。</p>

<p>接下来仔细看看自动变量和静态变量的问题。
在__main_block_impl_0中，可以看到静态变量static_k和自动变量val，被Block从外面捕获进来，成为__main_block_impl_0这个结构体的成员变量了。</p>

<p>接着看构造函数，</p>

<pre><code class="language-objectivec">
__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_static_k, int _val, int flags=0) : static_k(_static_k), val(_val)

</code></pre>
<p>这个构造函数中，自动变量和静态变量被捕获为成员变量追加到了构造函数中。</p>

<p>main里面的myBlock闭包中的__main_block_impl_0结构体，初始化如下</p>

<div class="highlighter-rouge"><pre class="highlight"><code>void (*myBlock)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;static_k, val));


impl.isa = &amp;_NSConcreteStackBlock;
impl.Flags = 0;
impl.FuncPtr = __main_block_impl_0; 
Desc = &amp;__main_block_desc_0_DATA;
*_static_k = 4；
val = 4; 
</code></pre>
</div>
<p>到此，__main_block_impl_0结构体就是这样把自动变量捕获进来的。也就是说，在执行Block语法的时候，Block语法表达式所使用的自动变量的值是被保存进了Block的结构体实例中，也就是Block自身中。</p>

<p>这里值得说明的一点是，如果Block外面还有很多自动变量，静态变量，等等，这些变量在Block里面并不会被使用到。那么这些变量并不会被Block捕获进来，也就是说并不会在构造函数里面传入它们的值。</p>

<p>Block捕获外部变量仅仅只捕获Block闭包里面会用到的值，其他用不到的值，它并不会去捕获。</p>

<p>再研究一下源码，我们注意到__main_block_func_0这个函数的实现</p>

<pre><code class="language-objectivec">
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
  int *static_k = __cself-&gt;static_k; // bound by copy
  int val = __cself-&gt;val; // bound by copy

        global_i ++;
        static_global_j ++;
        (*static_k) ++;
        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_45_k1d9q7c52vz50wz1683_hk9r0000gn_T_main_6fe658_mi_0,global_i,static_global_j,(*static_k),val);
    }
</code></pre>

<p>我们可以发现，系统自动给我们加上的注释，bound by copy，自动变量val虽然被捕获进来了，但是是用 __cself-&gt;val来访问的。Block仅仅捕获了val的值，并没有捕获val的内存地址。所以在__main_block_func_0这个函数中即使我们重写这个自动变量val的值，依旧没法去改变Block外面自动变量val的值。</p>

<p>OC可能是基于这一点，在编译的层面就防止开发者可能犯的错误，因为自动变量没法在Block中改变外部变量的值，所以编译过程中就报编译错误。错误就是最开始的那张截图。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Variable is not assignable(missing __block type specifier)

</code></pre>
</div>

<p>小结一下：
到此为止，上面提出的第二个问题就解开答案了。自动变量是以值传递方式传递到Block的构造函数里面去的。Block只捕获Block中会用到的变量。由于只捕获了自动变量的值，并非内存地址，所以Block内部不能改变自动变量的值。Block捕获的外部变量可以改变值的是静态变量，静态全局变量，全局变量。上面例子也都证明过了。</p>

<p>剩下问题一我们还没有解决。</p>

<p>回到上面的例子上面来，4种变量里面只有静态变量，静态全局变量，全局变量这3种是可以在Block里面被改变值的。仔细观看源码，我们能看出这3个变量可以改变值的原因。</p>

<ol>
  <li>
    <p>静态全局变量，全局变量由于作用域的原因，于是可以直接在Block里面被改变。他们也都存储在全局区。
<img src="http://upload-images.jianshu.io/upload_images/1194012-cf406451fc813cdb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" /></p>
  </li>
  <li>
    <p>静态变量传递给Block是内存地址值，所以能在Block里面直接改变值。</p>
  </li>
</ol>

<p>根据<a href="developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Blocks/Articles/bxVariables.html#//apple_ref/doc/uid/TP40007502-CH6-SW1">官方文档</a>我们可以了解到，苹果要求我们在自动变量前加入 <strong>__block</strong>关键字(__block storage-class-specifier存储域类说明符)，就可以在Block里面改变外部自动变量的值了。</p>

<p>总结一下在Block中改变变量值有2种方式，一是传递内存地址指针到Block中，二是改变存储区方式(__block)。</p>

<p>先来实验一下第一种方式，传递内存地址到Block中，改变变量的值。</p>

<pre><code class="language-objectivec">
#import &lt;Foundation/Foundation.h&gt;

int main(int argc, const char * argv[]) {
    
  NSMutableString * str = [[NSMutableString alloc]initWithString:@"Hello,"];
    
        void (^myBlock)(void) = ^{
            [str appendString:@"World!"];
            NSLog(@"Block中 str = %@",str);
        };
    
    NSLog(@"Block外 str = %@",str);
    
    myBlock();
    
    return 0;
}

</code></pre>
<p>控制台输出：</p>

<div class="language-vim highlighter-rouge"><pre class="highlight"><code>Block 外  str <span class="p">=</span> Hello<span class="p">,</span>
Block 中  str <span class="p">=</span> Hello<span class="p">,</span>World<span class="p">!</span>

</code></pre>
</div>
<p>看结果是成功改变了变量的值了，转换一下源码。</p>

<pre><code class="language-objectivec">
struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  NSMutableString *str;
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, NSMutableString *_str, int flags=0) : str(_str) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
  NSMutableString *str = __cself-&gt;str; // bound by copy

            ((void (*)(id, SEL, NSString *))(void *)objc_msgSend)((id)str, sel_registerName("appendString:"), (NSString *)&amp;__NSConstantStringImpl__var_folders_45_k1d9q7c52vz50wz1683_hk9r0000gn_T_main_33ff12_mi_1);
            NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_45_k1d9q7c52vz50wz1683_hk9r0000gn_T_main_33ff12_mi_2,str);
        }
static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;str, (void*)src-&gt;str, 3/*BLOCK_FIELD_IS_OBJECT*/);}

static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;str, 3/*BLOCK_FIELD_IS_OBJECT*/);}

static struct __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);
  void (*dispose)(struct __main_block_impl_0*);
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};

int main(int argc, const char * argv[]) {
    NSMutableString * str = ((NSMutableString *(*)(id, SEL, NSString *))(void *)objc_msgSend)((id)((NSMutableString *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass("NSMutableString"), sel_registerName("alloc")), sel_registerName("initWithString:"), (NSString *)&amp;__NSConstantStringImpl__var_folders_45_k1d9q7c52vz50wz1683_hk9r0000gn_T_main_33ff12_mi_0);

        void (*myBlock)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, str, 570425344));

    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_45_k1d9q7c52vz50wz1683_hk9r0000gn_T_main_33ff12_mi_3,str);

    ((void (*)(__block_impl *))((__block_impl *)myBlock)-&gt;FuncPtr)((__block_impl *)myBlock);

    return 0;
}
</code></pre>
<p>在__main_block_func_0里面可以看到传递的是指针。所以成功改变了变量的值。</p>

<p>至于源码里面的copy和dispose下一节会讲到。</p>

<p>改变外部变量值的第二种方式是加 __block这个放在第三章里面讨论，接下来我们先讨论一下Block的copy的问题，因为这个问题会关系到 __block存储域的问题。</p>

<h4 id="blockcopydispose">二.Block的copy和dispose</h4>

<p><img src="http://upload-images.jianshu.io/upload_images/1194012-244bd60d4cb8ad27.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" /></p>

<p>OC中，一般Block就分为以下3种，_NSConcreteStackBlock，_NSConcreteMallocBlock，_NSConcreteGlobalBlock。</p>

<p>先来说明一下3者的区别。</p>

<h5 id="section-1">1.从捕获外部变量的角度上来看</h5>

<ul>
  <li>
    <p>_NSConcreteStackBlock：
只用到外部局部变量、成员属性变量，且没有强指针引用的block都是StackBlock。
StackBlock的生命周期由系统控制的，一旦返回之后，就被系统销毁了。</p>
  </li>
  <li>
    <p>_NSConcreteMallocBlock：
有强指针引用或copy修饰的成员属性引用的block会被复制一份到堆中成为MallocBlock，没有强指针引用即销毁，生命周期由程序员控制</p>
  </li>
  <li>
    <p>_NSConcreteGlobalBlock：
没有用到外界变量或只用到全局变量、静态变量的block为_NSConcreteGlobalBlock，生命周期从创建到应用程序结束。</p>
  </li>
</ul>

<p>没有用到外部变量肯定是_NSConcreteGlobalBlock，这点很好理解。不过只用到全局变量、静态变量的block也是_NSConcreteGlobalBlock。举例如下：</p>

<pre><code class="language-objectivec">
#import &lt;Foundation/Foundation.h&gt;

int global_i = 1;
static int static_global_j = 2;

int main(int argc, const char * argv[]) {
   
    static int static_k = 3;

    void (^myBlock)(void) = ^{
            NSLog(@"Block中 变量 = %d %d %d",static_global_j ,static_k, global_i);
        };
    
    NSLog(@"%@",myBlock);
    
    myBlock();
    
    return 0;
}

</code></pre>
<p>输出：</p>

<div class="language-vim highlighter-rouge"><pre class="highlight"><code><span class="p">&lt;</span>__NSGlobalBlock__<span class="p">:</span> <span class="m">0</span>x100001050<span class="p">&gt;</span>
Block中 变量 <span class="p">=</span> <span class="m">2</span> <span class="m">3</span> <span class="m">1</span>
</code></pre>
</div>

<p>可见，只用到全局变量、静态变量的block也可以是_NSConcreteGlobalBlock。</p>

<p>所以在ARC环境下，3种类型都可以捕获外部变量。</p>

<h5 id="section-2">2.从持有对象的角度上来看：</h5>

<ul>
  <li>_NSConcreteStackBlock是不持有对象的。</li>
</ul>

<pre><code class="language-objectivec">
//以下是在MRC下执行的
    NSObject * obj = [[NSObject alloc]init];
    NSLog(@"1.Block外 obj = %lu",(unsigned long)obj.retainCount);
    
    void (^myBlock)(void) = ^{
        NSLog(@"Block中 obj = %lu",(unsigned long)obj.retainCount);
    };
    
    NSLog(@"2.Block外 obj = %lu",(unsigned long)obj.retainCount);
    
    myBlock();
</code></pre>

<p>输出：</p>

<div class="language-vim highlighter-rouge"><pre class="highlight"><code><span class="m">1</span><span class="p">.</span>Block外 obj <span class="p">=</span> <span class="m">1</span>
<span class="m">2</span><span class="p">.</span>Block外 obj <span class="p">=</span> <span class="m">1</span>
Block中 obj <span class="p">=</span> <span class="m">1</span>
</code></pre>
</div>

<ul>
  <li>_NSConcreteMallocBlock是持有对象的。</li>
</ul>

<pre><code class="language-objectivec">//以下是在MRC下执行的
    NSObject * obj = [[NSObject alloc]init];
    NSLog(@"1.Block外 obj = %lu",(unsigned long)obj.retainCount);
    
    void (^myBlock)(void) = [^{
        NSLog(@"Block中 obj = %lu",(unsigned long)obj.retainCount);
    }copy];
    
    NSLog(@"2.Block外 obj = %lu",(unsigned long)obj.retainCount);
    
    myBlock();
    
    [myBlock release];
    
    NSLog(@"3.Block外 obj = %lu",(unsigned long)obj.retainCount);
</code></pre>

<p>输出：</p>

<div class="language-vim highlighter-rouge"><pre class="highlight"><code><span class="m">1</span><span class="p">.</span>Block外 obj <span class="p">=</span> <span class="m">1</span>
<span class="m">2</span><span class="p">.</span>Block外 obj <span class="p">=</span> <span class="m">2</span>
Block中 obj <span class="p">=</span> <span class="m">2</span>
<span class="m">3</span><span class="p">.</span>Block外 obj <span class="p">=</span> <span class="m">1</span>
</code></pre>
</div>

<ul>
  <li>_NSConcreteGlobalBlock也不持有对象</li>
</ul>

<pre><code class="language-objectivec">//以下是在MRC下执行的
    void (^myBlock)(void) = ^{
        
        NSObject * obj = [[NSObject alloc]init];
        NSLog(@"Block中 obj = %lu",(unsigned long)obj.retainCount);
    };
    
    myBlock();

</code></pre>

<p>输出：</p>

<div class="language-vim highlighter-rouge"><pre class="highlight"><code>
Block 中 obj <span class="p">=</span> <span class="m">1</span>
</code></pre>
</div>

<p>由于_NSConcreteStackBlock所属的变量域一旦结束，那么该Block就会被销毁。在ARC环境下，编译器会自动的判断，把Block自动的从栈copy到堆。比如当Block作为函数返回值的时候，肯定会copy到堆上。</p>

<p>1.手动调用copy
2.Block是函数的返回值
3.Block被强引用，Block被赋值给__strong或者id类型
4.调用系统API入参中含有usingBlcok的方法</p>

<p>以上4种情况，系统都会默认调用copy方法把Block赋复制</p>

<p>但是当Block为函数参数的时候，就需要我们手动的copy一份到堆上了。这里除去系统的API我们不需要管，比如GCD等方法中本身带usingBlock的方法，其他我们自定义的方法传递Block为参数的时候都需要手动copy一份到堆上。</p>

<p>copy函数把Block从栈上拷贝到堆上，dispose函数是把堆上的函数在废弃的时候销毁掉。</p>

<pre><code class="language-objectivec">
#define Block_copy(...) ((__typeof(__VA_ARGS__))_Block_copy((const void *)(__VA_ARGS__)))
#define Block_release(...) _Block_release((const void *)(__VA_ARGS__))

// Create a heap based copy of a Block or simply add a reference to an existing one.
// This must be paired with Block_release to recover memory, even when running
// under Objective-C Garbage Collection.
BLOCK_EXPORT void *_Block_copy(const void *aBlock)
    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);

// Lose the reference, and if heap based and last reference, recover the memory
BLOCK_EXPORT void _Block_release(const void *aBlock)
    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);

// Used by the compiler. Do not call this function yourself.
BLOCK_EXPORT void _Block_object_assign(void *, const void *, const int)
    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);

// Used by the compiler. Do not call this function yourself.
BLOCK_EXPORT void _Block_object_dispose(const void *, const int)
    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);
</code></pre>

<p>上面是源码中2个常用的宏定义和4个常用的方法，一会我们就会看到这4个方法。</p>

<pre><code class="language-objectivec">
static void *_Block_copy_internal(const void *arg, const int flags) {
    struct Block_layout *aBlock;
    const bool wantsOne = (WANTS_ONE &amp; flags) == WANTS_ONE;
    
    // 1
    if (!arg) return NULL;
    
    // 2
    aBlock = (struct Block_layout *)arg;
    
    // 3
    if (aBlock-&gt;flags &amp; BLOCK_NEEDS_FREE) {
        // latches on high
        latching_incr_int(&amp;aBlock-&gt;flags);
        return aBlock;
    }
    
    // 4
    else if (aBlock-&gt;flags &amp; BLOCK_IS_GLOBAL) {
        return aBlock;
    }
    
    // 5
    struct Block_layout *result = malloc(aBlock-&gt;descriptor-&gt;size);
    if (!result) return (void *)0;
    
    // 6
    memmove(result, aBlock, aBlock-&gt;descriptor-&gt;size); // bitcopy first
    
    // 7
    result-&gt;flags &amp;= ~(BLOCK_REFCOUNT_MASK);    // XXX not needed
    result-&gt;flags |= BLOCK_NEEDS_FREE | 1;
    
    // 8
    result-&gt;isa = _NSConcreteMallocBlock;
    
    // 9
    if (result-&gt;flags &amp; BLOCK_HAS_COPY_DISPOSE) {
        (*aBlock-&gt;descriptor-&gt;copy)(result, aBlock); // do fixup
    }
    
    return result;
}
</code></pre>

<p>上面这一段是Block_copy的一个实现，实现了从_NSConcreteStackBlock复制到_NSConcreteMallocBlock的过程。对应有9个步骤。</p>

<pre><code class="language-objectivec">
void _Block_release(void *arg) {
    // 1
    struct Block_layout *aBlock = (struct Block_layout *)arg;
    if (!aBlock) return;
    
    // 2
    int32_t newCount;
    newCount = latching_decr_int(&amp;aBlock-&gt;flags) &amp; BLOCK_REFCOUNT_MASK;
    
    // 3
    if (newCount &gt; 0) return;
    
    // 4
    if (aBlock-&gt;flags &amp; BLOCK_NEEDS_FREE) {
        if (aBlock-&gt;flags &amp; BLOCK_HAS_COPY_DISPOSE)(*aBlock-&gt;descriptor-&gt;dispose)(aBlock);
        _Block_deallocator(aBlock);
    }
    
    // 5
    else if (aBlock-&gt;flags &amp; BLOCK_IS_GLOBAL) {
        ;
    }
    
    // 6
    else {
        printf("Block_release called upon a stack Block: %p, ignored\\\\n", (void *)aBlock);
    }
}
</code></pre>

<p>上面这一段是Block_release的一个实现，实现了怎么释放一个Block。对应有6个步骤。</p>

<p>上述2个方法的详细解析可以看这篇<a href="http://www.galloway.me.uk/2013/05/a-look-inside-blocks-episode-3-block-copy/">文章</a></p>

<p>回到上一章节中最后的例子，字符串的例子中来，转换源码之后，我们会发现多了一个copy和dispose方法。</p>

<p>因为在C语言的结构体中，编译器没法很好的进行初始化和销毁操作。这样对内存管理来说是很不方便的。所以就在 __main_block_desc_0结构体中间增加成员变量 void (*copy)(struct  __main_block_impl_0*, struct __main_block_impl_0*)和void (*dispose)(struct __main_block_impl_0*)，利用OC的Runtime进行内存管理。</p>

<p>相应的增加了2个方法。</p>

<pre><code class="language-objectivec">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;str, (void*)src-&gt;str, 3/*BLOCK_FIELD_IS_OBJECT*/);}

static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;str, 3/*BLOCK_FIELD_IS_OBJECT*/);}

</code></pre>
<p>这里的_Block_object_assign和_Block_object_dispose就对应着retain和release方法。</p>

<p>BLOCK_FIELD_IS_OBJECT 是Block截获对象时候的特殊标示，如果是截获的__block，那么是BLOCK_FIELD_IS_BYREF。</p>

<h4 id="blockblock">三.Block中__block实现原理</h4>

<p>我们继续研究一下__block实现原理。</p>

<h5 id="section-3">1.普通非对象的变量</h5>

<p>先来看看普通变量的情况。</p>

<pre><code class="language-objectivec">
#import &lt;Foundation/Foundation.h&gt;

int main(int argc, const char * argv[]) {
    
    __block int i = 0;
    
    void (^myBlock)(void) = ^{
        i ++;
        NSLog(@"%d",i);
    };
    
    myBlock();
    
    return 0;
}
</code></pre>
<p>把上述代码用clang转换成源码。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>
struct __Block_byref_i_0 {
  void *__isa;
__Block_byref_i_0 *__forwarding;
 int __flags;
 int __size;
 int i;
};

struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  __Block_byref_i_0 *i; // by ref
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_i_0 *_i, int flags=0) : i(_i-&gt;__forwarding) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
  __Block_byref_i_0 *i = __cself-&gt;i; // bound by ref

        (i-&gt;__forwarding-&gt;i) ++;
        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_45_k1d9q7c52vz50wz1683_hk9r0000gn_T_main_3b0837_mi_0,(i-&gt;__forwarding-&gt;i));
    }
static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;i, (void*)src-&gt;i, 8/*BLOCK_FIELD_IS_BYREF*/);}

static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;i, 8/*BLOCK_FIELD_IS_BYREF*/);}

static struct __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);
  void (*dispose)(struct __main_block_impl_0*);
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};
int main(int argc, const char * argv[]) {
    __attribute__((__blocks__(byref))) __Block_byref_i_0 i = {(void*)0,(__Block_byref_i_0 *)&amp;i, 0, sizeof(__Block_byref_i_0), 0};

    void (*myBlock)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_i_0 *)&amp;i, 570425344));

    ((void (*)(__block_impl *))((__block_impl *)myBlock)-&gt;FuncPtr)((__block_impl *)myBlock);

    return 0;
}
</code></pre>
</div>
<p>从源码我们能发现，带有 __block的变量也被转化成了一个结构体__Block_byref_i_0,这个结构体有5个成员变量。第一个是isa指针，第二个是指向自身类型的__forwarding指针，第三个是一个标记flag，第四个是它的大小，第五个是变量值，名字和变量名同名。</p>

<pre><code class="language-objectivec">__attribute__((__blocks__(byref))) __Block_byref_i_0 i = {(void*)0,(__Block_byref_i_0 *)&amp;i, 0, sizeof(__Block_byref_i_0), 0};

</code></pre>
<p>源码中是这样初始化的。__forwarding指针初始化传递的是自己的地址。然而这里__forwarding指针真的永远指向自己么？我们来做一个实验。</p>

<pre><code class="language-objectivec">
//以下代码在MRC中运行
    __block int i = 0;
    NSLog(@"%p",&amp;i);
    
    void (^myBlock)(void) = [^{
        i ++;
        NSLog(@"这是Block 里面%p",&amp;i);
    }copy];

</code></pre>
<p>我们把Block拷贝到了堆上，这个时候打印出来的2个i变量的地址就不同了。</p>

<div class="language-vim highlighter-rouge"><pre class="highlight"><code><span class="m">0</span>x7fff5fbff818
<span class="p">&lt;</span>__NSMallocBlock__<span class="p">:</span> <span class="m">0</span>x100203cc0<span class="p">&gt;</span>
这是Block 里面 <span class="m">0</span>x1002038a8
</code></pre>
</div>

<p>地址不同就可以很明显的说明__forwarding指针并没有指向之前的自己了。那__forwarding指针现在指向到哪里了呢？</p>

<p>Block里面的__block的地址和Block的地址就相差1052。我们可以很大胆的猜想，__block现在也在堆上了。</p>

<p>出现这个不同的原因在于这里把Block拷贝到了堆上。</p>

<p>由第二章里面详细分析的，堆上的Block会持有对象。我们把Block通过copy到了堆上，堆上也会重新复制一份Block，并且该Block也会继续持有该__block。当Block释放的时候，__block没有被任何对象引用，也会被释放销毁。</p>

<p>__forwarding指针这里的作用就是针对堆的Block，把原来__forwarding指针指向自己，换成指向_NSConcreteMallocBlock上复制之后的__block自己。然后堆上的变量的__forwarding再指向自己。这样不管__block怎么复制到堆上，还是在栈上，都可以通过(i-&gt;__forwarding-&gt;i)来访问到变量值。</p>

<p><img src="http://upload-images.jianshu.io/upload_images/1194012-5f5f486bab68191f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" />
所以在__main_block_func_0函数里面就是写的(i-&gt;__forwarding-&gt;i)。</p>

<p>这里还有一个需要注意的地方。还是从例子说起：</p>

<pre><code class="language-objectivec">//以下代码在MRC中运行
    __block int i = 0;
    NSLog(@"%p",&amp;i);
    
    void (^myBlock)(void) = ^{
        i ++;
        NSLog(@"Block 里面的%p",&amp;i);
    };
    
    
    NSLog(@"%@",myBlock);
    
    myBlock();

</code></pre>

<p>结果和之前copy的例子完全不同。</p>

<div class="language-vim highlighter-rouge"><pre class="highlight"><code>
 <span class="m">0</span>x7fff5fbff818
<span class="p">&lt;</span>__NSStackBlock__<span class="p">:</span> <span class="m">0</span>x7fff5fbff7c0<span class="p">&gt;</span>**
 <span class="m">0</span>x7fff5fbff818

</code></pre>
</div>

<p>Block在捕获住__block变量之后，并不会复制到堆上，所以地址也一直都在栈上。这与ARC环境下的不一样。</p>

<p><del>ARC环境下，不管有没有copy，__block都会变copy到堆上，Block也是__NSMallocBlock。</del></p>

<p>感谢@酷酷的哀殿 指出错误，感谢@bestswifter 指点。上述说法有点不妥，详细见文章末尾更新。</p>

<p>ARC环境下，一旦Block赋值就会触发copy，__block就会copy到堆上，Block也是__NSMallocBlock。ARC环境下也是存在__NSStackBlock的时候，这种情况下，__block就在栈上。</p>

<p>MRC环境下，只有copy，__block才会被复制到堆上，否则，__block一直都在栈上，block也只是__NSStackBlock，这个时候__forwarding指针就只指向自己了。</p>

<p><img src="http://upload-images.jianshu.io/upload_images/1194012-5e5ae21bfacf7b91.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" /></p>

<p>至此，文章开头提出的问题一，也解答了。__block的实现原理也已经明了。</p>

<h5 id="section-4">2.对象的变量</h5>

<p>还是先举一个例子：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>
//以下代码是在ARC下执行的
#import &lt;Foundation/Foundation.h&gt;

int main(int argc, const char * argv[]) {
     
    __block id block_obj = [[NSObject alloc]init];
    id obj = [[NSObject alloc]init];

    NSLog(@"block_obj = [%@ , %p] , obj = [%@ , %p]",block_obj , &amp;block_obj , obj , &amp;obj);
    
    void (^myBlock)(void) = ^{
        NSLog(@"***Block中****block_obj = [%@ , %p] , obj = [%@ , %p]",block_obj , &amp;block_obj , obj , &amp;obj);
    };
    
    myBlock();
   
    return 0;
}

</code></pre>
</div>

<p>输出</p>

<div class="highlighter-rouge"><pre class="highlight"><code>
block_obj = [&lt;NSObject: 0x100b027d0&gt; , 0x7fff5fbff7e8] , obj = [&lt;NSObject: 0x100b03b50&gt; , 0x7fff5fbff7b8]
Block****中********block_obj = [&lt;NSObject: 0x100b027d0&gt; , 0x100f000a8] , obj = [&lt;NSObject: 0x100b03b50&gt; , 0x100f00070]

</code></pre>
</div>

<p>我们把上面的代码转换成源码研究一下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>
struct __Block_byref_block_obj_0 {
  void *__isa;
__Block_byref_block_obj_0 *__forwarding;
 int __flags;
 int __size;
 void (*__Block_byref_id_object_copy)(void*, void*);
 void (*__Block_byref_id_object_dispose)(void*);
 id block_obj;
};

struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  id obj;
  __Block_byref_block_obj_0 *block_obj; // by ref
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, id _obj, __Block_byref_block_obj_0 *_block_obj, int flags=0) : obj(_obj), block_obj(_block_obj-&gt;__forwarding) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
  __Block_byref_block_obj_0 *block_obj = __cself-&gt;block_obj; // bound by ref
  id obj = __cself-&gt;obj; // bound by copy

        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_45_k1d9q7c52vz50wz1683_hk9r0000gn_T_main_e64910_mi_1,(block_obj-&gt;__forwarding-&gt;block_obj) , &amp;(block_obj-&gt;__forwarding-&gt;block_obj) , obj , &amp;obj);
    }
static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;block_obj, (void*)src-&gt;block_obj, 8/*BLOCK_FIELD_IS_BYREF*/);_Block_object_assign((void*)&amp;dst-&gt;obj, (void*)src-&gt;obj, 3/*BLOCK_FIELD_IS_OBJECT*/);}

static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;block_obj, 8/*BLOCK_FIELD_IS_BYREF*/);_Block_object_dispose((void*)src-&gt;obj, 3/*BLOCK_FIELD_IS_OBJECT*/);}

static struct __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);
  void (*dispose)(struct __main_block_impl_0*);
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};


int main(int argc, const char * argv[]) {

    __attribute__((__blocks__(byref))) __Block_byref_block_obj_0 block_obj = {(void*)0,(__Block_byref_block_obj_0 *)&amp;block_obj, 33554432, sizeof(__Block_byref_block_obj_0), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131, ((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass("NSObject"), sel_registerName("alloc")), sel_registerName("init"))};

    id obj = ((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass("NSObject"), sel_registerName("alloc")), sel_registerName("init"));
    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_45_k1d9q7c52vz50wz1683_hk9r0000gn_T_main_e64910_mi_0,(block_obj.__forwarding-&gt;block_obj) , &amp;(block_obj.__forwarding-&gt;block_obj) , obj , &amp;obj);

    void (*myBlock)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, obj, (__Block_byref_block_obj_0 *)&amp;block_obj, 570425344));

    ((void (*)(__block_impl *))((__block_impl *)myBlock)-&gt;FuncPtr)((__block_impl *)myBlock);

    return 0;
}
</code></pre>
</div>

<p>首先需要说明的一点是对象在OC中，默认声明自带__strong所有权修饰符的，所以main开头我们声明的</p>

<div class="highlighter-rouge"><pre class="highlight"><code>
__block id block_obj = [[NSObject alloc]init];
id obj = [[NSObject alloc]init];

</code></pre>
</div>
<p>等价于</p>

<div class="highlighter-rouge"><pre class="highlight"><code>
__block id __strong block_obj = [[NSObject alloc]init];
id __strong obj = [[NSObject alloc]init];
</code></pre>
</div>

<p>在转换出来的源码中，我们也可以看到，Block捕获了__block，并且强引用了，因为在__Block_byref_block_obj_0结构体中，有一个变量是id block_obj，这个默认也是带__strong所有权修饰符的。</p>

<p>根据打印出来的结果来看，ARC环境下，Block捕获外部对象变量，是都会copy一份的，地址都不同。只不过带有__block修饰符的变量会被捕获到Block内部持有。</p>

<p>我们再来看看MRC环境下的情况，还是将上述代码的例子运行在MRC中。</p>

<p>输出：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>
block_obj = [&lt;NSObject: 0x100b001b0&gt; , 0x7fff5fbff7e8] , obj = [&lt;NSObject: 0x100b001c0&gt; , 0x7fff5fbff7b8]
Block****中********block_obj = [&lt;NSObject: 0x100b001b0&gt; , 0x7fff5fbff7e8] , obj = [&lt;NSObject: 0x100b001c0&gt; , 0x7fff5fbff790]

</code></pre>
</div>

<p>这个时候block在栈上，__NSStackBlock__，可以打印出来retainCount值都是1。当把这个block copy一下，就变成__NSMallocBlock__，对象的retainCount值就会变成2了。</p>

<p>总结：</p>

<p>在MRC环境下，__block根本不会对指针所指向的对象执行copy操作，而只是把指针进行的复制。
而在ARC环境下，对于声明为__block的外部对象，在block内部会进行retain，以至于在block环境内能安全的引用外部对象，所以才会产生循环引用的问题！</p>

<h4 id="section-5">最后</h4>

<p>关于Block捕获外部变量有很多用途，用途也很广，只有弄清了捕获变量和持有的变量的概念以后，之后才能清楚的解决Block循环引用的问题。</p>

<p>再次回到文章开头，5种变量，自动变量，函数参数 ，静态变量，静态全局变量，全局变量，如果严格的来说，捕获是必须在Block结构体__main_block_impl_0里面有成员变量的话，Block能捕获的变量就只有带有自动变量和静态变量了。捕获进Block的对象会被Block持有。</p>

<p>对于非对象的变量来说，</p>

<p>自动变量的值，被copy进了Block，不带__block的自动变量只能在里面被访问，并不能改变值。<br />
<img src="http://upload-images.jianshu.io/upload_images/1194012-9c34ab1560e75504.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" /></p>

<p>带__block的自动变量 和 静态变量 就是直接地址访问。所以在Block里面可以直接改变变量的值。<br />
<img src="http://upload-images.jianshu.io/upload_images/1194012-455842213775d7dd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" /></p>

<p>而剩下的静态全局变量，全局变量，函数参数，也是可以在直接在Block中改变变量值的，但是他们并没有变成Block结构体__main_block_impl_0的成员变量，因为他们的作用域大，所以可以直接更改他们的值。</p>

<p>值得注意的是，静态全局变量，全局变量，函数参数他们并不会被Block持有，也就是说不会增加retainCount值。</p>

<p>对于对象来说，</p>

<p>在MRC环境下，__block根本不会对指针所指向的对象执行copy操作，而只是把指针进行的复制。
而在ARC环境下，对于声明为__block的外部对象，在block内部会进行retain，以至于在block环境内能安全的引用外部对象。</p>

<p>请大家多多指点。</p>

<p><strong>更新</strong></p>

<p>在ARC环境下，Block也是存在__NSStackBlock的时候的，平时见到最多的是_NSConcreteMallocBlock，是因为我们会对Block有赋值操作，所以ARC下，block 类型通过=进行传递时，会导致调用objc_retainBlock-&gt;_Block_copy-&gt;_Block_copy_internal方法链。并导致 __NSStackBlock__ 类型的 block 转换为 __NSMallocBlock__ 类型。</p>

<p>举例如下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>
#import &lt;Foundation/Foundation.h&gt;

int main(int argc, const char * argv[]) {
    
    __block int temp = 10;
    
    NSLog(@"%@",^{NSLog(@"*******%d %p",temp ++,&amp;temp);});
   
    return 0;
}
</code></pre>
</div>

<p>输出</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;__NSStackBlock__: 0x7fff5fbff768&gt;
</code></pre>
</div>

<p>这种情况就是ARC环境下Block是__NSStackBlock的类型。</p>

  </section>
</article>

<section class="read-more">
   
   
   <div class="read-more-item">
       <span class="read-more-item-dim">最近的文章</span>
       <h2 class="post-list__post-title post-title"><a href="/2016/09/%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6Block%E7%94%A8weakSelf-strongSelf-@weakify-@strongify%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/" title="link to 深入研究Block用weakSelf、strongSelf、@weakify、@strongify解决循环引用">深入研究Block用weakSelf、strongSelf、@weakify、@strongify解决循环引用</a></h2>
       <p class="excerpt">前言在上篇中，仔细分析了一下Block的实现原理以及__block捕获外部变量的原理。然而实际使用Block过程中，还是会遇到一些问题，比如Retain Circle的问题。目录  1.Retain Circle的由来  2.__weak、__strong的实现原理  3.weakSelf、strongSelf的用途  4.@weakify、@strongify实现原理一. Retain Circle的由来循环引用的问题相信大家都很理解了，这里还是简单的提一下。当A对象里面强引用了B对象，...&hellip;</p>
       <div class="post-list__meta"><time datetime="2016-09-06 07:02:03+0800" class="post-list__meta--date date">2016-09-05</time> &#8226; <span class="post-list__meta--tags tags">iOS</span><a class="btn-border-small" href=/2016/09/%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6Block%E7%94%A8weakSelf-strongSelf-@weakify-@strongify%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/>继续阅读</a></div>
   </div>
   
   
   
   
   <div class="read-more-item">
       <span class="read-more-item-dim">更早的文章</span>
       <h2 class="post-list__post-title post-title"><a href="/2016/08/%E7%BB%99iOS-%E6%A8%A1%E6%8B%9F%E5%99%A8-%E5%AE%89%E8%A3%85-app%E6%96%87%E4%BB%B6/" title="link to 给iOS 模拟器“安装”app文件">给iOS 模拟器“安装”app文件</a></h2>
       <p class="excerpt">前言刚刚接触iOS的时候，我就一直很好奇，模拟器上面能不能直接安装app呢？如果可以，我们就直接在模拟器上面聊QQ和微信了。直到昨天和朋友们聊到了这个话题，没有想到还真的可以给模拟器“安装”app！一.应用场景先来谈谈是什么情况下，会有在模拟器上安装app的需求。在一个大公司里，对源码的管理有严格的制度，非开发人员是没有权限接触到源码的。对苹果的开发证书管理也非常严格，甚至连开发人员也没有发布证书，证书只在持续集成环境或者Appstore产线里面，或者只在最后打包上架的人手上。那么现在就有...&hellip;</p>
       <div class="post-list__meta"><time datetime="2016-08-19 18:58:03+0800" class="post-list__meta--date date">2016-08-18</time> &#8226; <span class="post-list__meta--tags tags">iOS</span><a class="btn-border-small" href=/2016/08/%E7%BB%99iOS-%E6%A8%A1%E6%8B%9F%E5%99%A8-%E5%AE%89%E8%A3%85-app%E6%96%87%E4%BB%B6/>继续阅读</a></div>
   </div>
   
</section>

<section class="post-comments">
  
    <div id="disqus_thread"></div>
    <script>
    
    var disqus_config = function () {
        this.page.url = "http://vno.onevcat.com/2016/08/%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6Block%E6%8D%95%E8%8E%B7%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C__block%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/";
        this.page.identifier = "/2016/08/%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6Block%E6%8D%95%E8%8E%B7%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C__block%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/";
    };

    var disqus_shortname = 'halfrostsfield';
    
    (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();
    </script>
    <noscript>要查看<a href="http://disqus.com/?ref_noscript"> Disqus </a>评论，请启用 JavaScript</noscript>
    
  
  
  
  
</section>


            <section class="footer">
    <footer>
      <span class="footer__copyright">友情链接 ：<a href="https://desgard.com/">Guardia · 瓜地</a>    <a href="https://bestswifter.com/">bestswifter</a>  <a href="http://kuailejim.com/">kuailejim</a>  <a href="http://valiantcat.com/">南栀倾寒</a>  <a href="http://www.jianshu.com/users/9c51a213b02e">Martin_Joy</a>  <a href="http://bluelich.com/">bluelich</a>  <a href="http://yuyang.myportfolio.com/">yuy</a>  </span>
      <br>
      <br>
    	<span class="footer__copyright">本站点采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议</a></span>
        <span class="footer__copyright">由 <a href="https://jekyllrb.com">Jekyll</a> 于 2016-09-07 生成，感谢<a href="https://pages.github.com"> GitHub Pages</a> 强力驱动</span>
        <span class="footer__copyright">本站由 <a href="http://halfrost.com">@halfrost</a> 创建，采用 <a href="https://github.com/onevcat/vno-jekyll">Vno - Jekyll</a> 作为主题，您可以在 GitHub 找到<a href="https://github.com/onevcat/OneV-s-Den">本站源码</a> - &copy; 2016</span>
    </footer>
</section>

        </div>
    </div>
    
    <script type="text/javascript" src="//code.jquery.com/jquery-1.11.3.min.js"></script>

<script type="text/javascript" src="/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<script type="text/javascript" src="/js/main.js"></script>



    
  </body>

</html>
